var $jscomp = $jscomp || {};
$jscomp.scope = {};
$jscomp.ASSUME_ES5 = !1;
$jscomp.ASSUME_NO_NATIVE_MAP = !1;
$jscomp.ASSUME_NO_NATIVE_SET = !1;
$jscomp.SIMPLE_FROUND_POLYFILL = !1;
$jscomp.ISOLATE_POLYFILLS = !1;
$jscomp.FORCE_POLYFILL_PROMISE = !1;
$jscomp.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION = !1;
$jscomp.defineProperty = $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty: function(H, N, A) {
    if (H == Array.prototype || H == Object.prototype) return H;
    H[N] = A.value;
    return H
};
$jscomp.getGlobal = function(H) {
    H = ["object" == typeof globalThis && globalThis, H, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof global && global];
    for (var N = 0; N < H.length; ++N) {
        var A = H[N];
        if (A && A.Math == Math) return A
    }
    throw Error("Cannot find global object");
};
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.IS_SYMBOL_NATIVE = "function" === typeof Symbol && "symbol" === typeof Symbol("x");
$jscomp.TRUST_ES6_POLYFILLS = !$jscomp.ISOLATE_POLYFILLS || $jscomp.IS_SYMBOL_NATIVE;
$jscomp.polyfills = {};
$jscomp.propertyToPolyfillSymbol = {};
$jscomp.POLYFILL_PREFIX = "$jscp$";
var $jscomp$lookupPolyfilledValue = function(H, N) {
    var A = $jscomp.propertyToPolyfillSymbol[N];
    if (null == A) return H[N];
    A = H[A];
    return void 0 !== A ? A: H[N]
};
$jscomp.polyfill = function(H, N, A, K) {
    N && ($jscomp.ISOLATE_POLYFILLS ? $jscomp.polyfillIsolated(H, N, A, K) : $jscomp.polyfillUnisolated(H, N, A, K))
};
$jscomp.polyfillUnisolated = function(H, N, A, K) {
    A = $jscomp.global;
    H = H.split(".");
    for (K = 0; K < H.length - 1; K++) {
        var J = H[K];
        if (! (J in A)) return;
        A = A[J]
    }
    H = H[H.length - 1];
    K = A[H];
    N = N(K);
    N != K && null != N && $jscomp.defineProperty(A, H, {
        configurable: !0,
        writable: !0,
        value: N
    })
};
$jscomp.polyfillIsolated = function(H, N, A, K) {
    var J = H.split(".");
    H = 1 === J.length;
    K = J[0];
    K = !H && K in $jscomp.polyfills ? $jscomp.polyfills: $jscomp.global;
    for (var V = 0; V < J.length - 1; V++) {
        var Z = J[V];
        if (! (Z in K)) return;
        K = K[Z]
    }
    J = J[J.length - 1];
    A = $jscomp.IS_SYMBOL_NATIVE && "es6" === A ? K[J] : null;
    N = N(A);
    null != N && (H ? $jscomp.defineProperty($jscomp.polyfills, J, {
        configurable: !0,
        writable: !0,
        value: N
    }) : N !== A && ($jscomp.propertyToPolyfillSymbol[J] = $jscomp.IS_SYMBOL_NATIVE ? $jscomp.global.Symbol(J) : $jscomp.POLYFILL_PREFIX + J, J = $jscomp.propertyToPolyfillSymbol[J], $jscomp.defineProperty(K, J, {
        configurable: !0,
        writable: !0,
        value: N
    })))
};
$jscomp.polyfill("Array.from",
function(H) {
    return H ? H: function(N, A, K) {
        A = null != A ? A: function(pb) {
            return pb
        };
        var J = [],
        V = "undefined" != typeof Symbol && Symbol.iterator && N[Symbol.iterator];
        if ("function" == typeof V) {
            N = V.call(N);
            for (var Z = 0; ! (V = N.next()).done;) J.push(A.call(K, V.value, Z++))
        } else for (V = N.length, Z = 0; Z < V; Z++) J.push(A.call(K, N[Z], Z));
        return J
    }
},
"es6", "es3");
$jscomp.underscoreProtoCanBeSet = function() {
    var H = {
        a: !0
    },
    N = {};
    try {
        return N.__proto__ = H,
        N.a
    } catch(A) {}
    return ! 1
};
$jscomp.setPrototypeOf = $jscomp.TRUST_ES6_POLYFILLS && "function" == typeof Object.setPrototypeOf ? Object.setPrototypeOf: $jscomp.underscoreProtoCanBeSet() ?
function(H, N) {
    H.__proto__ = N;
    if (H.__proto__ !== N) throw new TypeError(H + " is not extensible");
    return H
}: null;
$jscomp.polyfill("Object.setPrototypeOf",
function(H) {
    return H || $jscomp.setPrototypeOf
},
"es6", "es5");
$jscomp.polyfill("Reflect",
function(H) {
    return H ? H: {}
},
"es6", "es3");
$jscomp.objectCreate = $jscomp.ASSUME_ES5 || "function" == typeof Object.create ? Object.create: function(H) {
    var N = function() {};
    N.prototype = H;
    return new N
};
$jscomp.getConstructImplementation = function() {
    function H() {
        function A() {}
        new A;
        Reflect.construct(A, [],
        function() {});
        return new A instanceof A
    }
    if ($jscomp.TRUST_ES6_POLYFILLS && "undefined" != typeof Reflect && Reflect.construct) {
        if (H()) return Reflect.construct;
        var N = Reflect.construct;
        return function(A, K, J) {
            A = N(A, K);
            J && Reflect.setPrototypeOf(A, J.prototype);
            return A
        }
    }
    return function(A, K, J) {
        void 0 === J && (J = A);
        J = $jscomp.objectCreate(J.prototype || Object.prototype);
        return Function.prototype.apply.call(A, J, K) || J
    }
};
$jscomp.construct = {
    valueOf: $jscomp.getConstructImplementation
}.valueOf();
$jscomp.polyfill("Reflect.construct",
function(H) {
    return $jscomp.construct
},
"es6", "es3");
$jscomp.arrayIteratorImpl = function(H) {
    var N = 0;
    return function() {
        return N < H.length ? {
            done: !1,
            value: H[N++]
        }: {
            done: !0
        }
    }
};
$jscomp.arrayIterator = function(H) {
    return {
        next: $jscomp.arrayIteratorImpl(H)
    }
};
$jscomp.initSymbol = function() {};
$jscomp.polyfill("Symbol",
function(H) {
    if (H) return H;
    var N = function(J, V) {
        this.$jscomp$symbol$id_ = J;
        $jscomp.defineProperty(this, "description", {
            configurable: !0,
            writable: !0,
            value: V
        })
    };
    N.prototype.toString = function() {
        return this.$jscomp$symbol$id_
    };
    var A = 0,
    K = function(J) {
        if (this instanceof K) throw new TypeError("Symbol is not a constructor");
        return new N("jscomp_symbol_" + (J || "") + "_" + A++, J)
    };
    return K
},
"es6", "es3");
$jscomp.polyfill("Symbol.iterator",
function(H) {
    if (H) return H;
    H = Symbol("Symbol.iterator");
    for (var N = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), A = 0; A < N.length; A++) {
        var K = $jscomp.global[N[A]];
        "function" === typeof K && "function" != typeof K.prototype[H] && $jscomp.defineProperty(K.prototype, H, {
            configurable: !0,
            writable: !0,
            value: function() {
                return $jscomp.iteratorPrototype($jscomp.arrayIteratorImpl(this))
            }
        })
    }
    return H
},
"es6", "es3");
$jscomp.iteratorPrototype = function(H) {
    H = {
        next: H
    };
    H[Symbol.iterator] = function() {
        return this
    };
    return H
};
$jscomp.checkEs6ConformanceViaProxy = function() {
    try {
        var H = {},
        N = Object.create(new $jscomp.global.Proxy(H, {
            get: function(A, K, J) {
                return A == H && "q" == K && J == N
            }
        }));
        return ! 0 === N.q
    } catch(A) {
        return ! 1
    }
};
$jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS = !1;
$jscomp.ES6_CONFORMANCE = $jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS && $jscomp.checkEs6ConformanceViaProxy();
$jscomp.makeIterator = function(H) {
    var N = "undefined" != typeof Symbol && Symbol.iterator && H[Symbol.iterator];
    return N ? N.call(H) : $jscomp.arrayIterator(H)
};
$jscomp.owns = function(H, N) {
    return Object.prototype.hasOwnProperty.call(H, N)
};
$jscomp.polyfill("WeakMap",
function(H) {
    function N() {
        if (!H || !Object.seal) return ! 1;
        try {
            var Q = Object.seal({}),
            R = Object.seal({}),
            ea = new H([[Q, 2], [R, 3]]);
            if (2 != ea.get(Q) || 3 != ea.get(R)) return ! 1;
            ea.delete(Q);
            ea.set(R, 4);
            return ! ea.has(Q) && 4 == ea.get(R)
        } catch(Nb) {
            return ! 1
        }
    }
    function A() {}
    function K(Q) {
        var R = typeof Q;
        return "object" === R && null !== Q || "function" === R
    }
    function J(Q) {
        if (!$jscomp.owns(Q, Z)) {
            var R = new A;
            $jscomp.defineProperty(Q, Z, {
                value: R
            })
        }
    }
    function V(Q) {
        if (!$jscomp.ISOLATE_POLYFILLS) {
            var R = Object[Q];
            R && (Object[Q] = function(ea) {
                if (ea instanceof A) return ea;
                Object.isExtensible(ea) && J(ea);
                return R(ea)
            })
        }
    }
    if ($jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {
        if (H && $jscomp.ES6_CONFORMANCE) return H
    } else if (N()) return H;
    var Z = "$jscomp_hidden_" + Math.random();
    V("freeze");
    V("preventExtensions");
    V("seal");
    var pb = 0,
    O = function(Q) {
        this.id_ = (pb += Math.random() + 1).toString();
        if (Q) {
            Q = $jscomp.makeIterator(Q);
            for (var R; ! (R = Q.next()).done;) R = R.value,
            this.set(R[0], R[1])
        }
    };
    O.prototype.set = function(Q, R) {
        if (!K(Q)) throw Error("Invalid WeakMap key");
        J(Q);
        if (!$jscomp.owns(Q, Z)) throw Error("WeakMap key fail: " + Q);
        Q[Z][this.id_] = R;
        return this
    };
    O.prototype.get = function(Q) {
        return K(Q) && $jscomp.owns(Q, Z) ? Q[Z][this.id_] : void 0
    };
    O.prototype.has = function(Q) {
        return K(Q) && $jscomp.owns(Q, Z) && $jscomp.owns(Q[Z], this.id_)
    };
    O.prototype.delete = function(Q) {
        return K(Q) && $jscomp.owns(Q, Z) && $jscomp.owns(Q[Z], this.id_) ? delete Q[Z][this.id_] : !1
    };
    return O
},
"es6", "es3");
$jscomp.MapEntry = function() {};
$jscomp.polyfill("Map",
function(H) {
    function N() {
        if ($jscomp.ASSUME_NO_NATIVE_MAP || !H || "function" != typeof H || !H.prototype.entries || "function" != typeof Object.seal) return ! 1;
        try {
            var O = Object.seal({
                x: 4
            }),
            Q = new H($jscomp.makeIterator([[O, "s"]]));
            if ("s" != Q.get(O) || 1 != Q.size || Q.get({
                x: 4
            }) || Q.set({
                x: 4
            },
            "t") != Q || 2 != Q.size) return ! 1;
            var R = Q.entries(),
            ea = R.next();
            if (ea.done || ea.value[0] != O || "s" != ea.value[1]) return ! 1;
            ea = R.next();
            return ea.done || 4 != ea.value[0].x || "t" != ea.value[1] || !R.next().done ? !1 : !0
        } catch(Nb) {
            return ! 1
        }
    }
    if ($jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {
        if (H && $jscomp.ES6_CONFORMANCE) return H
    } else if (N()) return H;
    var A = new WeakMap,
    K = function(O) {
        this.data_ = {};
        this.head_ = Z();
        this.size = 0;
        if (O) {
            O = $jscomp.makeIterator(O);
            for (var Q; ! (Q = O.next()).done;) Q = Q.value,
            this.set(Q[0], Q[1])
        }
    };
    K.prototype.set = function(O, Q) {
        O = 0 === O ? 0 : O;
        var R = J(this, O);
        R.list || (R.list = this.data_[R.id] = []);
        R.entry ? R.entry.value = Q: (R.entry = {
            next: this.head_,
            previous: this.head_.previous,
            head: this.head_,
            key: O,
            value: Q
        },
        R.list.push(R.entry), this.head_.previous.next = R.entry, this.head_.previous = R.entry, this.size++);
        return this
    };
    K.prototype.delete = function(O) {
        O = J(this, O);
        return O.entry && O.list ? (O.list.splice(O.index, 1), O.list.length || delete this.data_[O.id], O.entry.previous.next = O.entry.next, O.entry.next.previous = O.entry.previous, O.entry.head = null, this.size--, !0) : !1
    };
    K.prototype.clear = function() {
        this.data_ = {};
        this.head_ = this.head_.previous = Z();
        this.size = 0
    };
    K.prototype.has = function(O) {
        return !! J(this, O).entry
    };
    K.prototype.get = function(O) {
        return (O = J(this, O).entry) && O.value
    };
    K.prototype.entries = function() {
        return V(this,
        function(O) {
            return [O.key, O.value]
        })
    };
    K.prototype.keys = function() {
        return V(this,
        function(O) {
            return O.key
        })
    };
    K.prototype.values = function() {
        return V(this,
        function(O) {
            return O.value
        })
    };
    K.prototype.forEach = function(O, Q) {
        for (var R = this.entries(), ea; ! (ea = R.next()).done;) ea = ea.value,
        O.call(Q, ea[1], ea[0], this)
    };
    K.prototype[Symbol.iterator] = K.prototype.entries;
    var J = function(O, Q) {
        var R = Q && typeof Q;
        "object" == R || "function" == R ? A.has(Q) ? R = A.get(Q) : (R = "" + ++pb, A.set(Q, R)) : R = "p_" + Q;
        var ea = O.data_[R];
        if (ea && $jscomp.owns(O.data_, R)) for (O = 0; O < ea.length; O++) {
            var Nb = ea[O];
            if (Q !== Q && Nb.key !== Nb.key || Q === Nb.key) return {
                id: R,
                list: ea,
                index: O,
                entry: Nb
            }
        }
        return {
            id: R,
            list: ea,
            index: -1,
            entry: void 0
        }
    },
    V = function(O, Q) {
        var R = O.head_;
        return $jscomp.iteratorPrototype(function() {
            if (R) {
                for (; R.head != O.head_;) R = R.previous;
                for (; R.next != R.head;) return R = R.next,
                {
                    done: !1,
                    value: Q(R)
                };
                R = null
            }
            return {
                done: !0,
                value: void 0
            }
        })
    },
    Z = function() {
        var O = {};
        return O.previous = O.next = O.head = O
    },
    pb = 0;
    return K
},
"es6", "es3");
$jscomp.polyfill("Set",
function(H) {
    function N() {
        if ($jscomp.ASSUME_NO_NATIVE_SET || !H || "function" != typeof H || !H.prototype.entries || "function" != typeof Object.seal) return ! 1;
        try {
            var K = Object.seal({
                x: 4
            }),
            J = new H($jscomp.makeIterator([K]));
            if (!J.has(K) || 1 != J.size || J.add(K) != J || 1 != J.size || J.add({
                x: 4
            }) != J || 2 != J.size) return ! 1;
            var V = J.entries(),
            Z = V.next();
            if (Z.done || Z.value[0] != K || Z.value[1] != K) return ! 1;
            Z = V.next();
            return Z.done || Z.value[0] == K || 4 != Z.value[0].x || Z.value[1] != Z.value[0] ? !1 : V.next().done
        } catch(pb) {
            return ! 1
        }
    }
    if ($jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {
        if (H && $jscomp.ES6_CONFORMANCE) return H
    } else if (N()) return H;
    var A = function(K) {
        this.map_ = new Map;
        if (K) {
            K = $jscomp.makeIterator(K);
            for (var J; ! (J = K.next()).done;) this.add(J.value)
        }
        this.size = this.map_.size
    };
    A.prototype.add = function(K) {
        K = 0 === K ? 0 : K;
        this.map_.set(K, K);
        this.size = this.map_.size;
        return this
    };
    A.prototype.delete = function(K) {
        K = this.map_.delete(K);
        this.size = this.map_.size;
        return K
    };
    A.prototype.clear = function() {
        this.map_.clear();
        this.size = 0
    };
    A.prototype.has = function(K) {
        return this.map_.has(K)
    };
    A.prototype.entries = function() {
        return this.map_.entries()
    };
    A.prototype.values = function() {
        return this.map_.values()
    };
    A.prototype.keys = A.prototype.values;
    A.prototype[Symbol.iterator] = A.prototype.values;
    A.prototype.forEach = function(K, J) {
        var V = this;
        this.map_.forEach(function(Z) {
            return K.call(J, Z, Z, V)
        })
    };
    return A
},
"es6", "es3");
$jscomp.iteratorFromArray = function(H, N) {
    H instanceof String && (H += "");
    var A = 0,
    K = !1,
    J = {
        next: function() {
            if (!K && A < H.length) {
                var V = A++;
                return {
                    value: N(V, H[V]),
                    done: !1
                }
            }
            K = !0;
            return {
                done: !0,
                value: void 0
            }
        }
    };
    J[Symbol.iterator] = function() {
        return J
    };
    return J
};
$jscomp.polyfill("Array.prototype.entries",
function(H) {
    return H ? H: function() {
        return $jscomp.iteratorFromArray(this,
        function(N, A) {
            return [N, A]
        })
    }
},
"es6", "es3");
$jscomp.polyfill("Array.prototype.fill",
function(H) {
    return H ? H: function(N, A, K) {
        var J = this.length || 0;
        0 > A && (A = Math.max(0, J + A));
        if (null == K || K > J) K = J;
        K = Number(K);
        0 > K && (K = Math.max(0, J + K));
        for (A = Number(A || 0); A < K; A++) this[A] = N;
        return this
    }
},
"es6", "es3");
$jscomp.typedArrayFill = function(H) {
    return H ? H: Array.prototype.fill
};
$jscomp.polyfill("Int8Array.prototype.fill", $jscomp.typedArrayFill, "es6", "es5");
$jscomp.polyfill("Uint8Array.prototype.fill", $jscomp.typedArrayFill, "es6", "es5");
$jscomp.polyfill("Uint8ClampedArray.prototype.fill", $jscomp.typedArrayFill, "es6", "es5");
$jscomp.polyfill("Int16Array.prototype.fill", $jscomp.typedArrayFill, "es6", "es5");
$jscomp.polyfill("Uint16Array.prototype.fill", $jscomp.typedArrayFill, "es6", "es5");
$jscomp.polyfill("Int32Array.prototype.fill", $jscomp.typedArrayFill, "es6", "es5");
$jscomp.polyfill("Uint32Array.prototype.fill", $jscomp.typedArrayFill, "es6", "es5");
$jscomp.polyfill("Float32Array.prototype.fill", $jscomp.typedArrayFill, "es6", "es5");
$jscomp.polyfill("Float64Array.prototype.fill", $jscomp.typedArrayFill, "es6", "es5");
$jscomp.polyfill("Array.prototype.flatMap",
function(H) {
    return H ? H: function(N, A) {
        for (var K = [], J = 0; J < this.length; J++) {
            var V = N.call(A, this[J], J, this);
            Array.isArray(V) ? K.push.apply(K, V) : K.push(V)
        }
        return K
    }
},
"es9", "es5");
$jscomp.findInternal = function(H, N, A) {
    H instanceof String && (H = String(H));
    for (var K = H.length,
    J = 0; J < K; J++) {
        var V = H[J];
        if (N.call(A, V, J, H)) return {
            i: J,
            v: V
        }
    }
    return {
        i: -1,
        v: void 0
    }
};
$jscomp.polyfill("Array.prototype.findIndex",
function(H) {
    return H ? H: function(N, A) {
        return $jscomp.findInternal(this, N, A).i
    }
},
"es6", "es3"); (function(H) {
    "function" === typeof define && define.amd ? define(H) : H()
})(function() {
    function H(l, p, q) {
        p in l ? Object.defineProperty(l, p, {
            value: q,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : l[p] = q;
        return l
    }
    function N(l, p, q) {
        return "*" === l ? !0 : 0 < l.length ? -1 !== l.indexOf(p) : !q
    }
    function A(l, p, q) {
        var f;
        l = l || {};
        p = p || {};
        var n = l;
        if (q) for (f = 0; f < q.length; f++) n[q[f]] = p[q[f]];
        else for (f in p) n[f] = p[f];
        return l
    }
    function K(l) {
        return "[object Number]" === Object.prototype.toString.call(l)
    }
    function J(l) {
        return "string" === typeof l
    }
    function V(l) {
        return null == l ? !1 : "[object Object]" === Object.prototype.toString.call(l)
    }
    function Z(l) {
        return "[object Function]" === Object.prototype.toString.call(l)
    }
    function pb(l) {
        for (var p in l) if (l.hasOwnProperty(p)) return ! 1;
        return ! 0
    }
    function O(l) {
        if (J(l)) return "" + l;
        if ("boolean" === typeof l) return !! l;
        if ("[object Date]" === Object.prototype.toString.call(l)) return new Date(l.getTime());
        if (Z(l)) return l;
        if (Array.isArray(l)) {
            for (var p = [], q = 0; q < l.length; q++) p.push(O(l[q]));
            return p
        }
        if (V(l)) {
            p = {};
            for (q in l) p[q] = O(l[q]);
            return p
        }
        return l
    }
    function Q(l) {
        var p = {},
        q;
        for (q in l) null != l[q] && (p[q] = l[q]);
        return p
    }
    function R(l, p, q, f) {
        var n = {},
        d, k = {};
        q = q || [];
        f = f || [];
        for (d = 0; d < q.length; d++) n[q[d]] = !0;
        for (d = 0; d < f.length; d++) k[f[d]] = !0;
        q = O(l);
        for (d in p) if (null == q[d] || k[d]) q[d] = p[d];
        else if (n[d]) l = [],
        l.push.apply(l, Array.isArray(q[d]) ? q[d] : [q[d]]),
        l.push(p[d]),
        q[d] = l;
        else if (J(p[d]) || "boolean" === typeof p[d] || Z(p[d]) || K(p[d])) q[d] = p[d];
        else if (Array.isArray(p[d])) l = [],
        Array.isArray(q[d]) && l.push.apply(l, q[d]),
        l.push.apply(l, p[d]),
        q[d] = l;
        else if (V(p[d])) {
            V(q[d]) || (q[d] = {});
            for (var a in p[d]) q[d][a] = p[d][a]
        }
        return q
    }
    function ea(l, p) {
        if (null != l && null == p || (null == l || J(l) || "boolean" === typeof l || K(l)) && l !== p) return ! 1;
        if (Array.isArray(l)) {
            if (!Array.isArray(p) || !Nb(l, p)) return ! 1
        } else if (V(l) && (!V(l) || !me(l, p))) return ! 1;
        return ! 0
    }
    function Nb(l, p) {
        if (null == l && null == p) return ! 0;
        if (null == l && null != p || null != l && null == p || l.length !== p.length) return ! 1;
        for (var q = 0; q < l.length; q++) if (!ea(l[q], p[q])) return ! 1;
        return ! 0
    }
    function me(l, p) {
        if (null == l && null == p) return ! 0;
        if (null == l && null != p || null != l && null == p) return ! 1;
        for (var q in l) if (!ea(l[q], p[q])) return ! 1;
        return ! 0
    }
    function vf(l, p, q) {
        if (null != l) {
            var f = l;
            p.replace(/([^\.])+/g,
            function(n, d, k, a) {
                var e = n.match(/([^\[0-9]+){1}(\[)([0-9+])/);
                d = function() {
                    var c; (c = f[e[1]]) || (f[e[1]] = [], c = f[e[1]]);
                    return c
                };
                k + n.length >= a.length ? e ? d()[e[3]] = q: f[n] = q: e ? (n = d(), (k = n[e[3]]) || (n[e[3]] = {},
                k = n[e[3]]), f = k) : ((k = f[n]) || (f[n] = {},
                k = f[n]), f = k);
                return ""
            });
            return l
        }
    }
    function wf(l, p, q) {
        for (var f = 0; f < q.length; f++) {
            var n = q[f][0][q[f][1]].apply(q[f][0], q[f][2]);
            if (n === p) return n
        }
        return l
    }
    function Qc(l, p, q, f) {
        return function k(d) {
            if (null != d) {
                if (J(d)) {
                    var a = d.match(/(\${.*?})/g);
                    if (null != a) for (var e = 0; e < a.length; e++) {
                        var c = p[a[e].substring(2, a[e].length - 1)] || "";
                        null != c && (d = d.replace(a[e], c))
                    }
                    return d
                }
                if (!Z(d) || f || null != q && 0 !== (d.name || "").indexOf(q)) {
                    if (Array.isArray(d)) {
                        a = [];
                        for (e = 0; e < d.length; e++) a.push(k(d[e]));
                        return a
                    }
                    if (V(d)) {
                        a = {};
                        for (e in d) a[e] = k(d[e]);
                        return a
                    }
                    return d
                }
                return d(p)
            }
        } (l)
    }
    function P(l, p) {
        if (l) for (var q = 0; q < l.length; q++) p(l[q]);
        else return null
    }
    function ub(l, p) {
        if (l) for (var q = 0; q < l.length; q++) if (p(l[q])) return q;
        return - 1
    }
    function Yi(l, p) {
        var q = [];
        if (l) for (var f = 0; f < l.length; f++) p(l[f]) && q.push(f);
        return q
    }
    function ne(l, p) {
        p = ub(l, p);
        return - 1 === p ? null: l[p]
    }
    function Zi(l, p) {
        return Yi(l, p).map(function(q) {
            return l[q]
        })
    }
    function xf(l, p) {
        var q = null;
        l.forEach(function(f) {
            p(f) && (q = f)
        });
        return q
    }
    function $i(l) {
        var p = [];
        l.forEach(function(q) {
            p.push(q)
        });
        return p
    }
    function ma(l, p) {
        p = ub(l, p); - 1 < p && l.splice(p, 1);
        return - 1 !== p
    }
    function td(l) {
        if (null != Array.fromArray) return Array.from(l);
        var p = [];
        Array.prototype.push.apply(p, l);
        return p
    }
    function yf(l, p) {
        p = l.indexOf(p); - 1 < p && l.splice(p, 1);
        return - 1 !== p
    }
    function oe(l, p, q, f) {
        var n = l[p];
        null == n && (n = [], l[p] = n);
        n[f ? "unshift": "push"](q);
        return n
    }
    function Rc(l, p, q) {
        return - 1 === l.indexOf(p) ? (q ? l.unshift(p) : l.push(p), !0) : !1
    }
    function fa() {
        var l = 4294967295 * Math.random() | 0,
        p = 4294967295 * Math.random() | 0,
        q = 4294967295 * Math.random() | 0,
        f = 4294967295 * Math.random() | 0;
        return Oa[l & 255] + Oa[l >> 8 & 255] + Oa[l >> 16 & 255] + Oa[l >> 24 & 255] + "-" + Oa[p & 255] + Oa[p >> 8 & 255] + "-" + Oa[p >> 16 & 15 | 64] + Oa[p >> 24 & 255] + "-" + Oa[q & 63 | 128] + Oa[q >> 8 & 255] + "-" + Oa[q >> 16 & 255] + Oa[q >> 24 & 255] + Oa[f & 255] + Oa[f >> 8 & 255] + Oa[f >> 16 & 255] + Oa[f >> 24 & 255]
    }
    function qb(l, p, q) {
        var f = l.x - p.x;
        l = l.y - p.y;
        var n = Math.cos(q / 360 * Math.PI * 2);
        q = Math.sin(q / 360 * Math.PI * 2);
        return {
            x: f * n - l * q + p.x,
            y: l * n + f * q + p.y,
            cr: n,
            sr: q
        }
    }
    function aj(l, p) {
        l = qb({
            x: l[0],
            y: l[1]
        },
        {
            x: 0,
            y: 0
        },
        p);
        return [Math.round(l.x), Math.round(l.y)]
    }
    function vb(l) {
        if (null == l) return null;
        l = l.replace(/^\s\s*/, "");
        for (var p = /\s/,
        q = l.length; p.test(l.charAt(--q)););
        return l.slice(0, q + 1)
    }
    function pe(l, p) {
        for (var q = [], f = 0; f < l.length; f++) q.push(p(l[f]));
        return q
    }
    function pa() {
        for (var l = arguments.length,
        p = Array(l), q = 0; q < l; q++) p[q] = arguments[q];
        if ("undefined" !== typeof console) try {
            console.log(arguments[arguments.length - 1])
        } catch(f) {}
    }
    function ud(l, p, q) {
        return function() {
            var f = null;
            try {
                null != p && (f = p.apply(this, arguments))
            } catch(n) {
                pa("jsPlumb function failed : " + n)
            }
            if (null != l && (null == q || f !== q)) try {
                f = l.apply(this, arguments)
            } catch(n) {
                pa("wrapped function failed : " + n)
            }
            return f
        }
    }
    function vd(l, p, q) {
        l.has(p) || l.set(p, q());
        return l.get(p)
    }
    function zf(l, p) {
        for (l = l.__proto__; null != l;) {
            if (l instanceof p) return ! 0;
            l = l.__proto__
        }
        return ! 1
    }
    function wd(l, p, q, f) {
        if (0 === p.length) p.push(l);
        else {
            f = f ? -1 : 1;
            for (var n = 0,
            d = p.length,
            k = Math.floor((n + d) / 2); d > n;) 0 > q(l, p[k]) * f ? d = k: n = k + 1,
            k = Math.floor((n + d) / 2);
            p.splice(k, 0, l)
        }
    }
    function Af(l, p) {
        if (! (l instanceof p)) throw new TypeError("Cannot call a class as a function");
    }
    function Bf(l, p) {
        for (var q = 0; q < p.length; q++) {
            var f = p[q];
            f.enumerable = f.enumerable || !1;
            f.configurable = !0;
            "value" in f && (f.writable = !0);
            Object.defineProperty(l, f.key, f)
        }
    }
    function Cf(l, p, q) {
        p && Bf(l.prototype, p);
        q && Bf(l, q);
        return l
    }
    function Sc(l, p, q) {
        p in l ? Object.defineProperty(l, p, {
            value: q,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : l[p] = q;
        return l
    }
    function bj(l, p) {
        if ("function" !== typeof p && null !== p) throw new TypeError("Super expression must either be null or a function");
        l.prototype = Object.create(p && p.prototype, {
            constructor: {
                value: l,
                writable: !0,
                configurable: !0
            }
        });
        p && qe(l, p)
    }
    function xd(l) {
        xd = Object.setPrototypeOf ? Object.getPrototypeOf: function(p) {
            return p.__proto__ || Object.getPrototypeOf(p)
        };
        return xd(l)
    }
    function qe(l, p) {
        qe = Object.setPrototypeOf ||
        function(q, f) {
            q.__proto__ = f;
            return q
        };
        return qe(l, p)
    }
    function cj() {
        if ("undefined" === typeof Reflect || !Reflect.construct || Reflect.construct.sham) return ! 1;
        if ("function" === typeof Proxy) return ! 0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [],
            function() {})),
            !0
        } catch(l) {
            return ! 1
        }
    }
    function dj(l) {
        var p = cj();
        return function() {
            var q = xd(l);
            if (p) {
                var f = xd(this).constructor;
                q = Reflect.construct(q, arguments, f)
            } else q = q.apply(this, arguments);
            if (!q || "object" !== typeof q && "function" !== typeof q) {
                if (void 0 === this) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                q = this
            }
            return q
        }
    }
    function ac(l, p) {
        return {
            x: l.x + p.x,
            y: l.y + p.y
        }
    }
    function bc(l, p) {
        return p.x === l.x ? p.y > l.y ? Infinity: -Infinity: p.y === l.y ? p.x > l.x ? 0 : -0 : (p.y - l.y) / (p.x - l.x)
    }
    function Va(l, p) {
        return Math.sqrt(Math.pow(p.y - l.y, 2) + Math.pow(p.x - l.x, 2))
    }
    function yd(l, p) {
        return p.x > l.x ? p.y > l.y ? 2 : 1 : p.x == l.x ? p.y > l.y ? 2 : 1 : p.y > l.y ? 3 : 4
    }
    function cc(l, p) {
        var q = l.x,
        f = l.x + l.w,
        n = l.y;
        l = l.y + l.h;
        var d = p.x,
        k = p.x + p.w,
        a = p.y;
        p = p.y + p.h;
        return q <= d && d <= f && n <= a && a <= l || q <= k && k <= f && n <= a && a <= l || q <= d && d <= f && n <= p && p <= l || q <= k && d <= f && n <= p && p <= l || d <= q && q <= k && a <= n && n <= p || d <= f && f <= k && a <= n && n <= p || d <= q && q <= k && a <= l && l <= p || d <= f && q <= k && a <= l && l <= p
    }
    function Df(l) {
        var p = l[1].y - l[0].y,
        q = l[0].x - l[1].x;
        return {
            A: p,
            B: q,
            C: p * l[0].x + q * l[0].y
        }
    }
    function Ef(l, p) {
        var q = [];
        P([[{
            x: p.x,
            y: p.y
        },
        {
            x: p.x + p.w,
            y: p.y
        }], [{
            x: p.x + p.w,
            y: p.y
        },
        {
            x: p.x + p.w,
            y: p.y + p.h
        }], [{
            x: p.x,
            y: p.y
        },
        {
            x: p.x,
            y: p.y + p.h
        }], [{
            x: p.x,
            y: p.y + p.h
        },
        {
            x: p.x + p.w,
            y: p.y + p.h
        }]],
        function(f) {
            var n = Df(l),
            d = Df(f),
            k = n.A * d.B - d.A * n.B;
            if (0 == k) f = null;
            else {
                n = {
                    x: (d.B * n.C - n.B * d.C) / k,
                    y: (n.A * d.C - d.A * n.C) / k
                };
                d = Math.max(l[0].x, l[1].x);
                k = Math.min(l[0].y, l[1].y);
                var a = Math.max(l[0].y, l[1].y),
                e = Math.min(f[0].x, f[1].x),
                c = Math.max(f[0].x, f[1].x),
                h = Math.min(f[0].y, f[1].y);
                f = Math.max(f[0].y, f[1].y);
                f = n.x >= Math.min(l[0].x, l[1].x) && n.x <= d && n.y >= k && n.y <= a && n.x >= e && n.x <= c && n.y >= h && n.y <= f ? n: null
            }
            null != f && q.push(f)
        });
        return q
    }
    function dc(l, p, q) {
        var f = bc(l, p);
        p = yd(l, p);
        p = 0 < q ? ej[p] : fj[p];
        f = Math.atan(f);
        return {
            x: l.x + Math.abs(q * Math.cos(f)) * p[0],
            y: l.y + Math.abs(q * Math.sin(f)) * p[1]
        }
    }
    function Ff(l, p, q, f) {
        q = null == q ? null == p.thresholdX ? p.w / 2 : p.thresholdX: q;
        f = null == f ? null == p.thresholdY ? p.h / 2 : p.thresholdY: f;
        var n = p.w * Math.floor(l.x / p.w),
        d = n + p.w,
        k = p.h * Math.floor(l.y / p.h);
        p = k + p.h;
        return {
            x: Math.abs(l.x - n) <= q ? n: Math.abs(d - l.x) <= q ? d: l.x,
            y: Math.abs(l.y - k) <= f ? k: Math.abs(p - l.y) <= f ? p: l.y
        }
    }
    function Gf(l, p) {
        for (var q = 0; q < p.length; q++) {
            var f = p[q];
            f.enumerable = f.enumerable || !1;
            f.configurable = !0;
            "value" in f && (f.writable = !0);
            Object.defineProperty(l, f.key, f)
        }
    }
    function gj(l, p, q) {
        p && Gf(l.prototype, p);
        q && Gf(l, q);
        return l
    }
    function qc(l, p, q) {
        p in l ? Object.defineProperty(l, p, {
            value: q,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : l[p] = q;
        return l
    }
    function zd() {
        return {
            xmin: Infinity,
            xmax: -Infinity,
            ymin: Infinity,
            ymax: -Infinity
        }
    }
    function ja(l, p) {
        if (! (l instanceof p)) throw new TypeError("Cannot call a class as a function");
    }
    function Hf(l, p) {
        for (var q = 0; q < p.length; q++) {
            var f = p[q];
            f.enumerable = f.enumerable || !1;
            f.configurable = !0;
            "value" in f && (f.writable = !0);
            Object.defineProperty(l, f.key, f)
        }
    }
    function ua(l, p, q) {
        p && Hf(l.prototype, p);
        q && Hf(l, q);
        return l
    }
    function x(l, p, q) {
        p in l ? Object.defineProperty(l, p, {
            value: q,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : l[p] = q;
        return l
    }
    function xa(l, p) {
        if ("function" !== typeof p && null !== p) throw new TypeError("Super expression must either be null or a function");
        l.prototype = Object.create(p && p.prototype, {
            constructor: {
                value: l,
                writable: !0,
                configurable: !0
            }
        });
        p && re(l, p)
    }
    function Wa(l) {
        Wa = Object.setPrototypeOf ? Object.getPrototypeOf: function(p) {
            return p.__proto__ || Object.getPrototypeOf(p)
        };
        return Wa(l)
    }
    function re(l, p) {
        re = Object.setPrototypeOf ||
        function(q, f) {
            q.__proto__ = f;
            return q
        };
        return re(l, p)
    }
    function hj() {
        if ("undefined" === typeof Reflect || !Reflect.construct || Reflect.construct.sham) return ! 1;
        if ("function" === typeof Proxy) return ! 0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [],
            function() {})),
            !0
        } catch(l) {
            return ! 1
        }
    }
    function C(l) {
        if (void 0 === l) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return l
    }
    function ya(l) {
        var p = hj();
        return function() {
            var q = Wa(l);
            if (p) {
                var f = Wa(this).constructor;
                q = Reflect.construct(q, arguments, f)
            } else q = q.apply(this, arguments);
            q = !q || "object" !== typeof q && "function" !== typeof q ? C(this) : q;
            return q
        }
    }
    function kb(l, p, q) {
        kb = "undefined" !== typeof Reflect && Reflect.get ? Reflect.get: function(f, n, d) {
            for (; ! Object.prototype.hasOwnProperty.call(f, n) && (f = Wa(f), null !== f););
            if (f) return n = Object.getOwnPropertyDescriptor(f, n),
            n.get ? n.get.call(d) : n.value
        };
        return kb(l, p, q || l)
    }
    function se(l, p) {
        var q = Array.isArray(l) ? l: void 0;
        if (!q) if (q = null == l ? null: "undefined" !== typeof Symbol && l[Symbol.iterator] || l["@@iterator"], null == q) q = void 0;
        else {
            var f = [],
            n = !0,
            d = !1,
            k;
            try {
                for (q = q.call(l); ! (n = (k = q.next()).done) && (f.push(k.value), !p || f.length !== p); n = !0);
            } catch(e) {
                d = !0;
                var a = e
            } finally {
                try {
                    if (!n && null != q["return"]) q["return"]()
                } finally {
                    if (d) throw a;
                }
            }
            q = f
        }
        if (! (l = q || If(l, p))) throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        return l
    }
    function Ad(l) {
        var p = Array.isArray(l) ? te(l) : void 0;
        p || (p = "undefined" !== typeof Symbol && null != l[Symbol.iterator] || null != l["@@iterator"] ? Array.from(l) : void 0);
        if (! (l = p || If(l))) throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        return l
    }
    function If(l, p) {
        if (l) {
            if ("string" === typeof l) return te(l, p);
            var q = Object.prototype.toString.call(l).slice(8, -1);
            "Object" === q && l.constructor && (q = l.constructor.name);
            if ("Map" === q || "Set" === q) return Array.from(l);
            if ("Arguments" === q || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(q)) return te(l, p)
        }
    }
    function te(l, p) {
        if (null == p || p > l.length) p = l.length;
        for (var q = 0,
        f = Array(p); q < p; q++) f[q] = l[q];
        return f
    }
    function Eb() {
        for (var l = arguments.length,
        p = Array(l), q = 0; q < l; q++) p[q] = arguments[q];
        return p.map(function(f) {
            return "." + f
        }).join(",")
    }
    function ue() {
        for (var l = arguments.length,
        p = Array(l), q = 0; q < l; q++) p[q] = arguments[q];
        return p.join(" ")
    }
    function wb() {
        for (var l = arguments.length,
        p = Array(l), q = 0; q < l; q++) p[q] = arguments[q];
        return p.map(function(f) {
            return "[" + f + "]"
        }).join(",")
    }
    function ve(l) {
        l = J(l) ? {
            type: l,
            options: {}
        }: l;
        l.options.id = l.options.id || fa();
        return l
    }
    function Ob(l) {
        return l.type === Fb.type
    }
    function Bd(l) {
        return null == l ? null: l.split(" ")
    }
    function rc(l, p) {
        if (l.getDefaultType) {
            var q = l.getTypeDescriptor(),
            f = {},
            n = l.getDefaultType(),
            d = A({},
            n),
            k;
            for (k in n) f[k] = "__default";
            n = 0;
            for (k = l._types.length; n < k; n++) {
                var a = l._types[n];
                if ("__default" !== a) {
                    var e = l.instance.getType(a, q);
                    if (null != e) {
                        var c = new Set(["connector", "anchor", "anchors"]);
                        if ("override" === e.mergeStrategy) for (var h in e) c.add(h);
                        d = R(d, e, ["cssClass"], $i(c));
                        c = void 0;
                        var b = f;
                        for (c in e) b[c] = a
                    }
                }
            }
            p && (d = Qc(d, p, "_"));
            l.applyType(d, f)
        }
    }
    function we(l, p) {
        p = l.instance.getType(l._types[p], l.getTypeDescriptor());
        null != p && p.cssClass && l.removeClass(p.cssClass)
    }
    function Jf(l) {
        if (l.paintStyle && l.hoverPaintStyle) {
            var p = {};
            A(p, l.paintStyle);
            A(p, l.hoverPaintStyle);
            l.hoverPaintStyle = p
        }
    }
    function Kf(l, p) {
        return null == l.lockedAxis ? null == l.lockedFace ? -1 !== l.faces.indexOf(p) === !0 : l.lockedFace === p: -1 !== l.lockedAxis.indexOf(p)
    }
    function ij(l, p) {
        if ( - 1 === l.faces.indexOf(p)) {
            if ( - 1 !== l.faces.indexOf(Lf[p])) return Lf[p];
            var q = (l.clockwise ? Mf: Nf)[p];
            if ( - 1 !== l.faces.indexOf(q)) return q;
            q = (l.clockwise ? Nf: Mf)[p];
            if ( - 1 !== l.faces.indexOf(q)) return q
        }
        return p
    }
    function Of(l, p) {
        p = p || {};
        if (l === ec.Perimeter) return jj(p);
        var q = Pf[l];
        if (null != q) return Cd(l, pe(q,
        function(f) {
            return A({
                iox: f.ox,
                ioy: f.oy
            },
            f)
        }), p);
        q = kj[l];
        if (null != q) return lj(l, q.faces, p);
        throw {
            message: "jsPlumb: unknown anchor type '" + l + "'"
        };
    }
    function Cd(l, p, q) {
        return {
            type: l,
            locations: p,
            currentLocation: 0,
            locked: !1,
            id: fa(),
            isFloating: !1,
            isContinuous: !1,
            isDynamic: 1 < p.length,
            timestamp: null,
            cssClass: q.cssClass || ""
        }
    }
    function lj(l, p, q) {
        l = {
            type: l,
            locations: [],
            currentLocation: 0,
            locked: !1,
            id: fa(),
            cssClass: q.cssClass || "",
            isFloating: !1,
            isContinuous: !0,
            timestamp: null,
            faces: q.faces || p,
            lockedFace: null,
            lockedAxis: null,
            clockwise: !1 !== q.clockwise,
            __currentFace: null
        };
        Object.defineProperty(l, mj, {
            get: function() {
                return this.__currentFace
            },
            set: function(f) {
                this.__currentFace = ij(this, f)
            }
        });
        return l
    }
    function Qf(l) {
        return 7 > l.length && l.every(K) || 7 === l.length && l.slice(0, 5).every(K) && J(l[6])
    }
    function Tc(l) {
        if (J(l)) return Of(l, null);
        if (Array.isArray(l)) {
            if (Qf(l)) return Cd(null, [{
                x: l[0],
                y: l[1],
                ox: l[2],
                oy: l[3],
                offx: null == l[4] ? 0 : l[4],
                offy: null == l[5] ? 0 : l[5],
                iox: l[2],
                ioy: l[3],
                cls: l[6] || ""
            }], {
                cssClass: l[6] || ""
            });
            l = pe(l,
            function(p) {
                if (J(p)) return p = Pf[p],
                null != p ? A({
                    iox: 0,
                    ioy: 0,
                    cls: ""
                },
                p[0]) : null;
                if (Qf(p)) return {
                    x: p[0],
                    y: p[1],
                    ox: p[2],
                    oy: p[3],
                    offx: null == p[4] ? 0 : p[4],
                    offy: null == p[5] ? 0 : p[5],
                    iox: p[2],
                    ioy: p[3],
                    cls: p[6] || ""
                }
            }).filter(function(p) {
                return null != p
            });
            return Cd("Dynamic", l, {})
        }
        return Of(l.type, l.options)
    }
    function Rf(l) {
        for (var p = 2 * Math.PI / l,
        q = [], f = 0, n = 0; n < l; n++) q.push({
            x: .5 + .5 * Math.sin(f),
            y: .5 + .5 * Math.cos(f),
            ox: 0,
            oy: 0,
            offx: 0,
            offy: 0,
            iox: 0,
            ioy: 0,
            cls: ""
        }),
        f += p;
        return q
    }
    function nj(l, p) {
        for (var q = p / l.length,
        f = [], n = function(k, a, e, c, h, b, g) {
            q = p * h;
            e = (e - k) / q;
            c = (c - a) / q;
            for (h = 0; h < q; h++) f.push({
                x: k + e * h,
                y: a + c * h,
                ox: null == b ? 0 : b,
                oy: null == g ? 0 : g,
                offx: 0,
                offy: 0,
                iox: 0,
                ioy: 0,
                cls: ""
            })
        },
        d = 0; d < l.length; d++) n.apply(null, l[d]);
        return f
    }
    function xe(l, p) {
        for (var q = [], f = 0; f < l.length; f++) q.push([l[f][0], l[f][1], l[f][2], l[f][3], 1 / l.length, l[f][4], l[f][5]]);
        return nj(q, p)
    }
    function Sf(l) {
        return xe([[0, 0, 1, 0, 0, -1], [1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 1, 0, 0, -1, 0]], l)
    }
    function jj(l) {
        l = l || {};
        var p = l.anchorCount || 60,
        q = l.shape;
        if (!q) throw Error("no shape supplied to Perimeter Anchor type");
        if (!Pb.has(q)) throw Error("Shape [" + q + "] is unknown by Perimeter Anchor type");
        p = Pb.get(q)(p);
        if (l.rotation) {
            for (var f = [], n = l.rotation / 180 * Math.PI, d = 0; d < p.length; d++) {
                var k = p[d].x - .5,
                a = p[d].y - .5;
                f.push({
                    x: .5 + (k * Math.cos(n) - a * Math.sin(n)),
                    y: .5 + (k * Math.sin(n) + a * Math.cos(n)),
                    ox: p[d].ox,
                    oy: p[d].oy,
                    offx: 0,
                    offy: 0,
                    iox: 0,
                    ioy: 0,
                    cls: ""
                })
            }
            p = f
        }
        l = Cd(ec.Perimeter, p, l);
        return A(l, {
            shape: q
        })
    }
    function Tf(l, p, q, f, n, d, k) {
        if (p) l.endpoints[q] = p,
        p.addConnection(l);
        else {
            d = k || l.endpointSpec || l.endpointsSpec[q] || l.instance.defaults.endpoints[q] || l.instance.defaults.endpoint;
            k = l.endpointStyles[q] || l.endpointStyle || l.instance.defaults.endpointStyles[q] || l.instance.defaults.endpointStyle;
            null == k.fill && null != l.paintStyle && (k.fill = l.paintStyle.stroke);
            null == k.outlineStroke && null != l.paintStyle && (k.outlineStroke = l.paintStyle.outlineStroke);
            null == k.outlineWidth && null != l.paintStyle && (k.outlineWidth = l.paintStyle.outlineWidth);
            var a = l.endpointHoverStyles[q] || l.endpointHoverStyle || l.endpointHoverStyle || l.instance.defaults.endpointHoverStyles[q] || l.instance.defaults.endpointHoverStyle;
            null != l.hoverPaintStyle && (null == a && (a = {}), null == a.fill && (a.fill = l.hoverPaintStyle.stroke));
            var e = l.uuids ? l.uuids[q] : null;
            f = null != f ? f: null != l.instance.defaults.anchors ? l.instance.defaults.anchors[q] : l.instance.defaults.anchor;
            a = l.instance._internal_newEndpoint({
                paintStyle: k,
                hoverPaintStyle: a,
                endpoint: d,
                connections: [l],
                uuid: e,
                element: n,
                scope: l.scope,
                anchor: f,
                reattachConnections: l.reattach || l.instance.defaults.reattachConnections,
                connectionsDetachable: l.detachable || l.instance.defaults.connectionsDetachable
            });
            null == p && (a.deleteOnEmpty = !0);
            l.endpoints[q] = a
        }
        return a
    }
    function Uf() {
        return {
            x: 0,
            y: 0,
            w: 0,
            h: 0,
            r: 0,
            c: {
                x: 0,
                y: 0
            },
            x2: 0,
            y2: 0,
            t: {
                x: 0,
                y: 0,
                c: {
                    x: 0,
                    y: 0
                },
                w: 0,
                h: 0,
                r: 0,
                x2: 0,
                y2: 0,
                cr: 0,
                sr: 0
            },
            dirty: !0
        }
    }
    function oj(l, p, q, f, n) {
        var d = l + q / 2,
        k = p + f / 2,
        a = Math.cos(n / 360 * Math.PI * 2),
        e = Math.sin(n / 360 * Math.PI * 2),
        c = function(r, t) {
            return {
                x: d + Math.round((r - d) * a - (t - k) * e),
                y: k + Math.round((t - k) * a - (r - d) * e)
            }
        },
        h = c(l, p),
        b = c(l + q, p),
        g = c(l + q, p + f),
        m = c(l, p + f);
        l = c(l + q / 2, p + f / 2);
        p = Math.min(h.x, b.x, g.x, m.x);
        q = Math.max(h.x, b.x, g.x, m.x);
        f = Math.min(h.y, b.y, g.y, m.y);
        h = Math.max(h.y, b.y, g.y, m.y);
        return {
            x: p,
            y: f,
            w: q - p,
            h: h - f,
            c: l,
            r: n,
            x2: q,
            y2: h,
            cr: a,
            sr: e
        }
    }
    function Qb(l, p) {
        var q = ub(p,
        function(f) {
            return f[0] === l
        }); - 1 < q && p.splice(q, 1)
    }
    function Vf(l, p) {
        return p.theta - l.theta
    }
    function Wf(l, p) {
        return (0 > l.theta ? -Math.PI - l.theta: Math.PI - l.theta) - (0 > p.theta ? -Math.PI - p.theta: Math.PI - p.theta)
    }
    function lb(l) {
        return ! 0 === l.isContinuous
    }
    function fc(l, p, q) {
        var f = [],
        n = function(k) {
            return J(k) ? k: l.getId(k)
        };
        if (p) if ("string" === typeof p) {
            if ("*" === p) return p;
            f.push(p)
        } else if (q) f = p;
        else if (null != p.length) {
            var d; (d = f).push.apply(d, Ad(Ad(p).map(n)))
        } else f.push(n(p));
        return f
    }
    function pj(l, p) {
        null != l && ma(l.endpoints,
        function(q) {
            return q === p
        })
    }
    function Dd(l, p, q) {
        null != p && (p.connections.push(l), 1 === p.connections.length && l.instance.addClass(l.source, l.instance.connectedClass));
        null == q || null != p && l.sourceId === l.targetId || (q.connections.push(l), 1 === q.connections.length && l.instance.addClass(l.target, l.instance.connectedClass))
    }
    function Ed(l, p, q) {
        if (null != p) {
            var f = p.connections.length;
            ma(p.connections,
            function(n) {
                return l.id === n.id
            });
            0 < f && 0 === p.connections.length && l.instance.removeClass(l.source, l.instance.connectedClass)
        }
        null != q && (f = q.connections.length, null != p && l.sourceId === l.targetId || ma(q.connections,
        function(n) {
            return l.id === n.id
        }), 0 < f && 0 === q.connections.length && l.instance.removeClass(l.target, l.instance.connectedClass))
    }
    function Xf(l) {
        var p = Math.floor(l),
        q = Math.ceil(l);
        return 1E-10 > l - p ? p: 1E-10 > q - l ? q: l
    }
    function Rb(l) {
        return l.type === ye.type
    }
    function Uc(l) {
        return (Uc = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ?
        function(p) {
            return typeof p
        }: function(p) {
            return p && "function" == typeof Symbol && p.constructor === Symbol && p !== Symbol.prototype ? "symbol": typeof p
        })(l)
    }
    function ba(l, p) {
        if (! (l instanceof p)) throw new TypeError("Cannot call a class as a function");
    }
    function Yf(l, p) {
        for (var q = 0; q < p.length; q++) {
            var f = p[q];
            f.enumerable = f.enumerable || !1;
            f.configurable = !0;
            "value" in f && (f.writable = !0);
            Object.defineProperty(l, f.key, f)
        }
    }
    function ca(l, p, q) {
        return p && Yf(l.prototype, p),
        q && Yf(l, q),
        l
    }
    function B(l, p, q) {
        return p in l ? Object.defineProperty(l, p, {
            value: q,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : l[p] = q,
        l
    }
    function Fa(l, p) {
        if ("function" != typeof p && null !== p) throw new TypeError("Super expression must either be null or a function");
        l.prototype = Object.create(p && p.prototype, {
            constructor: {
                value: l,
                writable: !0,
                configurable: !0
            }
        });
        p && Zf(l, p)
    }
    function Vc(l) {
        return (Vc = Object.setPrototypeOf ? Object.getPrototypeOf: function(p) {
            return p.__proto__ || Object.getPrototypeOf(p)
        })(l)
    }
    function Zf(l, p) {
        return (Zf = Object.setPrototypeOf ||
        function(q, f) {
            return q.__proto__ = f,
            q
        })(l, p)
    }
    function qj() {
        if ("undefined" == typeof Reflect || !Reflect.construct || Reflect.construct.sham) return ! 1;
        if ("function" == typeof Proxy) return ! 0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [],
            function() {})),
            !0
        } catch(l) {
            return ! 1
        }
    }
    function L(l) {
        if (void 0 === l) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return l
    }
    function Ga(l) {
        var p = qj();
        return function() {
            var q = Vc(l);
            if (p) {
                var f = Vc(this).constructor;
                q = Reflect.construct(q, arguments, f)
            } else q = q.apply(this, arguments);
            if (!q || "object" != typeof q && "function" != typeof q) {
                if (void 0 !== q) throw new TypeError("Derived constructors may only return object or undefined");
                q = L(this)
            }
            return q
        }
    }
    function $f(l, p, q) {
        return ($f = "undefined" != typeof Reflect && Reflect.get ? Reflect.get: function(f, n, d) {
            for (; ! Object.prototype.hasOwnProperty.call(f, n) && null !== (f = Vc(f)););
            if (f) return n = Object.getOwnPropertyDescriptor(f, n),
            n.get ? n.get.call(d) : n.value
        })(l, p, q || l)
    }
    function rj(l) {
        var p, q = l.graph,
        f = q.getVertexCount(),
        n = {},
        d = {};
        for (l = 0; l < f; l++) {
            var k = q.getVertexAt(l);
            n[k.id] || (n[k.id] = {});
            d[k.id] || (d[k.id] = {});
            for (p = n[k.id][k.id] = 0; p < f; p++) if (l != p) {
                var a = q.getVertexAt(p);
                n[k.id][a.id] || (n[k.id][a.id] = 1 / 0);
                d[k.id][a.id] || (d[k.id][a.id] = [])
            }
            p = k.getEdges();
            for (a = 0; a < p.length; a++) p[a].source == k ? n[k.id][p[a].target.id] = p[a].getCost() : (n[p[a].source.id] || (n[p[a].source.id] = {},
            d[p[a].source.id] = {}), n[k.id][p[a].source.id] = p[a].getCost())
        }
        for (a = 0; a < f; a++) for (l = 0; l < f; l++) for (p = 0; p < f; p++) if (l != p && p != a && l != a) {
            k = q.getVertexAt(l).id;
            var e = q.getVertexAt(p).id,
            c = q.getVertexAt(a).id;
            n[k][c] + n[c][e] <= n[k][e] && n[k][c] + n[c][e] != 1 / 0 && (n[k][e] = n[k][c] + n[c][e], d[k][e] || (d[k][e] = []), d[k][e].unshift([q.getVertexAt(a), n[k][e]]))
        }
        return {
            paths: n,
            parents: d
        }
    }
    function ag(l) {
        return qa(l) ? l.getParent().id: l.getFullId()
    }
    function ze(l) {
        return qa(l) ? l.getParent() : l
    }
    function bg(l) {
        return qa(l) ? l.id: null
    }
    function ka(l) {
        return null != l && l.objectType === Pa.objectType
    }
    function Sb(l) {
        return ka(l) && null != l.group
    }
    function ra(l) {
        return null != l && l.objectType === cb.objectType
    }
    function Tb(l) {
        return ra(l) && null != l.group
    }
    function Wc(l) {
        return null != l && l.objectType === ab.objectType
    }
    function qa(l) {
        return null != l && l.objectType === oa.objectType
    }
    function cg(l) {
        return l.id
    }
    function Ae(l) {
        for (var p = l.graph,
        q = l.source,
        f = l.target,
        n = l.nodeFilter,
        d = l.edgeFilter,
        k = {},
        a = {},
        e = {},
        c = {
            dist: k,
            previous: a,
            edges: e,
            path: []
        },
        h = l.processAll, b = {},
        g = {},
        m = !1 !== l.strict, r = function(W) {
            return W.getFullId ? W.getFullId() : W.id
        },
        t = [], u = function(W) {
            W = g[W.getFullId()];
            return b[W.v.id]
        },
        v = function(W, Xa) {
            var aa;
            if (W.objectType === oa.objectType) {
                k[W.getFullId()] = Xa;
                var za = u(W);
                for (aa = 0; aa < za.length; aa++) za[aa].p != W && (k[za[aa].p.getFullId()] = Xa + W.getParent().getInternalEdge(W, za[aa].p).cost);
                m || (k[W.getParent().id] = Xa)
            } else for (k[W.id] = Xa, za = b[W.id], aa = 0; aa < za.length; aa++) k[za[aa].p.getFullId()] = Xa
        },
        w = function(W) {
            return n && !n(W) ? 1 / 0 : k[r(W)]
        },
        z = function(W, Xa) {
            var aa = Xa.getFullId(),
            za = W[aa];
            return null == za && (za = W[aa = Xa.getParent ? Xa.getParent().id: Xa.id]),
            null == za ? null: {
                p: za,
                id: aa
            }
        },
        y = 0; y < p.nodes.length; y++) {
            var E = p.nodes[y],
            F = E.getPorts();
            t.push(E);
            var M = {
                v: E,
                i: t.length - 1
            };
            b[E.id] = [];
            v(E, 1 / 0);
            for (var S = 0; S < F.length; S++) t.push(F[S]),
            g[F[S].getFullId()] = M,
            b[E.id].push({
                p: F[S],
                i: t.length - 1
            }),
            v(F[S], 1 / 0)
        }
        if (null == q && (q = p.getVertex(l.sourceId)), null == f && (f = p.getVertex(l.targetId)), null == q || null == f) return c;
        v(q, 0);
        var X = Array(p.nodes.length),
        da = 0;
        for (l = function() {
            var W = function(aa, za, xb, Ya, mb) {
                xb = -1;
                Ya = null;
                for (var Qa = 1 / 0,
                Ra = 0; Ra < aa.length; Ra++) if (!za[Ra]) {
                    var rb = mb(aa[Ra]);
                    rb < Qa ? (Qa = rb, xb = Ra, Ya = aa[Ra]) : rb === Qa && aa[Ra].objectType === oa.objectType && aa[Ra].getParent() === Ya && (xb = Ra, Ya = aa[Ra])
                }
                return {
                    node: Ya,
                    index: xb
                }
            } (t, X, 0, 0, w),
            Xa = W.node ? r(W.node) : null;
            return W.node && w(W.node) != 1 / 0 ? f && (Xa == r(f) || !m && W.node.objectType === oa.objectType && W.node.isChildOf(f)) && (c.path = function(aa, za, xb, Ya, mb, Qa) {
                mb = [];
                for (Qa = z(za, Ya); null != Qa;) mb.splice(0, 0, {
                    vertex: Ya,
                    cost: aa[Qa.id],
                    edge: xb[Qa.id]
                }),
                Ya = Qa.p,
                Qa = z(za, Ya);
                return mb.splice(0, 0, {
                    vertex: Ya,
                    cost: 0,
                    edge: null
                }),
                mb
            } (k, a, e, f), c.pathDistance = c.path[c.path.length - 1].cost, !h) ? "break": (X[W.index] = !0, da += 1, void
            function(aa, za, xb, Ya) {
                for (var mb = 0; mb < za.length; mb++) {
                    var Qa = za[mb];
                    if (xb(Qa)) {
                        var Ra = Ya(Qa),
                        rb = Ra.tp || Ra.tn;
                        Ra = r(rb);
                        var Gb = w(aa.node) + Qa.getCost();
                        if (Gb < w(rb)) {
                            v(rb, Gb);
                            Gb = rb;
                            var Xc = Ra,
                            Be = aa;
                            if (Gb.objectType === oa.objectType) {
                                for (var dg = u(Gb), Ce = 0; Ce < dg.length; Ce++) a[dg[Ce].p.getFullId()] = Be.node;
                                m || (a[Gb.getParent().id] = Be.node)
                            }
                            a[Xc] = Be.node;
                            if (rb.objectType === oa.objectType) {
                                Gb = u(rb);
                                for (Xc = 0; Xc < Gb.length; Xc++) e[Gb[Xc].p.getFullId()] = Qa;
                                m || (e[rb.getParent().id] = Qa)
                            }
                            e[Ra] = Qa
                        }
                    }
                }
            } (W, W.node.getAllEdges(),
            function(aa) {
                return ! (d && !d(aa)) && (!aa.isDirected() || W.node == aa.source || !m && aa.source.objectType === oa.objectType && aa.source.isChildOf(W.node))
            },
            function(aa) {
                var za = aa.source.objectType === oa.objectType ? aa.source.getParent() : aa.source,
                xb = aa.source.objectType === oa.objectType ? aa.source: null,
                Ya = aa.target.objectType === oa.objectType ? aa.target.getParent() : aa.target,
                mb = aa.target.objectType === oa.objectType ? aa.target: null;
                return aa.source == W.node || !m && aa.source.objectType === oa.objectType && aa.source.isChildOf(W.node) ? {
                    tn: Ya,
                    tp: mb
                }: {
                    tn: za,
                    tp: xb
                }
            })) : "break"
        }; da < t.length && "break" !== l(););
        return c
    }
    function De(l, p) {
        var q = l.center || {
            x: l.x + l.w / 2,
            y: l.y + l.h / 2
        },
        f = p.center || {
            x: p.x + p.w / 2,
            y: p.y + p.h / 2
        },
        n = bc(q, f);
        f = yd(q, f);
        q = n == 1 / 0 || n == -1 / 0 || isNaN(n) ? 0 : q.y - n * q.x;
        var d = n;
        isNaN(d) && (d = 0);
        var k, a, e = p.y + p.h;
        n = Math.atan(d);
        q = d == 1 / 0 || d == -1 / 0 ? p.x + p.w / 2 : (e - q) / d;
        return p.x <= q && q <= p.x + p.w ? {
            x: (k = eg[f][1](l, p)) / Math.sin(n) * Math.cos(n),
            y: k
        }: {
            x: a = eg[f][0](l, p),
            y: a / Math.cos(n) * Math.sin(n)
        }
    }
    function gc(l, p, q) {
        var f = p.w + 2 * q.x;
        p = p.h + 2 * q.y;
        return {
            x: l.x - f / 2,
            y: l.y - p / 2,
            w: f,
            h: p
        }
    }
    function fg(l) {
        var p = [];
        if (null == l) return null;
        if (Array.isArray(l)) return p = [],
        p.push.apply(p, l),
        p;
        for (var q in l) p.push(l[q]);
        return p
    }
    function Fd(l, p, q) {
        l.push(p);
        p = l.length - 1;
        for (var f = l[p]; 0 < p && f[q] < l[p - 1][q];) l[p] = l[p - 1],
        --p;
        return l[p] = f,
        p
    }
    function nb(l, p, q) {
        if (null == l) return null;
        if ("$data" === p || null == p) return l;
        var f = p.match(/^\{(.*)\}$/);
        if (f) {
            p = {};
            f = f[1].split(",");
            for (var n = 0; n < f.length; n++) {
                var d = f[n].split(":"),
                k = nb(l, d[1]);
                p[vb(d[0])] = k || d[1].replace(/'/g, "")
            }
            return p
        }
        p = p.replace(/\['([^']*)'\]/g, ".$1");
        var a = l,
        e = null;
        return p.replace(/([^\.])+/g,
        function(c, h, b, g) {
            if (null == e) {
                var m = c.match(/([^\[0-9]+){1}(\[)([0-9+])/);
                h = function() {
                    return a[m[1]] || (a[m[1]] = [], a[m[1]])
                };
                b + c.length >= g.length ? m ? (c = h(), b = m[3], null == q ? e = c[b] : c[b] = q) : null == q ? e = a[c] : a[c] = q: m ? (c = h(), a = c[m[3]] || (c[m[3]] = {},
                c[m[3]])) : a = a[c] || (a[c] = {},
                a[c])
            }
        }),
        e
    }
    function sj(l, p) {
        var q = {
            left: [],
            right: []
        };
        return P(l,
        function(f) {
            p(f) ? q.left.push(f) : q.right.push(f)
        }),
        q
    }
    function Ub(l, p, q, f, n, d) {
        Ee[q] && Ee[q][l] && Ee[q][l](p, f, n)
    }
    function Za(l, p) {
        if (! (l instanceof p)) throw new TypeError("Cannot call a class as a function");
    }
    function gg(l, p) {
        for (var q = 0; q < p.length; q++) {
            var f = p[q];
            f.enumerable = f.enumerable || !1;
            f.configurable = !0;
            "value" in f && (f.writable = !0);
            Object.defineProperty(l, f.key, f)
        }
    }
    function db(l, p, q) {
        return p && gg(l.prototype, p),
        q && gg(l, q),
        l
    }
    function T(l, p, q) {
        return p in l ? Object.defineProperty(l, p, {
            value: q,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : l[p] = q,
        l
    }
    function yb(l, p) {
        if ("function" != typeof p && null !== p) throw new TypeError("Super expression must either be null or a function");
        l.prototype = Object.create(p && p.prototype, {
            constructor: {
                value: l,
                writable: !0,
                configurable: !0
            }
        });
        p && hg(l, p)
    }
    function Fe(l) {
        return (Fe = Object.setPrototypeOf ? Object.getPrototypeOf: function(p) {
            return p.__proto__ || Object.getPrototypeOf(p)
        })(l)
    }
    function hg(l, p) {
        return (hg = Object.setPrototypeOf ||
        function(q, f) {
            return q.__proto__ = f,
            q
        })(l, p)
    }
    function tj() {
        if ("undefined" == typeof Reflect || !Reflect.construct || Reflect.construct.sham) return ! 1;
        if ("function" == typeof Proxy) return ! 0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [],
            function() {})),
            !0
        } catch(l) {
            return ! 1
        }
    }
    function Ca(l) {
        if (void 0 === l) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return l
    }
    function zb(l) {
        var p = tj();
        return function() {
            var q = Fe(l);
            if (p) {
                var f = Fe(this).constructor;
                q = Reflect.construct(q, arguments, f)
            } else q = q.apply(this, arguments);
            if (!q || "object" != typeof q && "function" != typeof q) {
                if (void 0 !== q) throw new TypeError("Derived constructors may only return object or undefined");
                q = Ca(this)
            }
            return q
        }
    }
    function ig(l, p) {
        if (l) {
            if ("string" == typeof l) return Ge(l, p);
            var q = Object.prototype.toString.call(l).slice(8, -1);
            return "Object" === q && l.constructor && (q = l.constructor.name),
            "Map" === q || "Set" === q ? Array.from(l) : "Arguments" === q || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(q) ? Ge(l, p) : void 0
        }
    }
    function Ge(l, p) { (null == p || p > l.length) && (p = l.length);
        for (var q = 0,
        f = Array(p); q < p; q++) f[q] = l[q];
        return f
    }
    function uj(l, p, q) {
        for (var f in p) l[f] = p[f],
        q && q(f, l[f]);
        return l
    }
    function vj(l) {
        return l.filter(function(p) {
            return null != p && 0 < vb(p).length
        })
    }
    function wj(l, p) {
        for (var q = 0; q < l.length; q++) {
            var f = l[q];
            null != f && 0 !== f.length && p(q, f)
        }
    }
    function jg(l, p) {
        return null == l ? l: vj(l.replace("/>", ">").split(/^<|>$/)[1].split(p))
    }
    function xj(l) {
        if (null == l || 0 === l.length) return ! 1;
        for (var p = l.length - 1; - 1 < p; p--) if ("each" === l[p].type) return ! 0;
        return ! 1
    }
    function Gd(l, p, q, f, n) {
        var d = fa(),
        k = {
            w: p,
            e: [],
            u: d
        };
        n.bindings[d] = k;
        return k.reapply = new Function("$data", (null != f ? "var out='';try { with($data) { if (" + f + ") out = this.w; else return null; }}catch(_){return null;}": "var out = this.w;") + "for (var k = 0; k < this.e.length; k++) { with($data) { " + (null != f ? "try {  if(" + f + ") { out = out.replace(this.e[k][0], eval(this.e[k][1])); } else out=''; } catch(__) { out='';}": "try { out = out.replace(this.e[k][0], eval(this.e[k][1])); } catch(__) { out=out.replace(this.e[k][0], '');}") + " }} return out;"),
        q.bindings[l] = k,
        p.replace(/\$\{([^\}]*)\}/g,
        function(a, e, c, h) {
            return k.e.push([a, e]),
            ""
        }),
        d
    }
    function yj(l, p) {
        l = jg(l, p.attributesRe);
        for (var q = {
            el: vb(l[0]),
            atts: {},
            bindings: {}
        },
        f = function(c, h) {
            var b = c.match(/([^=]+)=['"](.*)['"]/);
            if (null == b && null == h) q.atts[c] = "";
            else if (null == b) q.atts[c] = "",
            Gd(c, "", q, h, p);
            else {
                c = b[1];
                var g = b[2];
                q.atts[c] = g;
                Gd(c, g, q, h, p)
            }
            return b
        },
        n = 1; n < l.length; n++) {
            var d = vb(l[n]);
            if (null != d && 0 < d.length) {
                var k = d.match(p.inlineIfRe);
                if (k) {
                    d = k[2].split(p.attributesRe);
                    for (var a = 0; a < d.length; a++) {
                        var e = vb(d[a]);
                        null != e && 0 < e.length && f(e, k[1])
                    }
                } else f(d)
            }
        }
        return q
    }
    function Hd() {
        return {
            added: [],
            removed: [],
            elements: []
        }
    }
    function kg(l, p) {
        for (var q = 0; q < p.children.length; q++) {
            var f = !0,
            n;
            for (n in l) if (l[n] !== p.children[q][n]) {
                f = !1;
                break
            }
            if (f) return p.children[q]
        }
    }
    function lg(l, p, q, f, n) {
        var d, k, a = {},
        e = [],
        c = [],
        h = {
            added: [],
            removed: [],
            elements: []
        },
        b = function(v) {
            for (var w = "",
            z = 0; z < f.length; z++) w += v[f[z]];
            return w
        };
        if (0 < q.children.length) for (var g = 0; g < p.children.length; g++) {
            var m = p.children[g];
            for (var r = {},
            t = 0; t < f.length; t++) r[f[t]] = m[f[t]];
            null == (d = kg(r, q)) ? e.push(m) : (a[b(m)] = !0, k = l.updateFrom(m, d, null), Array.prototype.push.apply(h.added, k.added), Array.prototype.push.apply(h.removed, k.removed))
        } else Array.prototype.push.apply(e, p.children);
        var u = {};
        for (l = 0; l < e.length; l++) e[l].el.parentNode && e[l].el.parentNode.removeChild(e[l].el),
        u[e[l].index] = !0;
        l = p.children.filter(function(v) {
            return ! 0 !== u[v.index]
        });
        p.children = l;
        l = 0 < p.children.length ? p.children[p.children.length - 1].el: null;
        for (d = 0; d < q.children.length; d++) a[b(m = q.children[d])] || (p.children.push(m), c.push(m));
        if (0 < c.length) for (p = 0; p < c.length; p++) null != l ? l.parentNode.insertBefore(c[p].el, l.nextSibling) : null != n ? n.el.appendChild(c[p].el) : console.log("Knockle: couldnt insert child, nothing to insert after"),
        l = c[p].el;
        return Array.prototype.push.apply(h.added, c),
        Array.prototype.push.apply(h.removed, e),
        h
    }
    function mg(l, p) {
        for (var q = 0; q < p.length; q++) {
            var f = p[q];
            f.enumerable = f.enumerable || !1;
            f.configurable = !0;
            "value" in f && (f.writable = !0);
            Object.defineProperty(l, f.key, f)
        }
    }
    function zj(l, p, q) {
        return p && mg(l.prototype, p),
        q && mg(l, q),
        l
    }
    function Aj(l, p) {
        if ("function" != typeof p && null !== p) throw new TypeError("Super expression must either be null or a function");
        l.prototype = Object.create(p && p.prototype, {
            constructor: {
                value: l,
                writable: !0,
                configurable: !0
            }
        });
        p && ng(l, p)
    }
    function He(l) {
        return (He = Object.setPrototypeOf ? Object.getPrototypeOf: function(p) {
            return p.__proto__ || Object.getPrototypeOf(p)
        })(l)
    }
    function ng(l, p) {
        return (ng = Object.setPrototypeOf ||
        function(q, f) {
            return q.__proto__ = f,
            q
        })(l, p)
    }
    function Bj() {
        if ("undefined" == typeof Reflect || !Reflect.construct || Reflect.construct.sham) return ! 1;
        if ("function" == typeof Proxy) return ! 0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [],
            function() {})),
            !0
        } catch(l) {
            return ! 1
        }
    }
    function Cj(l) {
        var p = Bj();
        return function() {
            var q = He(l);
            if (p) {
                var f = He(this).constructor;
                q = Reflect.construct(q, arguments, f)
            } else q = q.apply(this, arguments);
            if (!q || "object" != typeof q && "function" != typeof q) {
                if (void 0 !== q) throw new TypeError("Derived constructors may only return object or undefined");
                if (void 0 === this) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                q = this
            }
            return q
        }
    }
    function Dj(l) {
        l = document.getElementById(l);
        return null != l ? l.innerHTML: null
    }
    function Yc(l) {
        "@babel/helpers - typeof";
        Yc = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ?
        function(p) {
            return typeof p
        }: function(p) {
            return p && "function" === typeof Symbol && p.constructor === Symbol && p !== Symbol.prototype ? "symbol": typeof p
        };
        return Yc(l)
    }
    function Sa(l, p) {
        if (! (l instanceof p)) throw new TypeError("Cannot call a class as a function");
    }
    function og(l, p) {
        for (var q = 0; q < p.length; q++) {
            var f = p[q];
            f.enumerable = f.enumerable || !1;
            f.configurable = !0;
            "value" in f && (f.writable = !0);
            Object.defineProperty(l, f.key, f)
        }
    }
    function Ta(l, p, q) {
        p && og(l.prototype, p);
        q && og(l, q);
        return l
    }
    function G(l, p, q) {
        p in l ? Object.defineProperty(l, p, {
            value: q,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : l[p] = q;
        return l
    }
    function Id(l, p) {
        if ("function" !== typeof p && null !== p) throw new TypeError("Super expression must either be null or a function");
        l.prototype = Object.create(p && p.prototype, {
            constructor: {
                value: l,
                writable: !0,
                configurable: !0
            }
        });
        p && Ie(l, p)
    }
    function eb(l) {
        eb = Object.setPrototypeOf ? Object.getPrototypeOf: function(p) {
            return p.__proto__ || Object.getPrototypeOf(p)
        };
        return eb(l)
    }
    function Ie(l, p) {
        Ie = Object.setPrototypeOf ||
        function(q, f) {
            q.__proto__ = f;
            return q
        };
        return Ie(l, p)
    }
    function Ej() {
        if ("undefined" === typeof Reflect || !Reflect.construct || Reflect.construct.sham) return ! 1;
        if ("function" === typeof Proxy) return ! 0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [],
            function() {})),
            !0
        } catch(l) {
            return ! 1
        }
    }
    function I(l) {
        if (void 0 === l) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return l
    }
    function Jd(l) {
        var p = Ej();
        return function() {
            var q = eb(l);
            if (p) {
                var f = eb(this).constructor;
                q = Reflect.construct(q, arguments, f)
            } else q = q.apply(this, arguments);
            q = !q || "object" !== typeof q && "function" !== typeof q ? I(this) : q;
            return q
        }
    }
    function Ab(l, p, q) {
        Ab = "undefined" !== typeof Reflect && Reflect.get ? Reflect.get: function(f, n, d) {
            for (; ! Object.prototype.hasOwnProperty.call(f, n) && (f = eb(f), null !== f););
            if (f) return n = Object.getOwnPropertyDescriptor(f, n),
            n.get ? n.get.call(d) : n.value
        };
        return Ab(l, p, q || l)
    }
    function pg(l, p) {
        if (null == p || p > l.length) p = l.length;
        for (var q = 0,
        f = Array(p); q < p; q++) f[q] = l[q];
        return f
    }
    function Bb(l, p, q) {
        q = q || l.parentNode;
        p = q.querySelectorAll(p);
        for (q = 0; q < p.length; q++) if (p[q] === l) return ! 0;
        return ! 1
    }
    function Ha(l, p) {
        l.stopPropagation ? l.stopPropagation() : l.returnValue = !1; ! p && l.preventDefault && l.preventDefault()
    }
    function sb(l, p, q, f) {
        if (f && Bb(l, p, q)) return l;
        for (l = l.parentNode; null != l && l !== q;) {
            if (Bb(l, p)) return l;
            l = l.parentNode
        }
    }
    function fb(l) {
        return l.srcElement || l.target
    }
    function Fj(l, p, q) {
        p = vb(p);
        "undefined" !== typeof l.className.baseVal ? l.className.baseVal = p: l.className = p;
        try {
            var f = l.classList;
            if (null != f) {
                for (; 0 < f.length;) f.remove(f.item(0));
                for (l = 0; l < q.length; l++) q[l] && f.add(q[l])
            }
        } catch(n) {
            pa("JSPLUMB: cannot set class list", n)
        }
    }
    function Je(l) {
        return null != l.className ? "undefined" === typeof l.className.baseVal ? l.className: l.className.baseVal: ""
    }
    function qg(l, p, q) {
        p = null == p ? [] : Array.isArray(p) ? p: p.split(/\s+/);
        q = null == q ? [] : Array.isArray(q) ? q: q.split(/\s+/);
        var f = Je(l).split(/\s+/),
        n = function(d, k) {
            for (var a = 0; a < k.length; a++) if (d) - 1 === f.indexOf(k[a]) && f.push(k[a]);
            else {
                var e = f.indexOf(k[a]); - 1 !== e && f.splice(e, 1)
            }
        };
        n(!0, p);
        n(!1, q);
        Fj(l, f.join(" "), f)
    }
    function hc(l) {
        return ! J(l) && !Array.isArray(l) && null != l.length && null == l.documentElement && null == l.nodeType
    }
    function rg(l) {
        return ! J(l) && (Array.isArray(l) || hc(l))
    }
    function sa(l, p) {
        var q = function(f, n) {
            null != f && null != n && 0 < n.length && (f.classList ? (n = vb(n).split(/\s+/), P(n,
            function(d) {
                f.classList.add(d)
            })) : qg(f, n))
        };
        hc(l) ? P(l,
        function(f) {
            return q(f, p)
        }) : q(l, p)
    }
    function ta(l, p) {
        var q = function(f, n) {
            null != f && null != n && 0 < n.length && (f.classList ? vb(n).split(/\s+/).forEach(function(d) {
                f.classList.remove(d)
            }) : qg(f, null, n))
        };
        hc(l) ? P(l,
        function(f) {
            return q(f, p)
        }) : q(l, p)
    }
    function Gj(l, p) {
        var q = this,
        f = function(n, d) {
            null != n && null != d && 0 < d.length && (n.classList ? n.classList.toggle(d) : q.hasClass(n, d) ? q.removeClass(n, d) : q.addClass(n, d))
        };
        hc(l) ? P(l,
        function(n) {
            return f(n, p)
        }) : f(l, p)
    }
    function Zc(l, p, q, f, n) {
        l = null == l ? document.createElement(p) : document.createElementNS(l, p);
        var d;
        q = q || {};
        for (d in q) l.style[d] = q[d];
        f && (l.className = f);
        n = n || {};
        for (d in n) l.setAttribute(d, "" + n[d]);
        return l
    }
    function sc(l) {
        l = l.getBoundingClientRect();
        var p = document.body,
        q = document.documentElement;
        return {
            x: Math.round(l.left + (window.pageXOffset || q.scrollLeft || p.scrollLeft) - (q.clientLeft || p.clientLeft || 0)),
            y: Math.round(l.top + (window.pageYOffset || q.scrollTop || p.scrollTop) - (q.clientTop || p.clientTop || 0))
        }
    }
    function Ja(l) {
        return {
            w: l.offsetWidth,
            h: l.offsetHeight
        }
    }
    function Hb(l, p) {
        for (var q in p) l.setAttribute(q, "" + p[q])
    }
    function Ib(l, p) {
        p = p || {};
        p.version = "1.1";
        p.xmlns = sg.svg;
        return Zc(sg.svg, l, null, null, p)
    }
    function Ke(l) {
        return "position:absolute;left:" + l[0] + "px;top:" + l[1] + "px"
    }
    function Le(l, p, q) {
        p.setAttribute("fill", q.fill ? q.fill: "none");
        p.setAttribute("stroke", q.stroke ? q.stroke: "none");
        q.strokeWidth && p.setAttribute("stroke-width", q.strokeWidth);
        if (q.dashstyle && q.strokeWidth && !q["stroke-dasharray"]) {
            var f = -1 === q.dashstyle.indexOf(",") ? " ": ",";
            l = q.dashstyle.split(f);
            var n = "";
            P(l,
            function(k) {
                n += Math.floor(k * q.strokeWidth) + f
            });
            p.setAttribute("stroke-dasharray", n)
        } else q["stroke-dasharray"] && p.setAttribute("stroke-dasharray", q["stroke-dasharray"]);
        for (var d in tg) q[d] && p.setAttribute(tg[d], q[d])
    }
    function Kd(l, p, q) {
        l.childNodes.length > q ? l.insertBefore(p, l.childNodes[q]) : l.appendChild(p)
    }
    function ug(l, p, q, f, n) {
        l.style.width = f + "px";
        l.style.height = n + "px";
        l.style.left = p + "px";
        l.style.top = q + "px";
        l.height = n;
        l.width = f
    }
    function la(l, p, q) {
        l = [l, p];
        q && l.push(q);
        return l.join(":")
    }
    function Hj() {
        var l = [];
        l.push.apply(l, arguments);
        l.item = function(p) {
            return this[p]
        };
        return l
    }
    function $c(l, p, q) {
        q = q || l.parentNode;
        p = q.querySelectorAll(p);
        for (q = 0; q < p.length; q++) if (p[q] === l) return ! 0;
        return ! 1
    }
    function Me(l, p, q, f) {
        if (f) {
            if ("undefined" !== typeof l.path && l.path.indexOf) return {
                path: l.path,
                end: l.path.indexOf(q)
            };
            var n = {
                path: [],
                end: -1
            }; (function a(k) {
                n.path.push(k);
                k === q ? n.end = n.path.length - 1 : null != k.parentNode && a(k.parentNode)
            })(p);
            return n
        }
        return {
            path: [p],
            end: 1
        }
    }
    function Ij(l, p) {
        var q;
        var f = 0;
        for (q = l.length; f < q && l[f][0] !== p; f++);
        f < l.length && l.splice(f, 1)
    }
    function Ne(l, p) {
        if (null == l) return {
            x: 0,
            y: 0
        };
        l = Ld(l);
        l = l.item ? l.item(0) : l[0];
        return {
            x: l[p + "X"],
            y: l[p + "Y"]
        }
    }
    function bb(l) {
        return Ne(l, "page")
    }
    function Ld(l) {
        return l.touches && 0 < l.touches.length ? l.touches: l.changedTouches && 0 < l.changedTouches.length ? l.changedTouches: l.targetTouches && 0 < l.targetTouches.length ? l.targetTouches: [l]
    }
    function Md(l, p, q, f, n) {
        vg(l, p, q);
        f.__tauid = q.__tauid;
        if (l.addEventListener) l.addEventListener(p, q, !1, n);
        else if (l.attachEvent) {
            var d = p + q.__tauid;
            l["e" + d] = q;
            l[d] = function() {
                l["e" + d] && l["e" + d](window.event)
            };
            l.attachEvent("on" + p, l[d])
        }
    }
    function ad(l, p, q) {
        var f = this;
        null != q && wg(l,
        function(n) {
            n.__ta && n.__ta[p] && delete n.__ta[p][q.__tauid];
            if (q.__taExtra) {
                for (var d = 0; d < q.__taExtra.length; d++) ad(n, q.__taExtra[d][0], q.__taExtra[d][1]);
                q.__taExtra.length = 0
            }
            q.__taUnstore && q.__taUnstore();
            null != q.__tauid && (n.removeEventListener ? (n.removeEventListener(p, q, !1), bd && Jb[p] && n.removeEventListener(Jb[p], q, !1)) : f.detachEvent && (d = p + q.__tauid, n[d] && n.detachEvent("on" + p, n[d]), n[d] = null, n["e" + d] = null));
            q.__taTouchProxy && ad(l, q.__taTouchProxy[1], q.__taTouchProxy[0])
        })
    }
    function wg(l, p) {
        if (null != l) {
            l = "string" === typeof l ? document.querySelectorAll(l) : null != l.length ? l: [l];
            for (var q = 0; q < l.length; q++) p(l[q])
        }
    }
    function vg(l, p, q) {
        var f = Jj++;
        l.__ta = l.__ta || {};
        l.__ta[p] = l.__ta[p] || {};
        l.__ta[p][f] = q;
        return q.__tauid = f
    }
    function Nd(l, p, q, f) {
        if (null == l) return q;
        var n = l.split(","),
        d = function e(a) {
            e.__tauid = q.__tauid;
            var c = !1,
            h = Me(a, a.srcElement || a.target, p, null != l);
            if ( - 1 != h.end) for (var b = 0; ! c && b < h.end; b++) {
                var g = h.path[b];
                for (var m = 0; ! c && m < n.length; m++) if ($c(g, n[m], p)) {
                    q.apply(g, [a, g]);
                    c = !0;
                    break
                }
            }
        };
        Kj(q, f, d);
        return d
    }
    function Kj(l, p, q) {
        l.__taExtra = l.__taExtra || [];
        l.__taExtra.push([p, q])
    }
    function xg(l, p, q, f) {
        for (var n in q.__tamee[l]) q.__tamee[l].hasOwnProperty(n) && q.__tamee[l][n].apply(f, [p])
    }
    function cd(l) {
        return {
            x: l.offsetLeft,
            y: l.offsetTop
        }
    }
    function yg(l) {
        return {
            w: l.offsetWidth,
            h: l.offsetHeight
        }
    }
    function zg(l, p) {
        l.style.left = p.x + "px";
        l.style.top = p.y + "px"
    }
    function Lj(l) {
        return "function" === typeof l ? (l._katavorioId = fa(), l._katavorioId) : l
    }
    function Ag(l, p, q) {
        var f = l.getSize(p.parentNode);
        l = l.getSize(p);
        p = q.x;
        q = q.y;
        var n = q + l.h;
        return 0 < p + l.w && p < f.w && 0 < n && q < f.h
    }
    function Mj(l, p) {
        return J(p) ? {
            id: p,
            active: !0
        }: {
            id: l.getId(p),
            active: p.active
        }
    }
    function Nj(l, p) {
        l = xf(l.members,
        function(q) {
            return q.el === p
        });
        return null !== l ? !0 === l.active: !1
    }
    function Oj(l) {
        var p = [];
        for (l = l._jsPlumbParentGroup; null != l;) p.push(l.el),
        l = l.group;
        return p
    }
    function Oe(l, p) {
        Bg[l] = p
    }
    function tc(l) {
        return l.type === Kb.type || l.type === uc.type || l.type === dd.type
    }
    function Cg(l) {
        l.canvas && l.canvas.parentNode.removeChild(l.canvas);
        delete l.canvas;
        delete l.svg
    }
    function ic(l) {
        return gb.getElement(l, l.component,
        function(p) {
            p = l.create(p);
            l.instance.addClass(p, l.instance.overlayClass);
            return p
        })
    }
    function Pj(l, p, q, f) {
        var n = l.x,
        d = l.y;
        p._jsPlumbParentGroup && p._jsPlumbParentGroup.constrain && (n = Math.max(l.x, 0), d = Math.max(l.y, 0), n = Math.min(n, q.w - f.w), d = Math.min(d, q.h - f.h));
        return {
            x: n,
            y: d
        }
    }
    function Qj(l) {
        var p = Dg + 1;
        Dg++;
        return new Rj(p, l)
    }
    function Eg(l, p) {
        for (var q = 0; q < p.length; q++) {
            var f = p[q];
            f.enumerable = f.enumerable || !1;
            f.configurable = !0;
            "value" in f && (f.writable = !0);
            Object.defineProperty(l, f.key, f)
        }
    }
    function Sj(l, p, q) {
        return p && Eg(l.prototype, p),
        q && Eg(l, q),
        l
    }
    function va(l, p, q) {
        return p in l ? Object.defineProperty(l, p, {
            value: q,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : l[p] = q,
        l
    }
    function Fg(l, p, q, f) {
        p = p.querySelectorAll("[jtk-att]");
        for (var n = 0; n < p.length; n++) {
            var d = p[n].tagName.toUpperCase(),
            k = "INPUT" === d ? (p[n].getAttribute("type") || "TEXT").toUpperCase() : d,
            a = p[n].getAttribute("jtk-att");
            a = f._rotors.data(l, a);
            null != a && Tj[k](p[n], a);
            q && f && p[n].getAttribute(Ka.JTK_COMMIT) && ("INPUT" === d ? f.eventManager.on(p[n], $a.KEYUP,
            function(e) {
                10 !== e.keyCode && 13 !== e.keyCode || f._close()
            }) : "TEXTAREA" === d && f.eventManager.on(p[n], $a.KEYUP,
            function(e) { ! e.ctrlKey || 10 !== e.keyCode && 13 !== e.keyCode || f._close()
            }))
        }
    }
    function Gg(l, p) {
        l = l.querySelectorAll(["[", Ka.JTK, "]"].join(""));
        for (var q = {},
        f = 0; f < l.length; f++) {
            var n = l[f].tagName.toUpperCase();
            n = "INPUT" === n ? (l[f].getAttribute(Ka.TYPE) || "TEXT").toUpperCase() : n;
            n = Uj[n](l[f]);
            var d = l[f].getAttribute(Ka.JTK);
            if (null != n) {
                var k = p.data(q, d);
                null != k ? (Array.isArray(k) || (k = [k], p.data(q, d, k)), k.push(n)) : p.data(q, d, n)
            }
        }
        return q
    }
    function Aa(l, p) {
        if (! (l instanceof p)) throw new TypeError("Cannot call a class as a function");
    }
    function Hg(l, p) {
        for (var q = 0; q < p.length; q++) {
            var f = p[q];
            f.enumerable = f.enumerable || !1;
            f.configurable = !0;
            "value" in f && (f.writable = !0);
            Object.defineProperty(l, f.key, f)
        }
    }
    function Ia(l, p, q) {
        return p && Hg(l.prototype, p),
        q && Hg(l, q),
        l
    }
    function D(l, p, q) {
        return p in l ? Object.defineProperty(l, p, {
            value: q,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : l[p] = q,
        l
    }
    function Vb(l, p) {
        if ("function" != typeof p && null !== p) throw new TypeError("Super expression must either be null or a function");
        l.prototype = Object.create(p && p.prototype, {
            constructor: {
                value: l,
                writable: !0,
                configurable: !0
            }
        });
        p && Ig(l, p)
    }
    function ed(l) {
        return (ed = Object.setPrototypeOf ? Object.getPrototypeOf: function(p) {
            return p.__proto__ || Object.getPrototypeOf(p)
        })(l)
    }
    function Ig(l, p) {
        return (Ig = Object.setPrototypeOf ||
        function(q, f) {
            return q.__proto__ = f,
            q
        })(l, p)
    }
    function Vj() {
        if ("undefined" == typeof Reflect || !Reflect.construct || Reflect.construct.sham) return ! 1;
        if ("function" == typeof Proxy) return ! 0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [],
            function() {})),
            !0
        } catch(l) {
            return ! 1
        }
    }
    function U(l) {
        if (void 0 === l) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return l
    }
    function Wb(l) {
        var p = Vj();
        return function() {
            var q = ed(l);
            if (p) {
                var f = ed(this).constructor;
                q = Reflect.construct(q, arguments, f)
            } else q = q.apply(this, arguments);
            if (!q || "object" != typeof q && "function" != typeof q) {
                if (void 0 !== q) throw new TypeError("Derived constructors may only return object or undefined");
                q = U(this)
            }
            return q
        }
    }
    function Jg(l, p, q) {
        return (Jg = "undefined" != typeof Reflect && Reflect.get ? Reflect.get: function(f, n, d) {
            for (; ! Object.prototype.hasOwnProperty.call(f, n) && null !== (f = ed(f)););
            if (f) return n = Object.getOwnPropertyDescriptor(f, n),
            n.get ? n.get.call(d) : n.value
        })(l, p, q || l)
    }
    function Pe(l, p) {
        var q = Array.isArray(l) ? l: void 0;
        if (!q) if (q = null == l ? null: "undefined" != typeof Symbol && l[Symbol.iterator] || l["@@iterator"], null != q) {
            var f, n = [],
            d = !0,
            k = !1;
            try {
                for (q = q.call(l); ! (d = (f = q.next()).done) && (n.push(f.value), !p || n.length !== p); d = !0);
            } catch(e) {
                k = !0;
                var a = e
            } finally {
                try {
                    d || null == q.
                    return || q.
                    return ()
                } finally {
                    if (k) throw a;
                }
            }
            q = n
        } else q = void 0;
        if (! (l = q || Kg(l, p))) throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        return l
    }
    function Lg(l) {
        var p = Array.isArray(l) ? Qe(l) : void 0;
        p || (p = "undefined" != typeof Symbol && null != l[Symbol.iterator] || null != l["@@iterator"] ? Array.from(l) : void 0);
        if (! (l = p || Kg(l))) throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        return l
    }
    function Kg(l, p) {
        if (l) {
            if ("string" == typeof l) return Qe(l, p);
            var q = Object.prototype.toString.call(l).slice(8, -1);
            return "Object" === q && l.constructor && (q = l.constructor.name),
            "Map" === q || "Set" === q ? Array.from(l) : "Arguments" === q || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(q) ? Qe(l, p) : void 0
        }
    }
    function Qe(l, p) { (null == p || p > l.length) && (p = l.length);
        for (var q = 0,
        f = Array(p); q < p; q++) f[q] = l[q];
        return f
    }
    function vc(l, p, q) {
        return function(f) {
            return f[l] / p * (q ? -1 : 1)
        }
    }
    function Mg(l) {
        return l.deltaY * (1 === l.deltaMode ? 25 : 1) * -1 / 120
    }
    function Ng(l) {
        return l.deltaX * (1 === l.deltaMode ? 25 : 1) * -1 / 120
    }
    function Og(l, p, q, f) {
        p = Wj(p, q, f);
        return l.addEventListener ? l.addEventListener(Pg, p, !1) : l.attachEvent && l.attachEvent("onmousewheel", p),
        p
    }
    function Qg(l, p) {
        p = p._jtkwl;
        null != p && (l.removeEventListener ? l.removeEventListener(Pg, p, !1) : l.detachEvent && l.detachEvent("onmousewheel", p))
    }
    function wc() {}
    function Rg(l) {
        for (var p = 0,
        q = 0; null != l && l !== document.body;) isNaN(l.scrollLeft) || (p += l.scrollLeft),
        isNaN(l.scrollTop) || (q += l.scrollTop),
        l = l.parentNode;
        return {
            x: p,
            y: q
        }
    }
    function Sg(l) {
        for (var p = 0,
        q = 0; null != l && l !== document.body;) p += l.offsetLeft,
        q += l.offsetTop,
        l = l.offsetParent;
        return {
            x: p,
            y: q
        }
    }
    function Xj(l, p) {
        p = p || 150;
        var q = null;
        return function() {
            window.clearTimeout(q);
            q = window.setTimeout(l, p)
        }
    }
    function Tg(l) {
        var p = window.XMLHttpRequest ? new XMLHttpRequest: new ActiveXObject("Microsoft.XMLHTTP"),
        q = l.type || "GET";
        if (p) {
            var f = "json" === l.dataType ?
            function(d) {
                return JSON.parse(d)
            }: function(d) {
                return d
            };
            p.open(q, l.url, !0);
            q = l.headers || {};
            for (var n in q) p.setRequestHeader(n, q[n]);
            p.onreadystatechange = function() {
                4 === p.readyState && ("2" === ("" + p.status)[0] ? l.success(f(p.responseText)) : l.error && l.error(p.responseText, p.status))
            };
            p.send(l.data ? JSON.stringify(l.data) : null)
        } else l.error && l.error("ajax not supported")
    }
    function Re(l) {
        return {
            x: parseInt(l.style.left, 10),
            y: parseInt(l.style.top, 10)
        }
    }
    function ob(l, p, q) {
        l.style.left = p + "px";
        l.style.top = q + "px"
    }
    function Xb(l, p) {
        return "[" + l + "='" + p + "']"
    }
    function Se(l, p) {
        return "endpoints" === l && Z(p.endpoints)
    }
    function Od(l, p, q) {
        var f = function(n) {
            return n ? p[n] : null
        };
        return (l = function k(d) {
            if (null == d) return {};
            if ("string" == typeof d) return f(d);
            if (d.length) {
                for (var a, e = !1,
                c = 0; ! e && c < d.length;)(a = k(d[c])) ? e = !0 : c++;
                return a
            }
        } (l)) ?
        function e(k, a) {
            if (null == k) return a;
            var c = Yj.slice();
            "override" === a.mergeStrategy && Array.prototype.push.apply(c, ["events", "overlays"]);
            null != q && (c = c.filter(function(h) {
                return q(h, a)
            }));
            c = R(k, a, [], c);
            return e(k ? f(k.parent) : null, c)
        } (l ? f(l.parent) : null, l) : {}
    }
    function Ug(l, p, q) {
        if (1 === p.connections.length) p.setVisible(q, !0);
        else if (q) p.setVisible(!0, !0);
        else {
            for (q = 0; q < p.connections.length; q++) if (p.connections[q] !== l && p.connections[q].isVisible()) return;
            p.setVisible(!1, !0)
        }
    }
    function Te(l) {
        var p = l.value("data-jtk-port"),
        q = l.value("data-jtk-port-type"),
        f = l.value("data-jtk-anchor-x"),
        n = l.value("data-jtk-anchor-y"),
        d = l.value("data-jtk-offset-x"),
        k = l.value("data-jtk-offset-y"),
        a = l.value("data-jtk-orientation-x"),
        e = l.value("data-jtk-orientation-y"),
        c = l.value("data-jtk-edge-type"),
        h = l.value("data-jtk-source");
        l = l.value("data-jtk-target");
        p = Q({
            portId: p,
            portType: q,
            source: h,
            target: l,
            edgeType: c
        });
        return null != f && null != n && (p.anchor = [parseFloat(f), parseFloat(n), parseInt(a || "0", 10), parseInt(e || "0", 10), parseFloat(d || "0"), parseFloat(k || "0")]),
        p
    }
    function xc(l) {
        return null != l.nodeType && 3 !== l.nodeType && 8 !== l.nodeType
    }
    function Zj(l, p, q) {
        if (null == l) return [];
        for (var f = [], n = 0; n < l.length; n++) {
            var d = l[n];
            var k = "string" == typeof d ? d: d.type; (d = ak.get(k, "string" == typeof d ? {}: d.options, p, q) || (pa("Decorator [" + k + "] nor registered on jsPlumbToolkit.Layouts.Decorators. Not fatal."), null)) && f.push(d)
        }
        return f
    }
    function fd(l, p) {
        if (! (l instanceof p)) throw new TypeError("Cannot call a class as a function");
    }
    function Vg(l, p) {
        for (var q = 0; q < p.length; q++) {
            var f = p[q];
            f.enumerable = f.enumerable || !1;
            f.configurable = !0;
            "value" in f && (f.writable = !0);
            Object.defineProperty(l, f.key, f)
        }
    }
    function gd(l, p, q) {
        return p && Vg(l.prototype, p),
        q && Vg(l, q),
        l
    }
    function hb(l, p, q) {
        return p in l ? Object.defineProperty(l, p, {
            value: q,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : l[p] = q,
        l
    }
    function Wg(l, p) {
        if ("function" != typeof p && null !== p) throw new TypeError("Super expression must either be null or a function");
        l.prototype = Object.create(p && p.prototype, {
            constructor: {
                value: l,
                writable: !0,
                configurable: !0
            }
        });
        p && Xg(l, p)
    }
    function Ue(l) {
        return (Ue = Object.setPrototypeOf ? Object.getPrototypeOf: function(p) {
            return p.__proto__ || Object.getPrototypeOf(p)
        })(l)
    }
    function Xg(l, p) {
        return (Xg = Object.setPrototypeOf ||
        function(q, f) {
            return q.__proto__ = f,
            q
        })(l, p)
    }
    function bk() {
        if ("undefined" == typeof Reflect || !Reflect.construct || Reflect.construct.sham) return ! 1;
        if ("function" == typeof Proxy) return ! 0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [],
            function() {})),
            !0
        } catch(l) {
            return ! 1
        }
    }
    function Yg(l) {
        if (void 0 === l) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return l
    }
    function Zg(l) {
        var p = bk();
        return function() {
            var q = Ue(l);
            if (p) {
                var f = Ue(this).constructor;
                q = Reflect.construct(q, arguments, f)
            } else q = q.apply(this, arguments);
            if (!q || "object" != typeof q && "function" != typeof q) {
                if (void 0 !== q) throw new TypeError("Derived constructors may only return object or undefined");
                q = Yg(this)
            }
            return q
        }
    }
    function ck(l) {
        return new $g(l || {})
    }
    function ah(l, p) {
        if (! (l instanceof p)) throw new TypeError("Cannot call a class as a function");
    }
    function bh(l, p) {
        for (var q = 0; q < p.length; q++) {
            var f = p[q];
            f.enumerable = f.enumerable || !1;
            f.configurable = !0;
            "value" in f && (f.writable = !0);
            Object.defineProperty(l, f.key, f)
        }
    }
    function ch(l, p, q) {
        return p && bh(l.prototype, p),
        q && bh(l, q),
        l
    }
    function Da(l, p, q) {
        return p in l ? Object.defineProperty(l, p, {
            value: q,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : l[p] = q,
        l
    }
    function dh(l, p) {
        var q = Array.isArray(l) ? l: void 0;
        if (!q) if (q = null == l ? null: "undefined" != typeof Symbol && l[Symbol.iterator] || l["@@iterator"], null != q) {
            var f, n = [],
            d = !0,
            k = !1;
            try {
                for (q = q.call(l); ! (d = (f = q.next()).done) && (n.push(f.value), !p || n.length !== p); d = !0);
            } catch(e) {
                k = !0;
                var a = e
            } finally {
                try {
                    d || null == q.
                    return || q.
                    return ()
                } finally {
                    if (k) throw a;
                }
            }
            q = n
        } else q = void 0; (f = q) || (l ? "string" == typeof l ? f = eh(l, p) : (a = Object.prototype.toString.call(l).slice(8, -1), f = ("Object" === a && l.constructor && (a = l.constructor.name), "Map" === a || "Set" === a ? Array.from(l) : "Arguments" === a || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a) ? eh(l, p) : void 0)) : f = void 0);
        if (! (l = f)) throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        return l
    }
    function eh(l, p) { (null == p || p > l.length) && (p = l.length);
        for (var q = 0,
        f = Array(p); q < p; q++) f[q] = l[q];
        return f
    }
    function dk(l, p, q, f, n, d, k, a, e) {
        d = l.faces;
        f = f.parentNode;
        n = [["left", q.x], ["right", n.w - q.x], ["top", q.y], ["bottom", n.h - q.y]];
        var c = new Map;
        c.set("top", [0, -1]);
        c.set("bottom", [0, 1]);
        c.set("left", [ - 1, 0]);
        c.set("right", [1, 0]);
        n.sort(function(g, m) {
            return g[1] < m[1] ? -1 : 1
        });
        for (var h = null,
        b = 0; b < n.length; b++) if ( - 1 != d.indexOf(n[b][0])) {
            h = n[b][0];
            break
        }
        null != h && (f.setAttribute("jtk-anchor-face", h), e.router.setCurrentFace(l, h), e.router.lock(l), l = c.get(h), p = e._getRotation(p.elementId), 0 !== p && (l = aj(l, p)), a.setAnchorOrientation(k, l));
        return q
    }
    function ek(l, p, q, f, n, d, k, a) {
        l.locations.map(function(e) {
            return [e.x, e.y, e.ox, e.oy, e]
        });
        p = l.locations.map(function(e, c) {
            return [c, Math.sqrt(Math.pow(q.x - n.w * e.x, 2) + Math.pow(q.y - n.h * e.y, 2)), e]
        });
        return p.sort(function(e, c) {
            return e[1] < c[1] ? -1 : 1
        }),
        l.currentLocation = p[0][0],
        q
    }
    function fh(l, p, q) {
        var f = document.createElement("div");
        return f.className = q || "",
        f.style.position = "absolute",
        f.style.left = l + "px",
        f.style.top = p + "px",
        f
    }
    function gh(l, p) {
        if (! (l instanceof p)) throw new TypeError("Cannot call a class as a function");
    }
    function hh(l, p) {
        for (var q = 0; q < p.length; q++) {
            var f = p[q];
            f.enumerable = f.enumerable || !1;
            f.configurable = !0;
            "value" in f && (f.writable = !0);
            Object.defineProperty(l, f.key, f)
        }
    }
    function ih(l, p, q) {
        return p && hh(l.prototype, p),
        q && hh(l, q),
        l
    }
    function Y(l, p, q) {
        return p in l ? Object.defineProperty(l, p, {
            value: q,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : l[p] = q,
        l
    }
    function jh(l, p) {
        for (var q = 0; q < p.length; q++) {
            var f = p[q];
            f.enumerable = f.enumerable || !1;
            f.configurable = !0;
            "value" in f && (f.writable = !0);
            Object.defineProperty(l, f.key, f)
        }
    }
    function fk(l, p, q) {
        return p && jh(l.prototype, p),
        q && jh(l, q),
        l
    }
    function hd(l, p) {
        var q = p === Ve.INCHES ? 96 : kh;
        return l.map(function(f) {
            return f * q
        })
    }
    function lh(l, p) {
        var q = p === Ve.INCHES ? 96 : kh;
        return l.map(function(f) {
            return f / q
        })
    }
    function mh(l) {
        var p = this;
        l.relayout(null);
        var q = [],
        f = [],
        n = [],
        d = [];
        l.jsplumb.getContainer().querySelectorAll(".jtk-overlay,.jtk-node,.jtk-endpoint,.jtk-group,.jtk-connector").forEach(function(c) {
            c = p.findElementBounds(c);
            var h = c.l;
            isNaN(h) || q.push(h);
            h = c.t;
            isNaN(h) || n.push(h);
            h = c.l1;
            isNaN(h) || f.push(h);
            c = c.t1;
            isNaN(c) || d.push(c)
        });
        l = Math.min.apply(null, q);
        var k = Math.max.apply(null, f),
        a = Math.min.apply(null, n),
        e = Math.max.apply(null, d);
        return {
            x: l,
            y: a,
            w: k - l,
            h: e - a,
            padding: null,
            vw: k + (0 > l ? -l: 0),
            vh: e + (0 > a ? -a: 0),
            z: null,
            zoom: null
        }
    }
    function nh(l, p) {
        for (var q = 0; q < p.length; q++) {
            var f = p[q];
            f.enumerable = f.enumerable || !1;
            f.configurable = !0;
            "value" in f && (f.writable = !0);
            Object.defineProperty(l, f.key, f)
        }
    }
    function gk(l, p, q) {
        return p && nh(l.prototype, p),
        q && nh(l, q),
        l
    }
    function na(l, p, q) {
        return p in l ? Object.defineProperty(l, p, {
            value: q,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : l[p] = q,
        l
    }
    function oh(l, p) {
        for (var q = 0; q < p.length; q++) {
            var f = p[q];
            f.enumerable = f.enumerable || !1;
            f.configurable = !0;
            "value" in f && (f.writable = !0);
            Object.defineProperty(l, f.key, f)
        }
    }
    function hk(l, p, q) {
        return p && oh(l.prototype, p),
        q && oh(l, q),
        l
    }
    function ha(l, p, q) {
        return p in l ? Object.defineProperty(l, p, {
            value: q,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : l[p] = q,
        l
    }
    function ik(l, p) {
        if ("function" != typeof p && null !== p) throw new TypeError("Super expression must either be null or a function");
        l.prototype = Object.create(p && p.prototype, {
            constructor: {
                value: l,
                writable: !0,
                configurable: !0
            }
        });
        p && ph(l, p)
    }
    function We(l) {
        return (We = Object.setPrototypeOf ? Object.getPrototypeOf: function(p) {
            return p.__proto__ || Object.getPrototypeOf(p)
        })(l)
    }
    function ph(l, p) {
        return (ph = Object.setPrototypeOf ||
        function(q, f) {
            return q.__proto__ = f,
            q
        })(l, p)
    }
    function jk() {
        if ("undefined" == typeof Reflect || !Reflect.construct || Reflect.construct.sham) return ! 1;
        if ("function" == typeof Proxy) return ! 0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [],
            function() {})),
            !0
        } catch(l) {
            return ! 1
        }
    }
    function ia(l) {
        if (void 0 === l) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return l
    }
    function kk(l) {
        var p = jk();
        return function() {
            var q = We(l);
            if (p) {
                var f = We(this).constructor;
                q = Reflect.construct(q, arguments, f)
            } else q = q.apply(this, arguments);
            if (!q || "object" != typeof q && "function" != typeof q) {
                if (void 0 !== q) throw new TypeError("Derived constructors may only return object or undefined");
                q = ia(this)
            }
            return q
        }
    }
    function qh(l, p) {
        for (var q = 0; q < p.length; q++) {
            var f = p[q];
            f.enumerable = f.enumerable || !1;
            f.configurable = !0;
            "value" in f && (f.writable = !0);
            Object.defineProperty(l, f.key, f)
        }
    }
    function lk(l, p, q) {
        return p && qh(l.prototype, p),
        q && qh(l, q),
        l
    }
    function ib(l, p, q) {
        return p in l ? Object.defineProperty(l, p, {
            value: q,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : l[p] = q,
        l
    }
    function mk(l, p) {
        if ("function" != typeof p && null !== p) throw new TypeError("Super expression must either be null or a function");
        l.prototype = Object.create(p && p.prototype, {
            constructor: {
                value: l,
                writable: !0,
                configurable: !0
            }
        });
        p && rh(l, p)
    }
    function Xe(l) {
        return (Xe = Object.setPrototypeOf ? Object.getPrototypeOf: function(p) {
            return p.__proto__ || Object.getPrototypeOf(p)
        })(l)
    }
    function rh(l, p) {
        return (rh = Object.setPrototypeOf ||
        function(q, f) {
            return q.__proto__ = f,
            q
        })(l, p)
    }
    function nk() {
        if ("undefined" == typeof Reflect || !Reflect.construct || Reflect.construct.sham) return ! 1;
        if ("function" == typeof Proxy) return ! 0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [],
            function() {})),
            !0
        } catch(l) {
            return ! 1
        }
    }
    function jb(l) {
        if (void 0 === l) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return l
    }
    function ok(l) {
        var p = nk();
        return function() {
            var q = Xe(l);
            if (p) {
                var f = Xe(this).constructor;
                q = Reflect.construct(q, arguments, f)
            } else q = q.apply(this, arguments);
            if (!q || "object" != typeof q && "function" != typeof q) {
                if (void 0 !== q) throw new TypeError("Derived constructors may only return object or undefined");
                q = jb(this)
            }
            return q
        }
    }
    function id(l) {
        var p = l[0].ax1,
        q = l[0].ay1,
        f = l[l.length - 1].ax2,
        n = l[l.length - 1].ay2,
        d = f >= p ? p: f,
        k = n >= q ? q: n;
        return l.forEach(function(a) {
            a.x1 = a.ax1 - d;
            a.y1 = a.ay1 - k;
            a.x2 = a.ax2 - d;
            a.y2 = a.ay2 - k;
            null != a.o && 0 !== a.o.length || (a.o = a.ax1 === a.ax2 ? "v": "h")
        }),
        l
    }
    function yc(l, p, q, f) {
        var n = null;
        if (null != f) {
            if ( - 1 === (f = l.indexOf(f))) return null;
            f += p
        } else f = -1 === p ? l.length - 2 : 1;
        for (; 0 < f && f < l.length - 1; f += p) if (l[f].o === q) {
            n = [l[f], f];
            break
        }
        return n
    }
    function Pd(l) {
        return Math.sqrt(Math.pow(l.ax2 - l.ax1, 2) + Math.pow(l.ay2 - l.ay1, 2))
    }
    function sh(l) {
        return 0 > l ? -1 : 0 === l ? 0 : 1
    }
    function th(l) {
        return [sh(l.x2 - l.x1), sh(l.y2 - l.y1)]
    }
    function uh(l, p) {
        return [l.startStubX, l.startStubY, l.endStubX, l.endStubY]
    }
    function vh(l, p) {
        return l.curX === p.curX && l.curY === p.curY
    }
    function Qd(l, p, q, f, n, d) {
        if (l.lastx !== p || l.lasty !== q) {
            var k = null == l.lastx ? f.sx: l.lastx;
            f = null == l.lasty ? f.sy: l.lasty;
            l.lastx = p;
            l.lasty = q;
            l.orthogonalSegments.push({
                x1: k,
                y1: f,
                x2: p,
                y2: q,
                o: k === p ? "v": "h",
                ax1: k + n,
                ay1: f + d,
                ax2: p + n,
                ay2: q + d
            })
        }
    }
    function wh(l, p) {
        for (var q = 0; q < p.length; q++) {
            var f = p[q];
            f.enumerable = f.enumerable || !1;
            f.configurable = !0;
            "value" in f && (f.writable = !0);
            Object.defineProperty(l, f.key, f)
        }
    }
    function pk(l, p, q) {
        return p && wh(l.prototype, p),
        q && wh(l, q),
        l
    }
    function jd(l, p, q) {
        return p in l ? Object.defineProperty(l, p, {
            value: q,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : l[p] = q,
        l
    }
    function qk(l, p) {
        if ("function" != typeof p && null !== p) throw new TypeError("Super expression must either be null or a function");
        l.prototype = Object.create(p && p.prototype, {
            constructor: {
                value: l,
                writable: !0,
                configurable: !0
            }
        });
        p && xh(l, p)
    }
    function Ye(l) {
        return (Ye = Object.setPrototypeOf ? Object.getPrototypeOf: function(p) {
            return p.__proto__ || Object.getPrototypeOf(p)
        })(l)
    }
    function xh(l, p) {
        return (xh = Object.setPrototypeOf ||
        function(q, f) {
            return q.__proto__ = f,
            q
        })(l, p)
    }
    function rk() {
        if ("undefined" == typeof Reflect || !Reflect.construct || Reflect.construct.sham) return ! 1;
        if ("function" == typeof Proxy) return ! 0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [],
            function() {})),
            !0
        } catch(l) {
            return ! 1
        }
    }
    function kd(l) {
        if (void 0 === l) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return l
    }
    function sk(l) {
        var p = rk();
        return function() {
            var q = Ye(l);
            if (p) {
                var f = Ye(this).constructor;
                q = Reflect.construct(q, arguments, f)
            } else q = q.apply(this, arguments);
            if (!q || "object" != typeof q && "function" != typeof q) {
                if (void 0 !== q) throw new TypeError("Derived constructors may only return object or undefined");
                q = kd(this)
            }
            return q
        }
    }
    function yh(l, p) {
        if (! (l instanceof p)) throw new TypeError("Cannot call a class as a function");
    }
    function zh(l, p) {
        for (var q = 0; q < p.length; q++) {
            var f = p[q];
            f.enumerable = f.enumerable || !1;
            f.configurable = !0;
            "value" in f && (f.writable = !0);
            Object.defineProperty(l, f.key, f)
        }
    }
    function Ah(l, p, q) {
        return p && zh(l.prototype, p),
        q && zh(l, q),
        l
    }
    function Ea(l, p, q) {
        return p in l ? Object.defineProperty(l, p, {
            value: q,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : l[p] = q,
        l
    }
    function Ze() {}
    function ld(l) {
        var p = document.createElement("div");
        return sa(p, l.join(" ")),
        document.body.appendChild(p),
        p
    }
    for (var Oa = [], md = 0; 256 > md; md++) Oa[md] = (16 > md ? "0": "") + md.toString(16);
    var zc = function() {
        function l() {
            Af(this, l);
            Sc(this, "_listeners", {});
            Sc(this, "eventsSuspended", !1);
            Sc(this, "tick", !1);
            Sc(this, "eventsToDieOn", {
                ready: !0
            });
            Sc(this, "queue", [])
        }
        Cf(l, [{
            key: "fire",
            value: function(p, q, f) {
                var n = null;
                if (this.tick) this.queue.unshift(arguments);
                else {
                    this.tick = !0;
                    if (!this.eventsSuspended && this._listeners[p]) {
                        var d = this._listeners[p].length,
                        k = 0,
                        a = !1;
                        if (!this.shouldFireEvent || this.shouldFireEvent(p, q, f)) for (; ! a && k < d && !1 !== n;) {
                            if (this.eventsToDieOn[p]) this._listeners[p][k].apply(this, [q, f]);
                            else try {
                                n = this._listeners[p][k].apply(this, [q, f])
                            } catch(e) {
                                pa("jsPlumb: fire failed for event " + p + " : " + (e.message || e))
                            }
                            k++;
                            if (null == this._listeners || null == this._listeners[p]) a = !0
                        }
                    }
                    this.tick = !1;
                    this._drain()
                }
                return n
            }
        },
        {
            key: "_drain",
            value: function() {
                var p = this.queue.pop();
                p && this.fire.apply(this, p)
            }
        },
        {
            key: "unbind",
            value: function(p, q) {
                if (0 === arguments.length) this._listeners = {};
                else if (1 === arguments.length) if ("string" === typeof p) delete this._listeners[p];
                else {
                    if (p.__jsPlumb) {
                        var f;
                        for (f in p.__jsPlumb) {
                            var n = p.__jsPlumb[f];
                            yf(this._listeners[n] || [], p)
                        }
                    }
                } else 2 === arguments.length && yf(this._listeners[p] || [], q);
                return this
            }
        },
        {
            key: "getListener",
            value: function(p) {
                return this._listeners[p] || []
            }
        },
        {
            key: "isSuspendEvents",
            value: function() {
                return this.eventsSuspended
            }
        },
        {
            key: "setSuspendEvents",
            value: function(p) {
                this.eventsSuspended = p
            }
        },
        {
            key: "bind",
            value: function(p, q, f) {
                var n = this,
                d = function(a) {
                    oe(n._listeners, a, q, f);
                    q.__jsPlumb = q.__jsPlumb || {};
                    q.__jsPlumb[fa()] = a
                };
                if ("string" === typeof p) d(p);
                else if (null != p.length) for (var k = 0; k < p.length; k++) d(p[k]);
                return this
            }
        },
        {
            key: "silently",
            value: function(p) {
                this.setSuspendEvents(!0);
                try {
                    p()
                } catch(q) {
                    pa("Cannot execute silent function " + q)
                }
                this.setSuspendEvents(!1)
            }
        }]);
        return l
    } (),
    $e = function(l) {
        function p() {
            Af(this, p);
            return q.apply(this, arguments)
        }
        bj(p, l);
        var q = dj(p);
        Cf(p, [{
            key: "shouldFireEvent",
            value: function(f, n, d) {
                return ! 0
            }
        }]);
        return p
    } (zc),
    ej = [null, [1, -1], [1, 1], [ - 1, 1], [ - 1, -1]],
    fj = [null, [ - 1, -1], [ - 1, 1], [1, 1], [1, -1]],
    jc = 2 * Math.PI,
    Yb; (function(l) {
        l.Circle = "Circle";
        l.Ellipse = "Ellipse";
        l.Triangle = "Triangle";
        l.Diamond = "Diamond";
        l.Rectangle = "Rectangle";
        l.Square = "Square"
    })(Yb || (Yb = {}));
    var ec; (function(l) {
        l.Assign = "Assign";
        l.AutoDefault = "AutoDefault";
        l.Bottom = "Bottom";
        l.BottomLeft = "BottomLeft";
        l.BottomRight = "BottomRight";
        l.Center = "Center";
        l.Continuous = "Continuous";
        l.ContinuousBottom = "ContinuousBottom";
        l.ContinuousLeft = "ContinuousLeft";
        l.ContinuousRight = "ContinuousRight";
        l.ContinuousTop = "ContinuousTop";
        l.ContinuousLeftRight = "ContinuousLeftRight";
        l.ContinuousTopBottom = "ContinuousTopBottom";
        l.Left = "Left";
        l.Perimeter = "Perimeter";
        l.Right = "Right";
        l.Top = "Top";
        l.TopLeft = "TopLeft";
        l.TopRight = "TopRight"
    })(ec || (ec = {}));
    var Bh = function() {
        function l(p) {
            if (! (this instanceof l)) throw new TypeError("Cannot call a class as a function");
            this.params = p;
            qc(this, "x1", void 0);
            qc(this, "x2", void 0);
            qc(this, "y1", void 0);
            qc(this, "y2", void 0);
            qc(this, "extents", zd());
            qc(this, "type", void 0);
            this.x1 = p.x1;
            this.y1 = p.y1;
            this.x2 = p.x2;
            this.y2 = p.y2
        }
        gj(l, [{
            key: "findClosestPointOnPath",
            value: function(p, q) {
                return {
                    d: Infinity,
                    x: null,
                    y: null,
                    l: null,
                    x1: null,
                    y1: null,
                    x2: null,
                    y2: null
                }
            }
        },
        {
            key: "lineIntersection",
            value: function(p, q, f, n) {
                return []
            }
        },
        {
            key: "boxIntersection",
            value: function(p, q, f, n) {
                var d = [];
                d.push.apply(d, this.lineIntersection(p, q, p + f, q));
                d.push.apply(d, this.lineIntersection(p + f, q, p + f, q + n));
                d.push.apply(d, this.lineIntersection(p + f, q + n, p, q + n));
                d.push.apply(d, this.lineIntersection(p, q + n, p, q));
                return d
            }
        },
        {
            key: "boundingBoxIntersection",
            value: function(p) {
                return this.boxIntersection(p.x, p.y, p.w, p.h)
            }
        }]);
        return l
    } (),
    Ch = {},
    Dh = {},
    Eh = {},
    Zb = {
        get: function(l, p, q) {
            var f = Ch[p];
            if (f) return new f(l, q);
            throw {
                message: "jsPlumb: unknown endpoint type '" + p + "'"
            };
        },
        clone: function(l) {
            return Zb.get(l.endpoint, l.type, Eh[l.type].getParams(l))
        },
        compute: function(l, p, q, f) {
            var n = Dh[l.type];
            if (null != n) return n(l, p, q, f);
            pa("jsPlumb: cannot find endpoint calculator for endpoint of type ", l.type)
        },
        registerHandler: function(l) {
            Eh[l.type] = l;
            Ch[l.type] = l.cls;
            Dh[l.type] = l.compute
        }
    },
    Ac = function() {
        function l(p, q) {
            ja(this, l);
            this.endpoint = p;
            x(this, "typeId", void 0);
            x(this, "x", void 0);
            x(this, "y", void 0);
            x(this, "w", void 0);
            x(this, "h", void 0);
            x(this, "computedValue", void 0);
            x(this, "bounds", zd());
            x(this, "classes", []);
            x(this, "instance", void 0);
            x(this, "type", void 0);
            q = q || {};
            this.instance = p.instance;
            p.cssClass && this.classes.push(p.cssClass);
            q.cssClass && this.classes.push(q.cssClass)
        }
        ua(l, [{
            key: "addClass",
            value: function(p) {
                this.classes.push(p);
                this.instance.addEndpointClass(this.endpoint, p)
            }
        },
        {
            key: "removeClass",
            value: function(p) {
                this.classes = this.classes.filter(function(q) {
                    return q !== p
                });
                this.instance.removeEndpointClass(this.endpoint, p)
            }
        },
        {
            key: "compute",
            value: function(p, q, f) {
                this.computedValue = Zb.compute(this, p, q, f);
                this.bounds.xmin = this.x;
                this.bounds.ymin = this.y;
                this.bounds.xmax = this.x + this.w;
                this.bounds.ymax = this.y + this.h
            }
        },
        {
            key: "setVisible",
            value: function(p) {
                this.instance.setEndpointVisible(this.endpoint, p)
            }
        }]);
        return l
    } (),
    Bc = function(l) {
        function p(f, n) {
            ja(this, p);
            f = q.call(this, f, n);
            x(C(f), "radius", void 0);
            x(C(f), "defaultOffset", void 0);
            x(C(f), "defaultInnerRadius", void 0);
            x(C(f), "type", p.type);
            n = n || {};
            f.radius = n.radius || 5;
            f.defaultOffset = .5 * f.radius;
            f.defaultInnerRadius = f.radius / 3;
            return f
        }
        xa(p, l);
        var q = ya(p);
        return p
    } (Ac);
    x(Bc, "type", "Dot");
    var tk = {
        type: Bc.type,
        cls: Bc,
        compute: function(l, p, q, f) {
            q = p.curX - l.radius;
            p = p.curY - l.radius;
            var n = 2 * l.radius,
            d = 2 * l.radius;
            f && f.stroke && (f = f.strokeWidth || 1, q -= f, p -= f, n += 2 * f, d += 2 * f);
            l.x = q;
            l.y = p;
            l.w = n;
            l.h = d;
            return [q, p, n, d, l.radius]
        },
        getParams: function(l) {
            return {
                radius: l.radius
            }
        }
    },
    nd = function(l) {
        function p(f, n) {
            ja(this, p);
            f = q.call(this, f, n);
            x(C(f), "type", p.type);
            return f
        }
        xa(p, l);
        var q = ya(p);
        return p
    } (Ac);
    x(nd, "type", "Blank");
    var uk = {
        type: nd.type,
        cls: nd,
        compute: function(l, p, q, f) {
            l.x = p.curX;
            l.y = p.curY;
            l.w = 10;
            l.h = 0;
            return [p.curX, p.curY, 10, 0]
        },
        getParams: function(l) {
            return {}
        }
    },
    Rd = function(l) {
        function p(f, n) {
            ja(this, p);
            f = q.call(this, f, n);
            x(C(f), "width", void 0);
            x(C(f), "height", void 0);
            x(C(f), "type", p.type);
            n = n || {};
            f.width = n.width || 10;
            f.height = n.height || 10;
            return f
        }
        xa(p, l);
        var q = ya(p);
        ua(p, null, [{
            key: "_getParams",
            value: function(f) {
                return {
                    width: f.width,
                    height: f.height
                }
            }
        }]);
        return p
    } (Ac);
    x(Rd, "type", "Rectangle");
    var vk = {
        type: Rd.type,
        cls: Rd,
        compute: function(l, p, q, f) {
            q = f.width || l.width;
            f = f.height || l.height;
            var n = p.curX - q / 2;
            p = p.curY - f / 2;
            l.x = n;
            l.y = p;
            l.w = q;
            l.h = f;
            return [n, p, q, f]
        },
        getParams: function(l) {
            return {
                width: l.width,
                height: l.height
            }
        }
    },
    af = function() {
        function l(p, q) {
            ja(this, l);
            this.connection = p;
            x(this, "type", void 0);
            x(this, "edited", !1);
            x(this, "stub", void 0);
            x(this, "sourceStub", void 0);
            x(this, "targetStub", void 0);
            x(this, "maxStub", void 0);
            x(this, "typeId", void 0);
            x(this, "gap", void 0);
            x(this, "sourceGap", void 0);
            x(this, "targetGap", void 0);
            x(this, "segments", []);
            x(this, "totalLength", 0);
            x(this, "segmentProportions", []);
            x(this, "segmentProportionalLengths", []);
            x(this, "paintInfo", null);
            x(this, "strokeWidth", void 0);
            x(this, "x", void 0);
            x(this, "y", void 0);
            x(this, "w", void 0);
            x(this, "h", void 0);
            x(this, "segment", void 0);
            x(this, "bounds", zd());
            x(this, "cssClass", void 0);
            x(this, "hoverClass", void 0);
            x(this, "geometry", void 0);
            this.stub = q.stub || this.getDefaultStubs();
            this.sourceStub = Array.isArray(this.stub) ? this.stub[0] : this.stub;
            this.targetStub = Array.isArray(this.stub) ? this.stub[1] : this.stub;
            this.gap = q.gap || 0;
            this.sourceGap = Array.isArray(this.gap) ? this.gap[0] : this.gap;
            this.targetGap = Array.isArray(this.gap) ? this.gap[1] : this.gap;
            this.maxStub = Math.max(this.sourceStub, this.targetStub);
            this.cssClass = q.cssClass || "";
            this.hoverClass = q.hoverClass || ""
        }
        ua(l, [{
            key: "getTypeDescriptor",
            value: function() {
                return "connector"
            }
        },
        {
            key: "getIdPrefix",
            value: function() {
                return "_jsplumb_connector"
            }
        },
        {
            key: "setGeometry",
            value: function(p, q) {
                this.geometry = p;
                this.edited = null != p && !q
            }
        },
        {
            key: "exportGeometry",
            value: function() {
                return this.geometry
            }
        },
        {
            key: "importGeometry",
            value: function(p) {
                this.geometry = p;
                return ! 0
            }
        },
        {
            key: "resetGeometry",
            value: function() {
                this.geometry = null;
                this.edited = !1
            }
        },
        {
            key: "resetBounds",
            value: function() {
                this.bounds = zd()
            }
        },
        {
            key: "findSegmentForPoint",
            value: function(p, q) {
                for (var f = {
                    d: Infinity,
                    s: null,
                    x: null,
                    y: null,
                    l: null,
                    x1: null,
                    y1: null,
                    x2: null,
                    y2: null,
                    index: null,
                    connectorLocation: null
                },
                n = 0; n < this.segments.length; n++) {
                    var d = this.segments[n].findClosestPointOnPath(p, q);
                    d.d < f.d && (f.d = d.d, f.l = d.l, f.x = d.x, f.y = d.y, f.s = this.segments[n], f.x1 = d.x1, f.x2 = d.x2, f.y1 = d.y1, f.y2 = d.y2, f.index = n, f.connectorLocation = this.segmentProportions[n][0] + d.l * (this.segmentProportions[n][1] - this.segmentProportions[n][0]))
                }
                return f
            }
        },
        {
            key: "lineIntersection",
            value: function(p, q, f, n) {
                for (var d = [], k = 0; k < this.segments.length; k++) d.push.apply(d, this.segments[k].lineIntersection(p, q, f, n));
                return d
            }
        },
        {
            key: "boxIntersection",
            value: function(p, q, f, n) {
                for (var d = [], k = 0; k < this.segments.length; k++) d.push.apply(d, this.segments[k].boxIntersection(p, q, f, n));
                return d
            }
        },
        {
            key: "boundingBoxIntersection",
            value: function(p) {
                for (var q = [], f = 0; f < this.segments.length; f++) q.push.apply(q, this.segments[f].boundingBoxIntersection(p));
                return q
            }
        },
        {
            key: "_updateSegmentProportions",
            value: function() {
                for (var p = 0,
                q = 0; q < this.segments.length; q++) {
                    var f = this.segments[q].getLength();
                    this.segmentProportionalLengths[q] = f / this.totalLength;
                    this.segmentProportions[q] = [p, p += f / this.totalLength]
                }
            }
        },
        {
            key: "_findSegmentForLocation",
            value: function(p, q) {
                var f;
                q && (p = 0 < p ? p / this.totalLength: (this.totalLength + p) / this.totalLength);
                if (1 === p) {
                    q = this.segments.length - 1;
                    var n = 1
                } else if (0 === p) q = n = 0;
                else if (.5 <= p) for (n = q = 0, f = this.segmentProportions.length - 1; - 1 < f; f--) {
                    if (this.segmentProportions[f][1] >= p && this.segmentProportions[f][0] <= p) {
                        q = f;
                        n = (p - this.segmentProportions[f][0]) / this.segmentProportionalLengths[f];
                        break
                    }
                } else for (q = this.segmentProportions.length - 1, n = 1, f = 0; f < this.segmentProportions.length; f++) if (this.segmentProportions[f][1] >= p) {
                    q = f;
                    n = (p - this.segmentProportions[f][0]) / this.segmentProportionalLengths[f];
                    break
                }
                return {
                    segment: this.segments[q],
                    proportion: n,
                    index: q
                }
            }
        },
        {
            key: "_addSegment",
            value: function(p, q) {
                if (q.x1 !== q.x2 || q.y1 !== q.y2) p = new p(q),
                this.segments.push(p),
                this.totalLength += p.getLength(),
                this.updateBounds(p)
            }
        },
        {
            key: "_clearSegments",
            value: function() {
                this.totalLength = 0;
                this.segments.length = 0;
                this.segmentProportions.length = 0;
                this.segmentProportionalLengths.length = 0
            }
        },
        {
            key: "getLength",
            value: function() {
                return this.totalLength
            }
        },
        {
            key: "_prepareCompute",
            value: function(p) {
                this.strokeWidth = p.strokeWidth;
                var q = p.sourcePos.curX,
                f = p.targetPos.curX,
                n = p.sourcePos.curY,
                d = p.targetPos.curY,
                k = yd({
                    x: q,
                    y: n
                },
                {
                    x: f,
                    y: d
                }),
                a = f < q,
                e = d < n,
                c = [p.sourcePos.ox, p.sourcePos.oy];
                p = [p.targetPos.ox, p.targetPos.oy];
                var h = a ? f: q,
                b = e ? d: n,
                g = Math.abs(f - q),
                m = Math.abs(d - n);
                if (0 === c[0] && 0 === c[1] || 0 === p[0] && 0 === p[1]) {
                    var r = g > m ? 0 : 1,
                    t = [1, 0][r];
                    q = 0 === r ? q: n;
                    f = 0 === r ? f: d;
                    c[r] = q > f ? -1 : 1;
                    p[r] = q > f ? 1 : -1;
                    c[t] = 0;
                    p[t] = 0
                }
                f = a ? g + this.sourceGap * c[0] : this.sourceGap * c[0];
                d = e ? m + this.sourceGap * c[1] : this.sourceGap * c[1];
                a = a ? this.targetGap * p[0] : g + this.targetGap * p[0];
                e = e ? this.targetGap * p[1] : m + this.targetGap * p[1];
                r = c[0] * p[0] + c[1] * p[1];
                k = {
                    sx: f,
                    sy: d,
                    tx: a,
                    ty: e,
                    xSpan: Math.abs(a - f),
                    ySpan: Math.abs(e - d),
                    mx: (f + a) / 2,
                    my: (d + e) / 2,
                    so: c,
                    to: p,
                    x: h,
                    y: b,
                    w: g,
                    h: m,
                    segment: k,
                    startStubX: f + c[0] * this.sourceStub,
                    startStubY: d + c[1] * this.sourceStub,
                    endStubX: a + p[0] * this.targetStub,
                    endStubY: e + p[1] * this.targetStub,
                    isXGreaterThanStubTimes2: Math.abs(f - a) > this.sourceStub + this.targetStub,
                    isYGreaterThanStubTimes2: Math.abs(d - e) > this.sourceStub + this.targetStub,
                    opposite: -1 === r,
                    perpendicular: 0 === r,
                    orthogonal: 1 === r,
                    sourceAxis: 0 === c[0] ? "y": "x",
                    points: [h, b, g, m, f, d, a, e],
                    stubs: [this.sourceStub, this.targetStub]
                };
                k.anchorOrientation = k.opposite ? "opposite": k.orthogonal ? "orthogonal": "perpendicular";
                return k
            }
        },
        {
            key: "updateBounds",
            value: function(p) {
                p = p.extents;
                this.bounds.xmin = Math.min(this.bounds.xmin, p.xmin);
                this.bounds.xmax = Math.max(this.bounds.xmax, p.xmax);
                this.bounds.ymin = Math.min(this.bounds.ymin, p.ymin);
                this.bounds.ymax = Math.max(this.bounds.ymax, p.ymax)
            }
        },
        {
            key: "dumpSegmentsToConsole",
            value: function() {
                pa("SEGMENTS:");
                for (var p = 0; p < this.segments.length; p++) pa(this.segments[p].type, "" + this.segments[p].getLength(), "" + this.segmentProportions[p])
            }
        },
        {
            key: "pointOnPath",
            value: function(p, q) {
                p = this._findSegmentForLocation(p, q);
                return p.segment && p.segment.pointOnPath(p.proportion, !1) || {
                    x: 0,
                    y: 0
                }
            }
        },
        {
            key: "gradientAtPoint",
            value: function(p, q) {
                p = this._findSegmentForLocation(p, q);
                return p.segment && p.segment.gradientAtPoint(p.proportion, !1) || 0
            }
        },
        {
            key: "pointAlongPathFrom",
            value: function(p, q, f) {
                p = this._findSegmentForLocation(p, f);
                return p.segment && p.segment.pointAlongPathFrom(p.proportion, q, !1) || {
                    x: 0,
                    y: 0
                }
            }
        },
        {
            key: "compute",
            value: function(p) {
                this.paintInfo = this._prepareCompute(p);
                this._clearSegments();
                this._compute(this.paintInfo, p);
                this.x = this.paintInfo.points[0];
                this.y = this.paintInfo.points[1];
                this.w = this.paintInfo.points[2];
                this.h = this.paintInfo.points[3];
                this.segment = this.paintInfo.segment;
                this._updateSegmentProportions()
            }
        },
        {
            key: "setAnchorOrientation",
            value: function(p, q) {}
        }]);
        return l
    } (),
    kc = function(l) {
        function p(f) {
            ja(this, p);
            var n = q.call(this, f);
            x(C(n), "length", void 0);
            x(C(n), "m", void 0);
            x(C(n), "m2", void 0);
            x(C(n), "type", p.segmentType);
            n._setCoordinates({
                x1: f.x1,
                y1: f.y1,
                x2: f.x2,
                y2: f.y2
            });
            return n
        }
        xa(p, l);
        var q = ya(p);
        ua(p, [{
            key: "getPath",
            value: function(f) {
                return (f ? "M " + this.x1 + " " + this.y1 + " ": "") + "L " + this.x2 + " " + this.y2
            }
        },
        {
            key: "_recalc",
            value: function() {
                this.length = Math.sqrt(Math.pow(this.x2 - this.x1, 2) + Math.pow(this.y2 - this.y1, 2));
                this.m = bc({
                    x: this.x1,
                    y: this.y1
                },
                {
                    x: this.x2,
                    y: this.y2
                });
                this.m2 = -1 / this.m;
                this.extents = {
                    xmin: Math.min(this.x1, this.x2),
                    ymin: Math.min(this.y1, this.y2),
                    xmax: Math.max(this.x1, this.x2),
                    ymax: Math.max(this.y1, this.y2)
                }
            }
        },
        {
            key: "getLength",
            value: function() {
                return this.length
            }
        },
        {
            key: "getGradient",
            value: function() {
                return this.m
            }
        },
        {
            key: "_setCoordinates",
            value: function(f) {
                this.x1 = f.x1;
                this.y1 = f.y1;
                this.x2 = f.x2;
                this.y2 = f.y2;
                this._recalc()
            }
        },
        {
            key: "pointOnPath",
            value: function(f, n) {
                return 0 !== f || n ? 1 !== f || n ? dc({
                    x: this.x1,
                    y: this.y1
                },
                {
                    x: this.x2,
                    y: this.y2
                },
                n ? 0 < f ? f: this.length + f: f * this.length) : {
                    x: this.x2,
                    y: this.y2
                }: {
                    x: this.x1,
                    y: this.y1
                }
            }
        },
        {
            key: "gradientAtPoint",
            value: function(f, n) {
                return this.m
            }
        },
        {
            key: "pointAlongPathFrom",
            value: function(f, n, d) {
                f = this.pointOnPath(f, d);
                d = 0 >= n ? {
                    x: this.x1,
                    y: this.y1
                }: {
                    x: this.x2,
                    y: this.y2
                };
                0 >= n && 1 < Math.abs(n) && (n *= -1);
                return dc(f, d, n)
            }
        },
        {
            key: "within",
            value: function(f, n, d) {
                return d >= Math.min(f, n) && d <= Math.max(f, n)
            }
        },
        {
            key: "closest",
            value: function(f, n, d) {
                return Math.abs(d - f) < Math.abs(d - n) ? f: n
            }
        },
        {
            key: "findClosestPointOnPath",
            value: function(f, n) {
                var d = {
                    d: Infinity,
                    x: null,
                    y: null,
                    l: null,
                    x1: this.x1,
                    x2: this.x2,
                    y1: this.y1,
                    y2: this.y2
                };
                if (0 === this.m) d.y = this.y1,
                d.x = this.within(this.x1, this.x2, f) ? f: this.closest(this.x1, this.x2, f);
                else if (Infinity === this.m || -Infinity === this.m) d.x = this.x1,
                d.y = this.within(this.y1, this.y2, n) ? n: this.closest(this.y1, this.y2, n);
                else {
                    var k = this.y1 - this.m * this.x1,
                    a = (n - this.m2 * f - k) / (this.m - this.m2);
                    k = this.m * a + k;
                    d.x = this.within(this.x1, this.x2, a) ? a: this.closest(this.x1, this.x2, a);
                    d.y = this.within(this.y1, this.y2, k) ? k: this.closest(this.y1, this.y2, k)
                }
                a = Va({
                    x: d.x,
                    y: d.y
                },
                {
                    x: this.x1,
                    y: this.y1
                });
                d.d = Va({
                    x: f,
                    y: n
                },
                d);
                d.l = a / length;
                return d
            }
        },
        {
            key: "_pointLiesBetween",
            value: function(f, n, d) {
                return d > n ? n <= f && f <= d: n >= f && f >= d
            }
        },
        {
            key: "lineIntersection",
            value: function(f, n, d, k) {
                var a = Math.abs(bc({
                    x: f,
                    y: n
                },
                {
                    x: d,
                    y: k
                })),
                e = Math.abs(this.m),
                c = Infinity === e ? this.x1: this.y1 - e * this.x1,
                h = [],
                b = Infinity === a ? f: n - a * f;
                a !== e && (Infinity === a && 0 === e ? this._pointLiesBetween(f, this.x1, this.x2) && this._pointLiesBetween(this.y1, n, k) && h.push({
                    x: f,
                    y: this.y1
                }) : 0 === a && Infinity === e ? this._pointLiesBetween(n, this.y1, this.y2) && this._pointLiesBetween(this.x1, f, d) && h.push({
                    x: this.x1,
                    y: n
                }) : Infinity === a ? (a = f, this._pointLiesBetween(a, this.x1, this.x2) && (b = e * f + c, this._pointLiesBetween(b, n, k) && h.push({
                    x: a,
                    y: b
                }))) : 0 === a ? (b = n, this._pointLiesBetween(b, this.y1, this.y2) && (a = (n - c) / e, this._pointLiesBetween(a, f, d) && h.push({
                    x: a,
                    y: b
                }))) : (a = (b - c) / (e - a), b = e * a + c, this._pointLiesBetween(a, this.x1, this.x2) && this._pointLiesBetween(b, this.y1, this.y2) && h.push({
                    x: a,
                    y: b
                })));
                return h
            }
        },
        {
            key: "boxIntersection",
            value: function(f, n, d, k) {
                var a = [];
                a.push.apply(a, this.lineIntersection(f, n, f + d, n));
                a.push.apply(a, this.lineIntersection(f + d, n, f + d, n + k));
                a.push.apply(a, this.lineIntersection(f + d, n + k, f, n + k));
                a.push.apply(a, this.lineIntersection(f, n + k, f, n));
                return a
            }
        }]);
        return p
    } (Bh);
    x(kc, "segmentType", "Straight");
    var Sd = function(l) {
        function p() {
            ja(this, p);
            var f = arguments.length;
            for (var n = Array(f), d = 0; d < f; d++) n[d] = arguments[d];
            f = q.call.apply(q, [this].concat(n));
            x(C(f), "type", p.type);
            return f
        }
        xa(p, l);
        var q = ya(p);
        ua(p, [{
            key: "getDefaultStubs",
            value: function() {
                return [0, 0]
            }
        },
        {
            key: "_compute",
            value: function(f, n) {
                this._addSegment(kc, {
                    x1: f.sx,
                    y1: f.sy,
                    x2: f.startStubX,
                    y2: f.startStubY
                });
                this._addSegment(kc, {
                    x1: f.startStubX,
                    y1: f.startStubY,
                    x2: f.endStubX,
                    y2: f.endStubY
                });
                this._addSegment(kc, {
                    x1: f.endStubX,
                    y1: f.endStubY,
                    x2: f.tx,
                    y2: f.ty
                });
                this.geometry = {
                    source: n.sourcePos,
                    target: n.targetPos
                }
            }
        }]);
        return p
    } (af);
    x(Sd, "type", "Straight");
    var Fh = {},
    bf = {
        get: function(l, p, q) {
            var f = Fh[p];
            if (f) return new f(l, q);
            throw {
                message: "jsPlumb: unknown connector type '" + p + "'"
            };
        },
        register: function(l, p) {
            Fh[l] = p
        }
    },
    Ba = wb("data-jtk-managed"),
    Td = function(l) {
        function p(f, n, d) {
            ja(this, p);
            var k = q.call(this);
            k.instance = f;
            k.component = n;
            x(C(k), "id", void 0);
            x(C(k), "type", void 0);
            x(C(k), "cssClass", void 0);
            x(C(k), "visible", !0);
            x(C(k), "location", void 0);
            x(C(k), "events", void 0);
            d = d || {};
            k.id = d.id || fa();
            k.cssClass = d.cssClass || "";
            k.location = d.location || .5;
            k.events = d.events || {};
            for (var a in k.events) k.bind(a, k.events[a]);
            return k
        }
        xa(p, l);
        var q = ya(p);
        ua(p, [{
            key: "shouldFireEvent",
            value: function(f, n, d) {
                return ! 0
            }
        },
        {
            key: "setVisible",
            value: function(f) {
                this.visible = f;
                this.instance.setOverlayVisible(this, f)
            }
        },
        {
            key: "isVisible",
            value: function() {
                return this.visible
            }
        }]);
        return p
    } (zc),
    Gh = {},
    lc = {
        get: function(l, p, q, f) {
            var n = Gh[p];
            if (n) return new n(l, q, f);
            throw {
                message: "jsPlumb: unknown overlay type '" + p + "'"
            };
        },
        register: function(l, p) {
            Gh[l] = p
        }
    },
    Fb = function(l) {
        function p(f, n, d) {
            ja(this, p);
            var k = q.call(this, f, n, d);
            k.instance = f;
            k.component = n;
            x(C(k), "label", void 0);
            x(C(k), "labelText", void 0);
            x(C(k), "type", p.type);
            x(C(k), "cachedDimensions", void 0);
            d = d || {
                label: ""
            };
            k.setLabel(d.label);
            return k
        }
        xa(p, l);
        var q = ya(p);
        ua(p, [{
            key: "getLabel",
            value: function() {
                return Z(this.label) ? this.label(this) : this.labelText
            }
        },
        {
            key: "setLabel",
            value: function(f) {
                this.label = f;
                this.labelText = null;
                this.instance.updateLabel(this)
            }
        },
        {
            key: "getDimensions",
            value: function() {
                return {
                    w: 1,
                    h: 1
                }
            }
        },
        {
            key: "updateFrom",
            value: function(f) {
                null != f.label && this.setLabel(f.label)
            }
        }]);
        return p
    } (Td);
    x(Fb, "type", "Label");
    lc.register("Label", Fb);
    var Hh = function(l) {
        function p(f, n) {
            ja(this, p);
            var d = q.call(this);
            d.instance = f;
            x(C(d), "defaultLabelLocation", .5);
            x(C(d), "overlays", {});
            x(C(d), "overlayPositions", {});
            x(C(d), "overlayPlacements", {});
            x(C(d), "clone", void 0);
            x(C(d), "deleted", void 0);
            x(C(d), "segment", void 0);
            x(C(d), "x", void 0);
            x(C(d), "y", void 0);
            x(C(d), "w", void 0);
            x(C(d), "h", void 0);
            x(C(d), "id", void 0);
            x(C(d), "visible", !0);
            x(C(d), "typeId", void 0);
            x(C(d), "params", {});
            x(C(d), "paintStyle", void 0);
            x(C(d), "hoverPaintStyle", void 0);
            x(C(d), "paintStyleInUse", void 0);
            x(C(d), "_hover", !1);
            x(C(d), "lastPaintedAt", void 0);
            x(C(d), "data", void 0);
            x(C(d), "_defaultType", void 0);
            x(C(d), "events", void 0);
            x(C(d), "parameters", void 0);
            x(C(d), "_types", void 0);
            x(C(d), "_typeCache", void 0);
            x(C(d), "cssClass", void 0);
            x(C(d), "hoverClass", void 0);
            x(C(d), "beforeDetach", void 0);
            x(C(d), "beforeDrop", void 0);
            n = n || {};
            d.cssClass = n.cssClass || "";
            d.hoverClass = n.hoverClass || f.defaults.hoverClass;
            d.beforeDetach = n.beforeDetach;
            d.beforeDrop = n.beforeDrop;
            d._types = [];
            d._typeCache = {};
            d.parameters = O(n.parameters || {});
            d.id = n.id || d.getIdPrefix() + (new Date).getTime();
            d._defaultType = {
                parameters: d.parameters,
                scope: n.scope || d.instance.defaultScope,
                overlays: {}
            };
            if (n.events) for (var k in n.events) d.bind(k, n.events[k]);
            d.clone = function() {
                var h = Object.create(d.constructor.prototype);
                d.constructor.apply(h, [f, n]);
                return h
            };
            d.overlays = {};
            d.overlayPositions = {};
            k = n.overlays || [];
            var a = {},
            e = d.getDefaultOverlayKey();
            if (e) for ((e = d.instance.defaults[e]) && k.push.apply(k, Ad(e)), e = 0; e < k.length; e++) {
                var c = ve(k[e]);
                a[c.options.id] = c
            }
            d._defaultType.overlays = a;
            n.label && (d.getDefaultType().overlays.__label = {
                type: Fb.type,
                options: {
                    label: n.label,
                    location: n.labelLocation || d.defaultLabelLocation,
                    id: "__label"
                }
            });
            return d
        }
        xa(p, l);
        var q = ya(p);
        ua(p, [{
            key: "isDetachAllowed",
            value: function(f) {
                var n = !0;
                if (this.beforeDetach) try {
                    n = this.beforeDetach(f)
                } catch(d) {
                    pa("jsPlumb: beforeDetach callback failed", d)
                }
                return n
            }
        },
        {
            key: "isDropAllowed",
            value: function(f, n, d, k, a) {
                f = {
                    sourceId: f,
                    targetId: n,
                    scope: d,
                    connection: k,
                    dropEndpoint: a
                };
                if (this.beforeDrop) try {
                    var e = this.beforeDrop(f)
                } catch(c) {
                    pa("jsPlumb: beforeDrop callback failed", c)
                } else e = this.instance.checkCondition("beforeDrop", f);
                return e
            }
        },
        {
            key: "getDefaultType",
            value: function() {
                return this._defaultType
            }
        },
        {
            key: "appendToDefaultType",
            value: function(f) {
                for (var n in f) this._defaultType[n] = f[n]
            }
        },
        {
            key: "getId",
            value: function() {
                return this.id
            }
        },
        {
            key: "cacheTypeItem",
            value: function(f, n, d) {
                this._typeCache[d] = this._typeCache[d] || {};
                this._typeCache[d][f] = n
            }
        },
        {
            key: "getCachedTypeItem",
            value: function(f, n) {
                return this._typeCache[n] ? this._typeCache[n][f] : null
            }
        },
        {
            key: "setType",
            value: function(f, n) {
                this.clearTypes();
                this._types = Bd(f) || [];
                rc(this, n)
            }
        },
        {
            key: "getType",
            value: function() {
                return this._types
            }
        },
        {
            key: "reapplyTypes",
            value: function(f) {
                rc(this, f)
            }
        },
        {
            key: "hasType",
            value: function(f) {
                return - 1 !== this._types.indexOf(f)
            }
        },
        {
            key: "addType",
            value: function(f, n) {
                f = Bd(f);
                var d = !1;
                if (null != f) {
                    for (var k = 0,
                    a = f.length; k < a; k++) this.hasType(f[k]) || (this._types.push(f[k]), d = !0);
                    d && rc(this, n)
                }
            }
        },
        {
            key: "removeType",
            value: function(f, n) {
                f = Bd(f);
                var d = !1;
                if (null != f) {
                    for (var k = 0,
                    a = f.length; k < a; k++) {
                        var e = this._types.indexOf(f[k]); - 1 !== e ? (we(this, e), this._types.splice(e, 1), e = !0) : e = !1;
                        d = e || d
                    }
                    d && rc(this, n)
                }
            }
        },
        {
            key: "clearTypes",
            value: function(f, n) {
                n = this._types.length;
                for (var d = 0; d < n; d++) we(this, 0),
                this._types.splice(0, 1);
                rc(this, f)
            }
        },
        {
            key: "toggleType",
            value: function(f, n) {
                f = Bd(f);
                if (null != f) {
                    for (var d = 0,
                    k = f.length; d < k; d++) {
                        var a = this._types.indexOf(f[d]); - 1 !== a ? (we(this, a), this._types.splice(a, 1)) : this._types.push(f[d])
                    }
                    rc(this, n)
                }
            }
        },
        {
            key: "applyType",
            value: function(f, n) {
                this.setPaintStyle(f.paintStyle);
                this.setHoverPaintStyle(f.hoverPaintStyle);
                this.mergeParameters(f.parameters);
                this.paintStyleInUse = this.getPaintStyle();
                if (f.overlays) {
                    n = {};
                    for (var d in f.overlays) {
                        var k = this.overlays[f.overlays[d].options.id];
                        k ? (k.updateFrom(f.overlays[d].options), n[f.overlays[d].options.id] = !0, this.instance.reattachOverlay(k, this)) : (k = this.getCachedTypeItem("overlay", f.overlays[d].options.id), null != k ? (this.instance.reattachOverlay(k, this), k.setVisible(!0), k.updateFrom(f.overlays[d].options), this.overlays[k.id] = k) : k = this.addOverlay(f.overlays[d]), n[k.id] = !0)
                    }
                    for (d in this.overlays) null == n[this.overlays[d].id] && this.removeOverlay(this.overlays[d].id, !0)
                }
            }
        },
        {
            key: "setPaintStyle",
            value: function(f) {
                this.paintStyleInUse = this.paintStyle = f;
                Jf(this)
            }
        },
        {
            key: "getPaintStyle",
            value: function() {
                return this.paintStyle
            }
        },
        {
            key: "setHoverPaintStyle",
            value: function(f) {
                this.hoverPaintStyle = f;
                Jf(this)
            }
        },
        {
            key: "getHoverPaintStyle",
            value: function() {
                return this.hoverPaintStyle
            }
        },
        {
            key: "destroy",
            value: function() {
                for (var f in this.overlays) this.instance.destroyOverlay(this.overlays[f]);
                this.overlays = {};
                this.overlayPositions = {};
                this.unbind();
                this.clone = null
            }
        },
        {
            key: "isHover",
            value: function() {
                return this._hover
            }
        },
        {
            key: "mergeParameters",
            value: function(f) {
                null != f && A(this.parameters, f)
            }
        },
        {
            key: "setVisible",
            value: function(f) { (this.visible = f) ? this.showOverlays() : this.hideOverlays()
            }
        },
        {
            key: "isVisible",
            value: function() {
                return this.visible
            }
        },
        {
            key: "setAbsoluteOverlayPosition",
            value: function(f, n) {
                this.overlayPositions[f.id] = n
            }
        },
        {
            key: "getAbsoluteOverlayPosition",
            value: function(f) {
                return this.overlayPositions ? this.overlayPositions[f.id] : null
            }
        },
        {
            key: "_clazzManip",
            value: function(f, n) {
                for (var d in this.overlays)"add" === f ? this.instance.addOverlayClass(this.overlays[d], n) : "remove" === f && this.instance.removeOverlayClass(this.overlays[d], n)
            }
        },
        {
            key: "addClass",
            value: function(f, n) {
                n = (this.cssClass || "").split(" ");
                n.push(f);
                this.cssClass = n.join(" ");
                this._clazzManip("add", f)
            }
        },
        {
            key: "removeClass",
            value: function(f, n) {
                this.cssClass = (this.cssClass || "").split(" ").filter(function(d) {
                    return d !== f
                }).join(" ");
                this._clazzManip("remove", f)
            }
        },
        {
            key: "getClass",
            value: function() {
                return this.cssClass
            }
        },
        {
            key: "shouldFireEvent",
            value: function(f, n, d) {
                return ! 0
            }
        },
        {
            key: "getData",
            value: function() {
                return this.data
            }
        },
        {
            key: "setData",
            value: function(f) {
                this.data = f || {}
            }
        },
        {
            key: "mergeData",
            value: function(f) {
                this.data = A(this.data, f)
            }
        },
        {
            key: "addOverlay",
            value: function(f) {
                if (J(f)) var n = lc.get(this.instance, f, this, {});
                else null != f.type && null != f.options ? (n = A({},
                f.options), n = lc.get(this.instance, f.type, this, n)) : n = f;
                n.id = n.id || fa();
                this.cacheTypeItem("overlay", n, n.id);
                this.overlays[n.id] = n;
                if (this.getData && n.type === Fb.type && !J(f)) {
                    var d = this.getData();
                    f = f.options;
                    d && (f = d[f.labelLocationAttribute || "labelLocation"]) && (n.location = f)
                }
                return n
            }
        },
        {
            key: "getOverlay",
            value: function(f) {
                return this.overlays[f]
            }
        },
        {
            key: "getOverlays",
            value: function() {
                return this.overlays
            }
        },
        {
            key: "hideOverlay",
            value: function(f) { (f = this.getOverlay(f)) && f.setVisible(!1)
            }
        },
        {
            key: "hideOverlays",
            value: function() {
                for (var f in this.overlays) this.overlays[f].setVisible(!1)
            }
        },
        {
            key: "showOverlay",
            value: function(f) { (f = this.getOverlay(f)) && f.setVisible(!0)
            }
        },
        {
            key: "showOverlays",
            value: function() {
                for (var f in this.overlays) this.overlays[f].setVisible(!0)
            }
        },
        {
            key: "removeAllOverlays",
            value: function() {
                for (var f in this.overlays) this.instance.destroyOverlay(this.overlays[f]);
                this.overlays = {};
                this.overlayPositions = null;
                this.overlayPlacements = {}
            }
        },
        {
            key: "removeOverlay",
            value: function(f, n) {
                var d = this.overlays[f];
                d && (d.setVisible(!1), n || this.instance.destroyOverlay(d), delete this.overlays[f], this.overlayPositions && delete this.overlayPositions[f], this.overlayPlacements && delete this.overlayPlacements[f])
            }
        },
        {
            key: "removeOverlays",
            value: function() {
                for (var f = arguments.length,
                n = Array(f), d = 0; d < f; d++) n[d] = arguments[d];
                f = 0;
                for (n = n.length; f < n; f++) this.removeOverlay(arguments[f])
            }
        },
        {
            key: "getLabel",
            value: function() {
                var f = this.getLabelOverlay();
                return null != f ? f.getLabel() : null
            }
        },
        {
            key: "getLabelOverlay",
            value: function() {
                return this.getOverlay("__label")
            }
        },
        {
            key: "setLabel",
            value: function(f) {
                var n = this.getLabelOverlay();
                n ? J(f) || Z(f) ? n.setLabel(f) : (f.label && n.setLabel(f.label), f.location && (n.location = f.location)) : (f = J(f) || Z(f) ? {
                    label: f
                }: f, f = A({
                    cssClass: f.cssClass,
                    id: "__label",
                    component: this
                },
                f), n = new Fb(this.instance, this, f), this.overlays.__label = n)
            }
        }]);
        return p
    } (zc),
    Cc,
    Dc,
    Ec,
    Fc; (function(l) {
        l.top = "top";
        l.left = "left";
        l.right = "right";
        l.bottom = "bottom"
    })(Fc || (Fc = {}));
    var wa = Fc.top,
    La = Fc.left,
    Ma = Fc.right,
    Ua = Fc.bottom,
    wk = [La, Ma],
    xk = [wa, Ua],
    yk = function() {
        function l(p, q) {
            ja(this, l);
            this.instance = p;
            this.element = q;
            x(this, "isFloating", !0);
            x(this, "isContinuous", void 0);
            x(this, "isDynamic", void 0);
            x(this, "locations", [{
                x: 0,
                y: 0,
                ox: 0,
                oy: 0,
                offx: 0,
                offy: 0,
                iox: 0,
                ioy: 0,
                cls: ""
            }]);
            x(this, "currentLocation", 0);
            x(this, "locked", !1);
            x(this, "cssClass", "");
            x(this, "timestamp", null);
            x(this, "type", "Floating");
            x(this, "id", fa());
            x(this, "orientation", [0, 0]);
            x(this, "size", void 0);
            this.size = p.getSize(q)
        }
        ua(l, [{
            key: "over",
            value: function(p) {
                this.orientation = this.instance.router.getEndpointOrientation(p);
                this.locations[0].ox = this.orientation[0];
                this.locations[0].oy = this.orientation[1]
            }
        },
        {
            key: "out",
            value: function() {
                this.orientation = null;
                this.locations[0].ox = this.locations[0].iox;
                this.locations[0].oy = this.locations[0].ioy
            }
        }]);
        return l
    } (),
    Lf = (Cc = {},
    x(Cc, wa, Ua), x(Cc, Ma, La), x(Cc, La, Ma), x(Cc, Ua, wa), Cc),
    Mf = (Dc = {},
    x(Dc, wa, Ma), x(Dc, Ma, Ua), x(Dc, La, wa), x(Dc, Ua, La), Dc),
    Nf = (Ec = {},
    x(Ec, wa, La), x(Ec, Ma, wa), x(Ec, La, Ua), x(Ec, Ua, Ma), Ec),
    Ih = {
        x: .5,
        y: 0,
        ox: 0,
        oy: -1,
        offx: 0,
        offy: 0
    },
    Jh = {
        x: .5,
        y: 1,
        ox: 0,
        oy: 1,
        offx: 0,
        offy: 0
    },
    Kh = {
        x: 0,
        y: .5,
        ox: -1,
        oy: 0,
        offx: 0,
        offy: 0
    },
    Lh = {
        x: 1,
        y: .5,
        ox: 1,
        oy: 0,
        offx: 0,
        offy: 0
    },
    Pf = {
        Top: [Ih],
        Bottom: [Jh],
        Left: [Kh],
        Right: [Lh],
        TopLeft: [{
            x: 0,
            y: 0,
            ox: 0,
            oy: -1,
            offx: 0,
            offy: 0
        }],
        TopRight: [{
            x: 1,
            y: 0,
            ox: 1,
            oy: -1,
            offx: 0,
            offy: 0
        }],
        BottomLeft: [{
            x: 0,
            y: 1,
            ox: 0,
            oy: 1,
            offx: 0,
            offy: 0
        }],
        BottomRight: [{
            x: 1,
            y: 1,
            ox: 0,
            oy: 1,
            offx: 0,
            offy: 0
        }],
        Center: [{
            x: .5,
            y: .5,
            ox: 0,
            oy: 0,
            offx: 0,
            offy: 0
        }],
        AutoDefault: [Ih, Kh, Jh, Lh]
    },
    kj = {
        Continuous: {
            faces: [wa, La, Ua, Ma]
        },
        ContinuousTop: {
            faces: [wa]
        },
        ContinuousRight: {
            faces: [Ma]
        },
        ContinuousBottom: {
            faces: [Ua]
        },
        ContinuousLeft: {
            faces: [La]
        },
        ContinuousLeftRight: {
            faces: [La, Ma]
        },
        ContinuousTopBottom: {
            faces: [wa, Ua]
        }
    },
    mj = "currentFace",
    Pb = new Map;
    Pb.set(Yb.Circle, Rf);
    Pb.set(Yb.Ellipse, Rf);
    Pb.set(Yb.Rectangle, Sf);
    Pb.set(Yb.Square, Sf);
    Pb.set(Yb.Diamond,
    function(l) {
        return xe([[.5, 0, 1, .5], [1, .5, .5, 1], [.5, 1, 0, .5], [0, .5, .5, 0]], l)
    });
    Pb.set(Yb.Triangle,
    function(l) {
        return xe([[.5, 0, 1, 1], [1, 1, 0, 1], [0, 1, .5, 0]], l)
    });
    var mc = function(l) {
        function p(f, n) {
            ja(this, p);
            var d = q.call(this, f, n);
            d.instance = f;
            x(C(d), "connector", void 0);
            x(C(d), "defaultLabelLocation", .5);
            x(C(d), "scope", void 0);
            x(C(d), "typeId", "_jsplumb_connection");
            x(C(d), "previousConnection", void 0);
            x(C(d), "sourceId", void 0);
            x(C(d), "targetId", void 0);
            x(C(d), "source", void 0);
            x(C(d), "target", void 0);
            x(C(d), "detachable", !0);
            x(C(d), "reattach", !1);
            x(C(d), "uuids", void 0);
            x(C(d), "cost", 1);
            x(C(d), "directed", void 0);
            x(C(d), "endpoints", [null, null]);
            x(C(d), "endpointStyles", void 0);
            x(C(d), "endpointSpec", void 0);
            x(C(d), "endpointsSpec", void 0);
            x(C(d), "endpointStyle", {});
            x(C(d), "endpointHoverStyle", {});
            x(C(d), "endpointHoverStyles", void 0);
            x(C(d), "suspendedEndpoint", void 0);
            x(C(d), "suspendedIndex", void 0);
            x(C(d), "suspendedElement", void 0);
            x(C(d), "suspendedElementId", void 0);
            x(C(d), "suspendedElementType", void 0);
            x(C(d), "_forceReattach", void 0);
            x(C(d), "_forceDetach", void 0);
            x(C(d), "proxies", []);
            x(C(d), "pending", !1);
            d.id = n.id;
            d.previousConnection = n.previousConnection;
            d.source = n.source;
            d.target = n.target;
            n.sourceEndpoint ? (d.source = n.sourceEndpoint.element, d.sourceId = n.sourceEndpoint.elementId) : d.sourceId = f.getId(d.source);
            n.targetEndpoint ? (d.target = n.targetEndpoint.element, d.targetId = n.targetEndpoint.elementId) : d.targetId = f.getId(d.target);
            d.scope = n.scope;
            var k = n.anchors ? n.anchors[0] : n.anchor,
            a = n.anchors ? n.anchors[1] : n.anchor;
            f.manage(d.source);
            f.manage(d.target);
            d.visible = !0;
            d.params = {
                cssClass: n.cssClass,
                hoverClass: n.hoverClass,
                "pointer-events": n["pointer-events"],
                overlays: n.overlays
            };
            d.lastPaintedAt = null;
            n.type && (n.endpoints = n.endpoints || d.instance._deriveEndpointAndAnchorSpec(n.type).endpoints);
            d.endpointSpec = n.endpoint;
            d.endpointsSpec = n.endpoints || [null, null];
            d.endpointStyle = n.endpointStyle;
            d.endpointHoverStyle = n.endpointHoverStyle;
            d.endpointStyles = n.endpointStyles || [null, null];
            d.endpointHoverStyles = n.endpointHoverStyles || [null, null];
            d.paintStyle = n.paintStyle;
            d.hoverPaintStyle = n.hoverPaintStyle;
            d.uuids = n.uuids;
            d.makeEndpoint(!0, d.source, d.sourceId, k, n.sourceEndpoint);
            d.makeEndpoint(!1, d.target, d.targetId, a, n.targetEndpoint);
            d.scope || (d.scope = d.endpoints[0].scope);
            null != n.deleteEndpointsOnEmpty && (d.endpoints[0].deleteOnEmpty = n.deleteEndpointsOnEmpty, d.endpoints[1].deleteOnEmpty = n.deleteEndpointsOnEmpty);
            f = d.instance.defaults.connectionsDetachable; ! 1 === n.detachable && (f = !1); ! 1 === d.endpoints[0].connectionsDetachable && (f = !1); ! 1 === d.endpoints[1].connectionsDetachable && (f = !1);
            d.endpointsSpec = n.endpoints || [null, null];
            d.endpointSpec = n.endpoint || null;
            d.appendToDefaultType({
                detachable: f,
                reattach: n.reattach || d.endpoints[0].reattachConnections || d.endpoints[1].reattachConnections || d.instance.defaults.reattachConnections,
                paintStyle: d.endpoints[0].connectorStyle || d.endpoints[1].connectorStyle || n.paintStyle || d.instance.defaults.paintStyle,
                hoverPaintStyle: d.endpoints[0].connectorHoverStyle || d.endpoints[1].connectorHoverStyle || n.hoverPaintStyle || d.instance.defaults.hoverPaintStyle
            });
            d.instance._suspendDrawing || (f = d.instance._suspendedAt || fa(), d.instance.paintEndpoint(d.endpoints[0], {
                timestamp: f
            }), d.instance.paintEndpoint(d.endpoints[1], {
                timestamp: f
            }));
            d.cost = n.cost || d.endpoints[0].connectionCost;
            d.directed = n.directed;
            null == n.directed && (d.directed = d.endpoints[0].connectionsDirected);
            f = A({},
            d.endpoints[1].parameters);
            A(f, d.endpoints[0].parameters);
            A(f, d.parameters);
            d.parameters = f;
            d.paintStyleInUse = d.getPaintStyle() || {};
            d.setConnector(d.endpoints[0].connector || d.endpoints[1].connector || n.connector || d.instance.defaults.connector, !0);
            f = null != n.data && V(n.data) ? n.data: {};
            d.setData(f);
            f = ["default", d.endpoints[0].edgeType, d.endpoints[1].edgeType, n.type].join(" ");
            /[^\s]/.test(f) && d.addType(f, n.data);
            return d
        }
        xa(p, l);
        var q = ya(p);
        ua(p, [{
            key: "getIdPrefix",
            value: function() {
                return "_jsPlumb_c"
            }
        },
        {
            key: "getDefaultOverlayKey",
            value: function() {
                return "connectionOverlays"
            }
        },
        {
            key: "getXY",
            value: function() {
                return {
                    x: this.connector.x,
                    y: this.connector.y
                }
            }
        },
        {
            key: "makeEndpoint",
            value: function(f, n, d, k, a) {
                d || this.instance.getId(n);
                return Tf(this, a, f ? 0 : 1, k, n)
            }
        },
        {
            key: "getTypeDescriptor",
            value: function() {
                return p.type
            }
        },
        {
            key: "isDetachable",
            value: function(f) {
                return ! 1 === this.detachable ? !1 : null != f ? !0 === f.connectionsDetachable: !0 === this.detachable
            }
        },
        {
            key: "setDetachable",
            value: function(f) {
                this.detachable = !0 === f
            }
        },
        {
            key: "isReattach",
            value: function() {
                return ! 0 === this.reattach || !0 === this.endpoints[0].reattachConnections || !0 === this.endpoints[1].reattachConnections
            }
        },
        {
            key: "setReattach",
            value: function(f) {
                this.reattach = !0 === f
            }
        },
        {
            key: "applyType",
            value: function(f, n) {
                if (null != f.connector) {
                    var d = this.getCachedTypeItem("connector", n.connector);
                    null == d && (d = this.prepareConnector(f.connector, n.connector), this.cacheTypeItem("connector", d, n.connector));
                    this.setPreparedConnector(d)
                }
                kb(Wa(p.prototype), "applyType", this).call(this, f, n);
                null != f.detachable && this.setDetachable(f.detachable);
                null != f.reattach && this.setReattach(f.reattach);
                f.scope && (this.scope = f.scope);
                d = null;
                f.anchor ? (d = this.getCachedTypeItem("anchors", n.anchor), null == d && (d = [Tc(f.anchor), Tc(f.anchor)], this.cacheTypeItem("anchors", d, n.anchor))) : f.anchors && (d = this.getCachedTypeItem("anchors", n.anchors), null == d && (d = [Tc(f.anchors[0]), Tc(f.anchors[1])], this.cacheTypeItem("anchors", d, n.anchors)));
                null != d && (this.instance.router.setConnectionAnchors(this, d), this.instance.router.isDynamicAnchor(this.endpoints[1]) && this.instance.repaint(this.endpoints[1].element));
                this.instance.applyConnectorType(this.connector, f)
            }
        },
        {
            key: "addClass",
            value: function(f, n) {
                kb(Wa(p.prototype), "addClass", this).call(this, f);
                n && (this.endpoints[0].addClass(f), this.endpoints[1].addClass(f), this.suspendedEndpoint && this.suspendedEndpoint.addClass(f));
                this.connector && this.instance.addConnectorClass(this.connector, f)
            }
        },
        {
            key: "removeClass",
            value: function(f, n) {
                kb(Wa(p.prototype), "removeClass", this).call(this, f);
                n && (this.endpoints[0].removeClass(f), this.endpoints[1].removeClass(f), this.suspendedEndpoint && this.suspendedEndpoint.removeClass(f));
                this.connector && this.instance.removeConnectorClass(this.connector, f)
            }
        },
        {
            key: "setVisible",
            value: function(f) {
                kb(Wa(p.prototype), "setVisible", this).call(this, f);
                this.connector && this.instance.setConnectorVisible(this.connector, f);
                this.instance.paintConnection(this)
            }
        },
        {
            key: "destroy",
            value: function() {
                kb(Wa(p.prototype), "destroy", this).call(this);
                this.target = this.source = this.endpointStyles = this.endpoints = null;
                this.instance.destroyConnector(this);
                this.connector = null;
                this.deleted = !0
            }
        },
        {
            key: "getUuids",
            value: function() {
                return [this.endpoints[0].getUuid(), this.endpoints[1].getUuid()]
            }
        },
        {
            key: "prepareConnector",
            value: function(f, n) {
                var d = {
                    cssClass: this.params.cssClass,
                    hoverClass: this.params.hoverClass,
                    "pointer-events": this.params["pointer-events"]
                };
                f = J(f) ? this.instance.makeConnector(this, f, d) : this.instance.makeConnector(this, f.type, R(f.options, d));
                null != n && (f.typeId = n);
                return f
            }
        },
        {
            key: "setPreparedConnector",
            value: function(f, n, d, k) {
                if (this.connector !== f) {
                    d = "";
                    if (null != this.connector) {
                        var a = this.connector;
                        d = this.instance.getConnectorClass(this.connector);
                        this.instance.destroyConnector(this)
                    }
                    this.connector = f;
                    k && this.cacheTypeItem("connector", f, k);
                    this.addClass(d);
                    if (null != a) {
                        f = this.getOverlays();
                        for (var e in f) this.instance.reattachOverlay(f[e], this)
                    }
                    n || this.instance.paintConnection(this)
                }
            }
        },
        {
            key: "setConnector",
            value: function(f, n, d, k) {
                f = this.prepareConnector(f, k);
                this.setPreparedConnector(f, n, d, k)
            }
        },
        {
            key: "replaceEndpoint",
            value: function(f, n) {
                var d = this.endpoints[f],
                k = d.elementId,
                a = this.instance.getEndpoints(d.element),
                e = a.indexOf(d);
                n = Tf(this, null, f, null, d.element, k, n);
                this.endpoints[f] = n;
                a.splice(e, 1, n);
                d.detachFromConnection(this);
                this.instance.deleteEndpoint(d);
                this.instance.fire("endpoint:replaced", {
                    previous: d,
                    current: n
                })
            }
        }]);
        return p
    } (Hh);
    x(mc, "type", "connection");
    var zk = "connectorStyle connectorHoverStyle connectorOverlays connector connectionType connectorClass connectorHoverClass".split(" "),
    Ud = function(l) {
        function p(f, n) {
            ja(this, p);
            var d = q.call(this, f, n);
            d.instance = f;
            x(C(d), "connections", []);
            x(C(d), "endpoint", void 0);
            x(C(d), "element", void 0);
            x(C(d), "elementId", void 0);
            x(C(d), "dragAllowedWhenFull", !0);
            x(C(d), "timestamp", void 0);
            x(C(d), "portId", void 0);
            x(C(d), "maxConnections", void 0);
            x(C(d), "proxiedBy", void 0);
            x(C(d), "connectorClass", void 0);
            x(C(d), "connectorHoverClass", void 0);
            x(C(d), "finalEndpoint", void 0);
            x(C(d), "enabled", !0);
            x(C(d), "isSource", void 0);
            x(C(d), "isTarget", void 0);
            x(C(d), "isTemporarySource", void 0);
            x(C(d), "connectionCost", 1);
            x(C(d), "connectionsDirected", void 0);
            x(C(d), "connectionsDetachable", void 0);
            x(C(d), "reattachConnections", void 0);
            x(C(d), "currentAnchorClass", void 0);
            x(C(d), "referenceEndpoint", void 0);
            x(C(d), "edgeType", void 0);
            x(C(d), "connector", void 0);
            x(C(d), "connectorOverlays", void 0);
            x(C(d), "connectorStyle", void 0);
            x(C(d), "connectorHoverStyle", void 0);
            x(C(d), "deleteOnEmpty", void 0);
            x(C(d), "uuid", void 0);
            x(C(d), "scope", void 0);
            x(C(d), "_anchor", void 0);
            x(C(d), "defaultLabelLocation", [.5, .5]);
            d.appendToDefaultType({
                edgeType: n.edgeType,
                maxConnections: null == n.maxConnections ? d.instance.defaults.maxConnections: n.maxConnections,
                paintStyle: n.paintStyle || d.instance.defaults.endpointStyle,
                hoverPaintStyle: n.hoverPaintStyle || d.instance.defaults.endpointHoverStyle,
                connectorStyle: n.connectorStyle,
                connectorHoverStyle: n.connectorHoverStyle,
                connectorClass: n.connectorClass,
                connectorHoverClass: n.connectorHoverClass,
                connectorOverlays: n.connectorOverlays,
                connector: n.connector
            });
            d.enabled = !1 !== n.enabled;
            d.visible = !0;
            d.element = n.element;
            d.uuid = n.uuid;
            d.portId = n.portId;
            d.elementId = n.elementId;
            d.connectionCost = null == n.connectionCost ? 1 : n.connectionCost;
            d.connectionsDirected = n.connectionsDirected;
            d.currentAnchorClass = "";
            d.events = {};
            d.connectorOverlays = n.connectorOverlays;
            d.connectorStyle = n.connectorStyle;
            d.connectorHoverStyle = n.connectorHoverStyle;
            d.connector = n.connector;
            d.edgeType = n.edgeType;
            d.connectorClass = n.connectorClass;
            d.connectorHoverClass = n.connectorHoverClass;
            d.deleteOnEmpty = !0 === n.deleteOnEmpty;
            d.isSource = n.source || !1;
            d.isTemporarySource = n.isTemporarySource || !1;
            d.isTarget = n.target || !1;
            d.connections = n.connections || [];
            d.scope = n.scope || f.defaultScope;
            d.timestamp = null;
            d.reattachConnections = n.reattachConnections || f.defaults.reattachConnections;
            d.connectionsDetachable = f.defaults.connectionsDetachable; ! 1 === n.connectionsDetachable && (d.connectionsDetachable = !1);
            d.dragAllowedWhenFull = !1 !== n.dragAllowedWhenFull;
            n.onMaxConnections && d.bind("maxConnections", n.onMaxConnections);
            d.setEndpoint(n.endpoint || n.existingEndpoint || f.defaults.endpoint);
            null != n.preparedAnchor ? d.setPreparedAnchor(n.preparedAnchor) : d.setAnchor(n.anchor ? n.anchor: n.anchors ? n.anchors: f.defaults.anchor || ec.Top);
            f = ["default", n.type || ""].join(" ");
            d.addType(f, n.data);
            return d
        }
        xa(p, l);
        var q = ya(p);
        ua(p, [{
            key: "getIdPrefix",
            value: function() {
                return "_jsplumb_e"
            }
        },
        {
            key: "getTypeDescriptor",
            value: function() {
                return "endpoint"
            }
        },
        {
            key: "getXY",
            value: function() {
                return {
                    x: this.endpoint.x,
                    y: this.endpoint.y
                }
            }
        },
        {
            key: "getDefaultOverlayKey",
            value: function() {
                return "endpointOverlays"
            }
        },
        {
            key: "_updateAnchorClass",
            value: function() {
                var f = this._anchor && this._anchor.cssClass;
                if (null != f && 0 < f.length) {
                    var n = this.instance.endpointAnchorClassPrefix + "-" + this.currentAnchorClass;
                    this.currentAnchorClass = f;
                    f = this.instance.endpointAnchorClassPrefix + (this.currentAnchorClass ? "-" + this.currentAnchorClass: "");
                    n !== f && (this.removeClass(n), this.addClass(f), this.instance.removeClass(this.element, n), this.instance.addClass(this.element, f))
                }
            }
        },
        {
            key: "setPreparedAnchor",
            value: function(f) {
                this.instance.router.setAnchor(this, f);
                this._updateAnchorClass();
                return this
            }
        },
        {
            key: "_anchorLocationChanged",
            value: function(f) {
                this.fire("anchor:changed", {
                    endpoint: this,
                    anchor: f
                });
                this._updateAnchorClass()
            }
        },
        {
            key: "setAnchor",
            value: function(f) {
                f = this.instance.router.prepareAnchor(this, f);
                this.setPreparedAnchor(f);
                return this
            }
        },
        {
            key: "addConnection",
            value: function(f) {
                var n = this.isFull(),
                d = 0 === this.connections.length;
                this.connections.push(f);
                d && this.addClass(this.instance.endpointConnectedClass);
                this.isFull() ? n || this.addClass(this.instance.endpointFullClass) : n && this.removeClass(this.instance.endpointFullClass)
            }
        },
        {
            key: "detachFromConnection",
            value: function(f, n, d) {
                n = null == n ? this.connections.indexOf(f) : n;
                0 <= n && (this.connections.splice(n, 1), this.instance.refreshEndpoint(this)); ! d && this.deleteOnEmpty && 0 === this.connections.length && this.instance.deleteEndpoint(this)
            }
        },
        {
            key: "deleteEveryConnection",
            value: function(f) {
                for (var n = this.connections.length,
                d = 0; d < n; d++) this.instance.deleteConnection(this.connections[0], f)
            }
        },
        {
            key: "detachFrom",
            value: function(f) {
                for (var n = [], d = 0; d < this.connections.length; d++) this.connections[d].endpoints[1] !== f && this.connections[d].endpoints[0] !== f || n.push(this.connections[d]);
                f = 0;
                for (d = n.length; f < d; f++) this.instance.deleteConnection(n[0]);
                return this
            }
        },
        {
            key: "setVisible",
            value: function(f, n, d) {
                kb(Wa(p.prototype), "setVisible", this).call(this, f);
                this.endpoint.setVisible(f);
                f ? this.showOverlays() : this.hideOverlays();
                if (!n) for (n = 0; n < this.connections.length; n++) if (this.connections[n].setVisible(f), !d) {
                    var k = this === this.connections[n].endpoints[0] ? 1 : 0;
                    1 === this.connections[n].endpoints[k].connections.length && this.connections[n].endpoints[k].setVisible(f, !0, !0)
                }
            }
        },
        {
            key: "applyType",
            value: function(f, n) {
                kb(Wa(p.prototype), "applyType", this).call(this, f, n);
                this.setPaintStyle(f.endpointStyle || f.paintStyle);
                this.setHoverPaintStyle(f.endpointHoverStyle || f.hoverPaintStyle);
                this.connectorStyle = f.connectorStyle;
                this.connectorHoverStyle = f.connectorHoverStyle;
                this.connector = f.connector;
                this.connectorOverlays = f.connectorOverlays;
                this.edgeType = f.edgeType;
                null != f.maxConnections && (this.maxConnections = f.maxConnections);
                f.scope && (this.scope = f.scope);
                A(f, zk);
                this.instance.applyEndpointType(this, f)
            }
        },
        {
            key: "destroy",
            value: function() {
                kb(Wa(p.prototype), "destroy", this).call(this);
                null != this.endpoint && this.instance.destroyEndpoint(this)
            }
        },
        {
            key: "isFull",
            value: function() {
                return 0 === this.maxConnections ? !0 : !(this.isFloating() || 0 > this.maxConnections || this.connections.length < this.maxConnections)
            }
        },
        {
            key: "isFloating",
            value: function() {
                return this.instance.router.isFloating(this)
            }
        },
        {
            key: "isConnectedTo",
            value: function(f) {
                var n = !1;
                if (f) for (var d = 0; d < this.connections.length; d++) if (this.connections[d].endpoints[1] === f || this.connections[d].endpoints[0] === f) {
                    n = !0;
                    break
                }
                return n
            }
        },
        {
            key: "setDragAllowedWhenFull",
            value: function(f) {
                this.dragAllowedWhenFull = f
            }
        },
        {
            key: "getUuid",
            value: function() {
                return this.uuid
            }
        },
        {
            key: "connectorSelector",
            value: function() {
                return this.connections[0]
            }
        },
        {
            key: "prepareEndpoint",
            value: function(f, n) {
                var d = {
                    cssClass: this.cssClass,
                    endpoint: this
                };
                zf(f, Ac) ? f = Zb.clone(f) : J(f) ? f = Zb.get(this, f, d) : (A(d, f.options || {}), f = Zb.get(this, f.type, d));
                f.typeId = n;
                return f
            }
        },
        {
            key: "setEndpoint",
            value: function(f) {
                f = this.prepareEndpoint(f);
                this.setPreparedEndpoint(f)
            }
        },
        {
            key: "setPreparedEndpoint",
            value: function(f) {
                null != this.endpoint && this.instance.destroyEndpoint(this);
                this.endpoint = f
            }
        },
        {
            key: "addClass",
            value: function(f, n) {
                kb(Wa(p.prototype), "addClass", this).call(this, f, n);
                null != this.endpoint && this.endpoint.addClass(f)
            }
        },
        {
            key: "removeClass",
            value: function(f, n) {
                kb(Wa(p.prototype), "removeClass", this).call(this, f, n);
                null != this.endpoint && this.endpoint.removeClass(f)
            }
        }]);
        return p
    } (Hh),
    cf = function f(p, q) {
        ja(this, f);
        this.instance = p;
        this.el = q;
        x(this, "group", void 0)
    },
    Ak = function(p) {
        function q(n, d, k) {
            ja(this, q);
            var a = f.call(this, n, d);
            a.instance = n;
            x(C(a), "children", []);
            x(C(a), "collapsed", !1);
            x(C(a), "droppable", void 0);
            x(C(a), "enabled", void 0);
            x(C(a), "orphan", void 0);
            x(C(a), "constrain", void 0);
            x(C(a), "proxied", void 0);
            x(C(a), "ghost", void 0);
            x(C(a), "revert", void 0);
            x(C(a), "prune", void 0);
            x(C(a), "dropOverride", void 0);
            x(C(a), "anchor", void 0);
            x(C(a), "endpoint", void 0);
            x(C(a), "connections", {
                source: [],
                target: [],
                internal: []
            });
            x(C(a), "manager", void 0);
            x(C(a), "id", void 0);
            x(C(a), "elId", void 0);
            var e = a.el;
            e._isJsPlumbGroup = !0;
            e._jsPlumbGroup = C(a);
            a.elId = n.getId(d);
            a.orphan = !0 === k.orphan;
            a.revert = !0 === a.orphan ? !1 : !1 !== k.revert;
            a.droppable = !1 !== k.droppable;
            a.ghost = !0 === k.ghost;
            a.enabled = !1 !== k.enabled;
            a.prune = !0 !== a.orphan && !0 === k.prune;
            a.constrain = a.ghost || !0 === k.constrain;
            a.proxied = !1 !== k.proxied;
            a.id = k.id || fa();
            a.dropOverride = !0 === k.dropOverride;
            a.anchor = k.anchor;
            a.endpoint = k.endpoint;
            a.anchor = k.anchor;
            n.setAttribute(d, "data-jtk-group", "");
            return a
        }
        xa(q, p);
        var f = ya(q);
        ua(q, [{
            key: "overrideDrop",
            value: function(n, d) {
                return this.dropOverride && (this.revert || this.prune || this.orphan)
            }
        },
        {
            key: "getAnchor",
            value: function(n, d) {
                return this.anchor || "Continuous"
            }
        },
        {
            key: "getEndpoint",
            value: function(n, d) {
                return this.endpoint || {
                    type: Bc.type,
                    options: {
                        radius: 10
                    }
                }
            }
        },
        {
            key: "add",
            value: function(n, d) {
                var k = this.instance.getGroupContentArea(this);
                if (null != n._jsPlumbParentGroup) {
                    if (n._jsPlumbParentGroup === this) return;
                    n._jsPlumbParentGroup.remove(n, !0, d, !1)
                }
                n._jsPlumbParentGroup = this;
                this.children.push(new cf(this.instance, n));
                this.instance._appendElement(n, k);
                this.manager._updateConnectionsForGroup(this)
            }
        },
        {
            key: "resolveNode",
            value: function(n) {
                return null == n ? null: ne(this.children,
                function(d) {
                    return d.el === n
                })
            }
        },
        {
            key: "remove",
            value: function(n, d, k, a, e) {
                n = this.resolveNode(n);
                null != n && this._doRemove(n, d, k, a, e)
            }
        },
        {
            key: "_doRemove",
            value: function(n, d, k, a, e) {
                var c = n.el;
                delete c._jsPlumbParentGroup;
                ma(this.children,
                function(h) {
                    return h === n
                });
                if (d) try {
                    this.instance.getGroupContentArea(this).removeChild(c)
                } catch(h) {
                    pa("Could not remove element from Group " + h)
                }
                k || (d = {
                    group: this,
                    el: c
                },
                e && (d.targetGroup = e), this.instance.fire("group:member:removed", d));
                a || this.manager._updateConnectionsForGroup(this)
            }
        },
        {
            key: "removeAll",
            value: function(n, d) {
                for (var k = 0,
                a = this.children.length; k < a; k++) {
                    var e = this.children[0];
                    this._doRemove(e, n, d, !0);
                    this.instance.unmanage(e.el, !0)
                }
                this.children.length = 0;
                this.manager._updateConnectionsForGroup(this)
            }
        },
        {
            key: "orphanAll",
            value: function() {
                for (var n = {},
                d = 0; d < this.children.length; d++) {
                    var k = this.manager.orphan(this.children[d].el, !1);
                    n[k.id] = k.pos
                }
                this.children.length = 0;
                return n
            }
        },
        {
            key: "addGroup",
            value: function(n) {
                if (this.instance.allowNestedGroups && n !== this) {
                    if (this.instance.groupManager.isAncestor(this, n)) return ! 1;
                    null != n.group && n.group.removeGroup(n);
                    var d = this.instance.getId(n.el);
                    this.instance.getManagedElements()[d].group = this.elId;
                    d = this.instance.getOffsetRelativeToRoot(n.el);
                    var k = this.collapsed ? this.instance.getOffsetRelativeToRoot(this.el) : this.instance.getOffsetRelativeToRoot(this.instance.getGroupContentArea(this));
                    n.el._jsPlumbParentGroup = this;
                    this.children.push(n);
                    this.instance._appendElement(n.el, this.instance.getGroupContentArea(this));
                    n.group = this;
                    this.instance.setPosition(n.el, {
                        x: d.x - k.x,
                        y: d.y - k.y
                    });
                    this.instance.fire("group:nested:added", {
                        parent: this,
                        child: n
                    });
                    return ! 0
                }
                return ! 1
            }
        },
        {
            key: "removeGroup",
            value: function(n) {
                if (n.group === this) {
                    var d = n.el,
                    k = this.instance.getGroupContentArea(this);
                    k === d.parentNode && k.removeChild(n.el);
                    k = this.instance.getId(n.el); (k = this.instance.getManagedElements()[k]) && delete k.group;
                    this.children = this.children.filter(function(a) {
                        return a.id !== n.id
                    });
                    delete n.group;
                    delete d._jsPlumbParentGroup;
                    this.instance.fire("group:nested:removed", {
                        parent: this,
                        child: n
                    })
                }
            }
        },
        {
            key: "getGroups",
            value: function() {
                return this.children.filter(function(n) {
                    return n.constructor === q
                })
            }
        },
        {
            key: "getNodes",
            value: function() {
                return this.children.filter(function(n) {
                    return n.constructor === cf
                })
            }
        },
        {
            key: "collapseParent",
            get: function() {
                var n = null;
                if (null == this.group) return null;
                for (var d = this.group; null != d;) d.collapsed && (n = d),
                d = d.group;
                return n
            }
        }]);
        return q
    } (cf),
    Bk = function() {
        function p(q) {
            var f = this;
            ja(this, p);
            this.instance = q;
            x(this, "groupMap", {});
            x(this, "_connectionSourceMap", {});
            x(this, "_connectionTargetMap", {});
            q.bind("internal.connection",
            function(n) {
                var d = f.getGroupFor(n.source),
                k = f.getGroupFor(n.target);
                null != d && null != k && d === k ? (f._connectionSourceMap[n.connection.id] = d, f._connectionTargetMap[n.connection.id] = d, Rc(d.connections.internal, n.connection)) : (null != d && (n.target._jsPlumbGroup === d ? Rc(d.connections.internal, n.connection) : Rc(d.connections.source, n.connection), f._connectionSourceMap[n.connection.id] = d), null != k && (n.source._jsPlumbGroup === k ? Rc(k.connections.internal, n.connection) : Rc(k.connections.target, n.connection), f._connectionTargetMap[n.connection.id] = k))
            });
            q.bind("internal.connection:detached",
            function(n) {
                f._cleanupDetachedConnection(n.connection)
            });
            q.bind("connection:move",
            function(n) {
                var d = f.getGroupFor(n.originalEndpoint.element),
                k = f.getGroupFor(n.connection.endpoints[n.index].element),
                a = 0 === n.index ? f._connectionSourceMap: f._connectionTargetMap,
                e = 0 === n.index ? f._connectionTargetMap: f._connectionSourceMap;
                null != k ? (a[n.connection.id] = k, n.connection.source === n.connection.target && (e[n.connection.id] = k)) : (delete a[n.connection.id], n.connection.source === n.connection.target && delete e[n.connection.id]);
                null != d && f._updateConnectionsForGroup(d);
                null != k && f._updateConnectionsForGroup(k)
            })
        }
        ua(p, [{
            key: "_cleanupDetachedConnection",
            value: function(q) {
                q.proxies.length = 0;
                var f = this._connectionSourceMap[q.id];
                if (null != f) {
                    var n = function(d) {
                        return d.id === q.id
                    };
                    ma(f.connections.source, n);
                    ma(f.connections.target, n);
                    ma(f.connections.internal, n);
                    delete this._connectionSourceMap[q.id]
                }
                f = this._connectionTargetMap[q.id];
                null != f && (n = function(d) {
                    return d.id === q.id
                },
                ma(f.connections.source, n), ma(f.connections.target, n), ma(f.connections.internal, n), delete this._connectionTargetMap[q.id])
            }
        },
        {
            key: "addGroup",
            value: function(q) {
                var f = q.el;
                if (null != this.groupMap[q.id]) throw Error("cannot create Group [" + q.id + "]; a Group with that ID exists");
                if (null != f._isJsPlumbGroup) throw Error("cannot create Group [" + q.id + "]; the given element is already a Group");
                f = new Ak(this.instance, q.el, q);
                this.groupMap[f.id] = f;
                q.collapsed && this.collapseGroup(f);
                this.instance.manage(f.el);
                this.instance.addClass(f.el, "jtk-group-expanded");
                f.manager = this;
                this._updateConnectionsForGroup(f);
                this.instance.fire("group:added", {
                    group: f
                });
                return f
            }
        },
        {
            key: "getGroup",
            value: function(q) {
                var f = q;
                if (J(q) && (f = this.groupMap[q], null == f)) throw Error("No such group [" + q + "]");
                return f
            }
        },
        {
            key: "getGroupFor",
            value: function(q) {
                for (var f = this.instance.getContainer(), n = !1, d = null; ! n;) null == q || q === f ? n = !0 : q._jsPlumbParentGroup ? (d = q._jsPlumbParentGroup, n = !0) : q = q.parentNode;
                return d
            }
        },
        {
            key: "getGroups",
            value: function() {
                var q = [],
                f;
                for (f in this.groupMap) q.push(this.groupMap[f]);
                return q
            }
        },
        {
            key: "removeGroup",
            value: function(q, f, n, d) {
                var k = this,
                a = this.getGroup(q);
                this.expandGroup(a, !0);
                q = {};
                P(a.children,
                function(e) { (e = k.instance.getManagedElements()[k.instance.getId(e.el)]) && delete e.group
                });
                f ? (P(a.getGroups(),
                function(e) {
                    return k.removeGroup(e, f, n)
                }), a.removeAll(n, d)) : (a.group && P(a.children,
                function(e) {
                    return a.group.add(e.el)
                }), q = a.orphanAll());
                a.group && a.group.removeGroup(a);
                this.instance.unmanage(a.el, !0);
                delete this.groupMap[a.id];
                this.instance.fire("group:removed", {
                    group: a
                });
                return q
            }
        },
        {
            key: "removeAllGroups",
            value: function(q, f, n) {
                for (var d in this.groupMap) this.removeGroup(this.groupMap[d], q, f, n)
            }
        },
        {
            key: "forEach",
            value: function(q) {
                for (var f in this.groupMap) q(this.groupMap[f])
            }
        },
        {
            key: "orphan",
            value: function(q, f) {
                if (q._jsPlumbParentGroup) {
                    var n = q._jsPlumbParentGroup,
                    d = this.instance.getOffset(q),
                    k = this.instance.getId(q),
                    a = this.instance.getOffset(q);
                    q.parentNode.removeChild(q); ! 0 !== f && n.group ? (a.x += d.x, a.y += d.y, this.instance.getGroupContentArea(n.group).appendChild(q)) : this.instance._appendElement(q, this.instance.getContainer());
                    this.instance.setPosition(q, a);
                    delete q._jsPlumbParentGroup;
                    return {
                        id: k,
                        pos: a
                    }
                }
            }
        },
        {
            key: "_updateConnectionsForGroup",
            value: function(q) {
                var f = this;
                q.connections.source.length = 0;
                q.connections.target.length = 0;
                q.connections.internal.length = 0;
                var n = q.children.slice().map(function(b) {
                    return b.el
                }),
                d = [];
                P(n,
                function(b) {
                    Array.prototype.push.apply(d, f.instance.getSelector(b, Ba))
                });
                Array.prototype.push.apply(n, d);
                if (0 < n.length) {
                    var k = this.instance.getConnections({
                        source: n,
                        scope: "*"
                    },
                    !0);
                    n = this.instance.getConnections({
                        target: n,
                        scope: "*"
                    },
                    !0);
                    var a = {},
                    e, c, h = function(b) {
                        for (var g = 0; g < b.length; g++) a[b[g].id] || (a[b[g].id] = !0, e = f.getGroupFor(b[g].source), c = f.getGroupFor(b[g].target), b[g].source === q.el && c === q || b[g].target === q.el && e === q ? q.connections.internal.push(b[g]) : e === q ? (c !== q ? q.connections.source.push(b[g]) : q.connections.internal.push(b[g]), f._connectionSourceMap[b[g].id] = q) : c === q && (q.connections.target.push(b[g]), f._connectionTargetMap[b[g].id] = q))
                    };
                    h(k);
                    h(n)
                }
            }
        },
        {
            key: "_collapseConnection",
            value: function(q, f, n) {
                var d = q.endpoints[0 === f ? 1 : 0].element;
                if (d._jsPlumbParentGroup && !d._jsPlumbParentGroup.proxied && d._jsPlumbParentGroup.collapsed) return ! 1;
                d = q.endpoints[0].element._jsPlumbParentGroup;
                d = null != d ? d.collapseParent || d: null;
                var k = q.endpoints[1].element._jsPlumbParentGroup;
                k = null != k ? k.collapseParent || k: null;
                return null == d || null == k || d.id !== k.id ? (d = n.el, this.instance.getId(d), this.instance.proxyConnection(q, f, d,
                function(a, e) {
                    return n.getEndpoint(a, e)
                },
                function(a, e) {
                    return n.getAnchor(a, e)
                }), !0) : !1
            }
        },
        {
            key: "_expandConnection",
            value: function(q, f, n) {
                this.instance.unproxyConnection(q, f)
            }
        },
        {
            key: "isElementDescendant",
            value: function(q, f) {
                for (var n = this.instance.getContainer();;) {
                    if (null == q || q === n) return ! 1;
                    if (q === f) return ! 0;
                    q = q.parentNode
                }
            }
        },
        {
            key: "collapseGroup",
            value: function(q) {
                var f = this,
                n = this.getGroup(q);
                if (null != n && !n.collapsed) if (q = n.el, null == n.collapseParent) {
                    this.instance.setGroupVisible(n, !1);
                    n.collapsed = !0;
                    this.instance.removeClass(q, "jtk-group-expanded");
                    this.instance.addClass(q, "jtk-group-collapsed");
                    if (n.proxied) {
                        var d = new Set,
                        k = function(a, e) {
                            for (var c = 0; c < a.length; c++) {
                                var h = a[c]; ! 0 === f._collapseConnection(h, e, n) && d.add(h.id)
                            }
                        };
                        k(n.connections.source, 0);
                        k(n.connections.target, 1);
                        P(n.getGroups(),
                        function(a) {
                            f.cascadeCollapse(n, a, d)
                        })
                    }
                    this.instance.revalidate(q);
                    this.repaintGroup(n);
                    this.instance.fire("group:collapse", {
                        group: n
                    })
                } else n.collapsed = !0,
                this.instance.removeClass(q, "jtk-group-expanded"),
                this.instance.addClass(q, "jtk-group-collapsed")
            }
        },
        {
            key: "cascadeCollapse",
            value: function(q, f, n) {
                var d = this;
                if (q.proxied) {
                    var k = function(a, e) {
                        for (var c = 0; c < a.length; c++) {
                            var h = a[c];
                            n.has(h.id) || !0 === d._collapseConnection(h, e, q) && n.add(h.id)
                        }
                    };
                    k(f.connections.source, 0);
                    k(f.connections.target, 1)
                }
                P(f.getGroups(),
                function(a) {
                    d.cascadeCollapse(q, a, n)
                })
            }
        },
        {
            key: "expandGroup",
            value: function(q, f) {
                var n = this,
                d = this.getGroup(q);
                if (null != d) if (q = d.el, null == d.collapseParent) {
                    this.instance.setGroupVisible(d, !0);
                    d.collapsed = !1;
                    this.instance.addClass(q, "jtk-group-expanded");
                    this.instance.removeClass(q, "jtk-group-collapsed");
                    if (d.proxied) {
                        var k = function(a, e) {
                            for (var c = 0; c < a.length; c++) n._expandConnection(a[c], e, d)
                        };
                        k(d.connections.source, 0);
                        k(d.connections.target, 1);
                        P(d.getGroups(),
                        function h(e, c) {
                            c || e.collapsed ? (c = function(b, g) {
                                for (var m = 0; m < b.length; m++) n._collapseConnection(b[m], g, e.collapseParent || e)
                            },
                            c(e.connections.source, 0), c(e.connections.target, 1), P(e.connections.internal,
                            function(b) {
                                return b.setVisible(!1)
                            }), P(e.getGroups(),
                            function(b) {
                                return h(b, !0)
                            })) : n.expandGroup(e, !0)
                        })
                    }
                    this.instance.revalidate(q);
                    this.repaintGroup(d);
                    f || this.instance.fire("group:expand", {
                        group: d
                    })
                } else d.collapsed = !1,
                this.instance.addClass(q, "jtk-group-expanded"),
                this.instance.removeClass(q, "jtk-group-collapsed")
            }
        },
        {
            key: "toggleGroup",
            value: function(q) {
                q = this.getGroup(q);
                null != q && (q.collapsed ? this.expandGroup(q) : this.collapseGroup(q))
            }
        },
        {
            key: "repaintGroup",
            value: function(q) {
                q = this.getGroup(q).children;
                for (var f = 0; f < q.length; f++) this.instance.revalidate(q[f].el)
            }
        },
        {
            key: "addToGroup",
            value: function(q, f) {
                var n = this,
                d = this.getGroup(q);
                if (d) {
                    for (var k = d.el,
                    a = arguments.length,
                    e = Array(2 < a ? a - 2 : 0), c = 2; c < a; c++) e[c - 2] = arguments[c];
                    P(e,
                    function(h) {
                        var b = null != h._isJsPlumbGroup,
                        g = h._jsPlumbGroup,
                        m = h._jsPlumbParentGroup;
                        if (m !== d) {
                            var r = n.instance.manage(h),
                            t = n.instance.getOffset(h),
                            u = d.collapsed ? n.instance.getOffsetRelativeToRoot(k) : n.instance.getOffset(n.instance.getGroupContentArea(d));
                            r.group = d.elId;
                            null != m && (m.remove(h, !1, f, !1, d), n._updateConnectionsForGroup(m));
                            b ? d.addGroup(g) : d.add(h, f);
                            b = function(v, w) {
                                var z = 0 === w ? 1 : 0;
                                v.each(function(y) {
                                    y.setVisible(!1);
                                    y.endpoints[z].element._jsPlumbGroup === d ? (y.endpoints[z].setVisible(!1), n._expandConnection(y, z, d)) : (y.endpoints[w].setVisible(!1), n._collapseConnection(y, w, d))
                                })
                            };
                            d.collapsed && (b(n.instance.select({
                                source: h
                            }), 0), b(n.instance.select({
                                target: h
                            }), 1));
                            n.instance.getId(h);
                            t = {
                                x: t.x - u.x,
                                y: t.y - u.y
                            };
                            n.instance.setPosition(h, t);
                            n._updateConnectionsForGroup(d);
                            n.instance.revalidate(h);
                            f || (h = {
                                group: d,
                                el: h,
                                pos: t
                            },
                            m && (h.sourceGroup = m), n.instance.fire("group:member:added", h))
                        }
                    })
                }
            }
        },
        {
            key: "removeFromGroup",
            value: function(q, f) {
                var n = this,
                d = this.getGroup(q);
                if (d) {
                    for (var k = arguments.length,
                    a = Array(2 < k ? k - 2 : 0), e = 2; e < k; e++) a[e - 2] = arguments[e];
                    P(a,
                    function(c) {
                        if (d.collapsed) {
                            var h = function(b, g) {
                                for (var m = 0; m < b.length; m++) {
                                    var r = b[m];
                                    if (r.proxies) for (var t = 0; t < r.proxies.length; t++) if (null != r.proxies[t]) {
                                        var u = r.proxies[t].originalEp.element; (u === c || n.isElementDescendant(u, c)) && n._expandConnection(r, g, d)
                                    }
                                }
                            };
                            h(d.connections.source.slice(), 0);
                            h(d.connections.target.slice(), 1)
                        }
                        d.remove(c, null, f); (h = n.instance.getManagedElements()[n.instance.getId(c)]) && delete h.group
                    })
                }
            }
        },
        {
            key: "getAncestors",
            value: function(q) {
                var f = [];
                for (q = q.group; null != q;) f.push(q),
                q = q.group;
                return f
            }
        },
        {
            key: "isAncestor",
            value: function(q, f) {
                return null == q || null == f ? !1 : -1 !== this.getAncestors(q).indexOf(f)
            }
        },
        {
            key: "getDescendants",
            value: function(q) {
                var f = []; (function k(d) {
                    d = d.getGroups();
                    f.push.apply(f, Ad(d));
                    P(d, k)
                })(q);
                return f
            }
        },
        {
            key: "isDescendant",
            value: function(q, f) {
                return null == q || null == f ? !1 : -1 !== this.getDescendants(f).indexOf(q)
            }
        },
        {
            key: "reset",
            value: function() {
                this._connectionSourceMap = {};
                this._connectionTargetMap = {};
                this.groupMap = {}
            }
        }]);
        return p
    } (),
    Mh = function() {
        function p(q, f) {
            ja(this, p);
            this.instance = q;
            this.entries = f
        }
        ua(p, [{
            key: "length",
            get: function() {
                return this.entries.length
            }
        },
        {
            key: "each",
            value: function(q) {
                P(this.entries,
                function(f) {
                    return q(f)
                });
                return this
            }
        },
        {
            key: "get",
            value: function(q) {
                return this.entries[q]
            }
        },
        {
            key: "addClass",
            value: function(q, f) {
                this.each(function(n) {
                    return n.addClass(q, f)
                });
                return this
            }
        },
        {
            key: "removeClass",
            value: function(q, f) {
                this.each(function(n) {
                    return n.removeClass(q, f)
                });
                return this
            }
        },
        {
            key: "removeAllOverlays",
            value: function() {
                this.each(function(q) {
                    return q.removeAllOverlays()
                });
                return this
            }
        },
        {
            key: "setLabel",
            value: function(q) {
                this.each(function(f) {
                    return f.setLabel(q)
                });
                return this
            }
        },
        {
            key: "clear",
            value: function() {
                this.entries.length = 0;
                return this
            }
        },
        {
            key: "map",
            value: function(q) {
                var f = [];
                this.each(function(n) {
                    return f.push(q(n))
                });
                return f
            }
        },
        {
            key: "addOverlay",
            value: function(q) {
                this.each(function(f) {
                    return f.addOverlay(q)
                });
                return this
            }
        },
        {
            key: "removeOverlay",
            value: function(q) {
                this.each(function(f) {
                    return f.removeOverlay(q)
                });
                return this
            }
        },
        {
            key: "removeOverlays",
            value: function() {
                this.each(function(q) {
                    return q.removeOverlays()
                });
                return this
            }
        },
        {
            key: "showOverlay",
            value: function(q) {
                this.each(function(f) {
                    return f.showOverlay(q)
                });
                return this
            }
        },
        {
            key: "hideOverlay",
            value: function(q) {
                this.each(function(f) {
                    return f.hideOverlay(q)
                });
                return this
            }
        },
        {
            key: "setPaintStyle",
            value: function(q) {
                this.each(function(f) {
                    return f.setPaintStyle(q)
                });
                return this
            }
        },
        {
            key: "setHoverPaintStyle",
            value: function(q) {
                this.each(function(f) {
                    return f.setHoverPaintStyle(q)
                });
                return this
            }
        },
        {
            key: "setSuspendEvents",
            value: function(q) {
                this.each(function(f) {
                    return f.setSuspendEvents(q)
                });
                return this
            }
        },
        {
            key: "setParameter",
            value: function(q, f) {
                this.each(function(n) {
                    return n.parameters[q] = f
                });
                return this
            }
        },
        {
            key: "setParameters",
            value: function(q) {
                this.each(function(f) {
                    return f.parameters = q
                });
                return this
            }
        },
        {
            key: "setVisible",
            value: function(q) {
                this.each(function(f) {
                    return f.setVisible(q)
                });
                return this
            }
        },
        {
            key: "addType",
            value: function(q) {
                this.each(function(f) {
                    return f.addType(q)
                });
                return this
            }
        },
        {
            key: "toggleType",
            value: function(q) {
                this.each(function(f) {
                    return f.toggleType(q)
                });
                return this
            }
        },
        {
            key: "removeType",
            value: function(q) {
                this.each(function(f) {
                    return f.removeType(q)
                });
                return this
            }
        },
        {
            key: "bind",
            value: function(q, f) {
                this.each(function(n) {
                    return n.bind(q, f)
                });
                return this
            }
        },
        {
            key: "unbind",
            value: function(q, f) {
                this.each(function(n) {
                    return n.unbind(q, f)
                });
                return this
            }
        },
        {
            key: "setHover",
            value: function(q) {
                var f = this;
                this.each(function(n) {
                    return f.instance.setHover(n, q)
                });
                return this
            }
        }]);
        return p
    } (),
    Ck = function(p) {
        function q() {
            ja(this, q);
            return f.apply(this, arguments)
        }
        xa(q, p);
        var f = ya(q);
        ua(q, [{
            key: "setEnabled",
            value: function(n) {
                this.each(function(d) {
                    return d.enabled = n
                });
                return this
            }
        },
        {
            key: "setAnchor",
            value: function(n) {
                this.each(function(d) {
                    return d.setAnchor(n)
                });
                return this
            }
        },
        {
            key: "deleteEveryConnection",
            value: function() {
                this.each(function(n) {
                    return n.deleteEveryConnection()
                });
                return this
            }
        },
        {
            key: "deleteAll",
            value: function() {
                var n = this;
                this.each(function(d) {
                    return n.instance.deleteEndpoint(d)
                });
                this.clear();
                return this
            }
        }]);
        return q
    } (Mh),
    Dk = function(p) {
        function q() {
            ja(this, q);
            return f.apply(this, arguments)
        }
        xa(q, p);
        var f = ya(q);
        ua(q, [{
            key: "setDetachable",
            value: function(n) {
                this.each(function(d) {
                    return d.setDetachable(n)
                });
                return this
            }
        },
        {
            key: "setReattach",
            value: function(n) {
                this.each(function(d) {
                    return d.setReattach(n)
                });
                return this
            }
        },
        {
            key: "setConnector",
            value: function(n) {
                this.each(function(d) {
                    return d.setConnector(n)
                });
                return this
            }
        },
        {
            key: "deleteAll",
            value: function() {
                var n = this;
                this.each(function(d) {
                    return n.instance.deleteConnection(d)
                });
                this.clear()
            }
        },
        {
            key: "repaint",
            value: function() {
                var n = this;
                this.each(function(d) {
                    return n.instance.paintConnection(d)
                });
                return this
            }
        }]);
        return q
    } (Mh),
    Ek = function q() {
        ja(this, q);
        x(this, "affectedElements", new Set)
    },
    nc = function(q, f) {
        var n = 0;
        f[1] > q[1] ? n = -1 : f[1] < q[1] && (n = 1);
        return n
    },
    Nh = function(q, f) {
        return - 1 * nc(q, f)
    },
    Fk = function(q) {
        function f(d) {
            ja(this, f);
            var k = n.call(this);
            k.instance = d;
            x(C(k), "_currentTransaction", null);
            x(C(k), "_sortedElements", {
                xmin: [],
                xmax: [],
                ymin: [],
                ymax: []
            });
            x(C(k), "_elementMap", new Map);
            x(C(k), "_transformedElementMap", new Map);
            x(C(k), "_bounds", {
                minx: 0,
                maxx: 0,
                miny: 0,
                maxy: 0
            });
            return k
        }
        xa(f, q);
        var n = ya(f);
        ua(f, [{
            key: "_updateBounds",
            value: function(d, k, a) {
                null != k && (Qb(d, this._sortedElements.xmin), Qb(d, this._sortedElements.xmax), Qb(d, this._sortedElements.ymin), Qb(d, this._sortedElements.ymax), wd([d, k.t.x], this._sortedElements.xmin, nc, !1), wd([d, k.t.x + k.t.w], this._sortedElements.xmax, nc, !0), wd([d, k.t.y], this._sortedElements.ymin, nc, !1), wd([d, k.t.y + k.t.h], this._sortedElements.ymax, nc, !0), !0 !== a && this._recalculateBounds())
            }
        },
        {
            key: "_recalculateBounds",
            value: function() {
                this._bounds.minx = 0 < this._sortedElements.xmin.length ? this._sortedElements.xmin[0][1] : 0;
                this._bounds.maxx = 0 < this._sortedElements.xmax.length ? this._sortedElements.xmax[0][1] : 0;
                this._bounds.miny = 0 < this._sortedElements.ymin.length ? this._sortedElements.ymin[0][1] : 0;
                this._bounds.maxy = 0 < this._sortedElements.ymax.length ? this._sortedElements.ymax[0][1] : 0
            }
        },
        {
            key: "recomputeBounds",
            value: function() {
                var d = this;
                this._sortedElements.xmin.length = 0;
                this._sortedElements.xmax.length = 0;
                this._sortedElements.ymin.length = 0;
                this._sortedElements.ymax.length = 0;
                this._elementMap.forEach(function(k, a) {
                    d._sortedElements.xmin.push([a, k.t.x]);
                    d._sortedElements.xmax.push([a, k.t.x + k.t.w]);
                    d._sortedElements.ymin.push([a, k.t.y]);
                    d._sortedElements.ymax.push([a, k.t.y + k.t.h])
                });
                this._sortedElements.xmin.sort(nc);
                this._sortedElements.ymin.sort(nc);
                this._sortedElements.xmax.sort(Nh);
                this._sortedElements.ymax.sort(Nh);
                this._recalculateBounds()
            }
        },
        {
            key: "_finaliseUpdate",
            value: function(d, k, a) {
                k.t = oj(k.x, k.y, k.w, k.h, k.r);
                this._transformedElementMap.set(d, k.t); ! 0 !== a && this._updateBounds(d, k, a)
            }
        },
        {
            key: "shouldFireEvent",
            value: function(d, k, a) {
                return ! 0
            }
        },
        {
            key: "startTransaction",
            value: function() {
                if (null != this._currentTransaction) throw Error("Viewport: cannot start transaction; a transaction is currently active.");
                this._currentTransaction = new Ek
            }
        },
        {
            key: "endTransaction",
            value: function() {
                var d = this;
                null != this._currentTransaction && (this._currentTransaction.affectedElements.forEach(function(k) {
                    var a = d.getPosition(k);
                    d._finaliseUpdate(k, a, !0)
                }), this.recomputeBounds(), this._currentTransaction = null)
            }
        },
        {
            key: "updateElements",
            value: function(d) {
                var k = this;
                P(d,
                function(a) {
                    return k.updateElement(a.id, a.x, a.y, a.width, a.height, a.rotation)
                })
            }
        },
        {
            key: "updateElement",
            value: function(d, k, a, e, c, h, b) {
                var g = vd(this._elementMap, d, Uf);
                g.dirty = null == k && null == g.x || null == a && null == g.y || null == e && null == g.w || null == c && null == g.h;
                null != k && (g.x = k);
                null != a && (g.y = a);
                null != e && (g.w = e);
                null != c && (g.h = c);
                null != h && (g.r = h || 0);
                g.c.x = g.x + g.w / 2;
                g.c.y = g.y + g.h / 2;
                g.x2 = g.x + g.w;
                g.y2 = g.y + g.h;
                null == this._currentTransaction ? this._finaliseUpdate(d, g, b) : this._currentTransaction.affectedElements.add(d);
                return g
            }
        },
        {
            key: "refreshElement",
            value: function(d, k) {
                var a = this.instance.getManagedElements(),
                e = a[d] ? a[d].el: null;
                return null != e ? (a = this.getSize(e), e = this.getOffset(e), this.updateElement(d, e.x, e.y, a.w, a.h, null, k)) : null
            }
        },
        {
            key: "getSize",
            value: function(d) {
                return this.instance.getSize(d)
            }
        },
        {
            key: "getOffset",
            value: function(d) {
                return this.instance.getOffset(d)
            }
        },
        {
            key: "registerElement",
            value: function(d, k) {
                return this.updateElement(d, 0, 0, 0, 0, 0, k)
            }
        },
        {
            key: "addElement",
            value: function(d, k, a, e, c, h) {
                return this.updateElement(d, k, a, e, c, h)
            }
        },
        {
            key: "rotateElement",
            value: function(d, k) {
                var a = vd(this._elementMap, d, Uf);
                a.r = k || 0;
                this._finaliseUpdate(d, a);
                return a
            }
        },
        {
            key: "getBoundsWidth",
            value: function() {
                return this._bounds.maxx - this._bounds.minx
            }
        },
        {
            key: "getBoundsHeight",
            value: function() {
                return this._bounds.maxy - this._bounds.miny
            }
        },
        {
            key: "getX",
            value: function() {
                return this._bounds.minx
            }
        },
        {
            key: "getY",
            value: function() {
                return this._bounds.miny
            }
        },
        {
            key: "setSize",
            value: function(d, k, a) {
                if (this._elementMap.has(d)) return this.updateElement(d, null, null, k, a, null)
            }
        },
        {
            key: "setPosition",
            value: function(d, k, a) {
                if (this._elementMap.has(d)) return this.updateElement(d, k, a, null, null, null)
            }
        },
        {
            key: "reset",
            value: function() {
                this._sortedElements.xmin.length = 0;
                this._sortedElements.xmax.length = 0;
                this._sortedElements.ymin.length = 0;
                this._sortedElements.ymax.length = 0;
                this._elementMap.clear();
                this._transformedElementMap.clear();
                this._recalculateBounds()
            }
        },
        {
            key: "remove",
            value: function(d) {
                Qb(d, this._sortedElements.xmin);
                Qb(d, this._sortedElements.xmax);
                Qb(d, this._sortedElements.ymin);
                Qb(d, this._sortedElements.ymax);
                this._elementMap["delete"](d);
                this._transformedElementMap["delete"](d);
                this._recalculateBounds()
            }
        },
        {
            key: "getPosition",
            value: function(d) {
                return this._elementMap.get(d)
            }
        },
        {
            key: "getElements",
            value: function() {
                return this._elementMap
            }
        },
        {
            key: "isEmpty",
            value: function() {
                return 0 === this._elementMap.size
            }
        }]);
        return f
    } (zc),
    Oh = function() {
        function q(f, n) {
            var d = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : !1;
            ja(this, q);
            this.selector = f;
            this.def = n;
            this.exclude = d
        }
        ua(q, [{
            key: "setEnabled",
            value: function(f) {
                this.def.enabled = f
            }
        },
        {
            key: "isEnabled",
            value: function() {
                return ! 1 !== this.def.enabled
            }
        }]);
        return q
    } (),
    Gk = function(q) {
        function f(d, k, a) {
            ja(this, f);
            d = n.call(this, d, k, a);
            d.def = k;
            x(C(d), "redrop", void 0);
            d.redrop = k.def.redrop || "strict";
            return d
        }
        xa(f, q);
        var n = ya(f);
        return f
    } (Oh),
    Hk = function(q) {
        function f(d, k, a) {
            ja(this, f);
            d = n.call(this, d, k, a);
            d.def = k;
            return d
        }
        xa(f, q);
        var n = ya(f);
        return f
    } (Oh),
    Gc,
    Ik = (Gc = {},
    x(Gc, wa, Wf), x(Gc, Ma, Vf), x(Gc, Ua, Vf), x(Gc, La, Wf), Gc),
    Jk = function() {
        function q(f) {
            var n = this;
            ja(this, q);
            this.instance = f;
            x(this, "anchorLists", new Map);
            x(this, "anchorLocations", new Map);
            f.bind("internal.connection:detached",
            function(d) {
                n._removeEndpointFromAnchorLists(d.sourceEndpoint);
                n._removeEndpointFromAnchorLists(d.targetEndpoint)
            });
            f.bind("internal.endpoint:unregistered",
            function(d) {
                n._removeEndpointFromAnchorLists(d)
            })
        }
        ua(q, [{
            key: "getAnchorOrientation",
            value: function(f) {
                return (f = this.anchorLocations.get(f.id)) ? [f.ox, f.oy] : [0, 0]
            }
        },
        {
            key: "_distance",
            value: function(f, n, d, k, a, e, c) {
                c = k.x + f.x * a.w;
                var h = k.y + f.y * a.h;
                f = k.x + a.w / 2;
                k = k.y + a.h / 2;
                null != e && 0 < e.length && (e = this.instance._applyRotations([c, h, 0, 0], e), c = e.x, h = e.y);
                return Math.sqrt(Math.pow(n - c, 2) + Math.pow(d - h, 2)) + Math.sqrt(Math.pow(f - c, 2) + Math.pow(k - h, 2))
            }
        },
        {
            key: "_anchorSelector",
            value: function(f, n, d, k, a, e, c) {
                var h = d.x + k.w / 2;
                d = d.y + k.h / 2;
                k = -1;
                for (var b = Infinity,
                g = 0; g < c.length; g++) {
                    var m = this._distance(c[g], h, d, f, n, a, e);
                    m < b && (k = g + 0, b = m)
                }
                return [k, c[k]]
            }
        },
        {
            key: "_floatingAnchorCompute",
            value: function(f, n) {
                n = n.xy;
                return this._setComputedPosition(f, {
                    curX: n.x + f.size.w / 2,
                    curY: n.y + f.size.h / 2,
                    x: 0,
                    y: 0,
                    ox: 0,
                    oy: 0
                })
            }
        },
        {
            key: "_setComputedPosition",
            value: function(f, n, d) {
                this.anchorLocations.set(f.id, n);
                f.computedPosition = n;
                d && (f.timestamp = d);
                return n
            }
        },
        {
            key: "_computeSingleLocation",
            value: function(f, n, d, k) {
                n = {
                    curX: n.x + f.x * d.w + f.offx,
                    curY: n.y + f.y * d.h + f.offy,
                    x: f.x,
                    y: f.y,
                    ox: 0,
                    oy: 0
                };
                k = k.rotation;
                if (null != k && 0 < k.length) {
                    var a = [f.iox, f.ioy],
                    e = {
                        x: n.curX,
                        y: n.curY,
                        cr: 0,
                        sr: 0
                    };
                    P(k,
                    function(c) {
                        e = qb(e, c.c, c.r);
                        a = [Math.round(a[0] * e.cr - a[1] * e.sr), Math.round(a[1] * e.cr + a[0] * e.sr)].slice()
                    });
                    f.ox = a[0];
                    f.oy = a[1];
                    f = {
                        curX: e.x,
                        curY: e.y,
                        x: f.x,
                        y: f.y,
                        ox: a[0],
                        oy: a[1]
                    }
                } else f.ox = f.iox,
                f.oy = f.ioy,
                f = A({
                    ox: f.iox,
                    oy: f.ioy
                },
                n);
                return f
            }
        },
        {
            key: "_singleAnchorCompute",
            value: function(f, n) {
                var d = n.xy,
                k = n.wh,
                a = n.timestamp,
                e = this.anchorLocations.get(f.id);
                if (null != e && a && a === f.timestamp) return e;
                e = se([f.currentLocation, f.locations[f.currentLocation]], 2);
                e[0];
                e = this._computeSingleLocation(e[1], d, k, n);
                return this._setComputedPosition(f, e, a)
            }
        },
        {
            key: "_defaultAnchorCompute",
            value: function(f, n) {
                if (1 === f.locations.length) return this._singleAnchorCompute(f, n);
                var d = n.xy;
                var k = n.wh,
                a = n.txy,
                e = n.twh,
                c = se([f.currentLocation, f.locations[f.currentLocation]], 2),
                h = c[0];
                c = c[1];
                f.locked || null == a || null == e ? d = this._computeSingleLocation(c, d, k, n) : (a = this._anchorSelector(d, k, a, e, n.rotation, n.tRotation, f.locations), e = se(a, 2), a = e[0], e = e[1], f.currentLocation = a, a !== h && (f.cssClass = e.cls || f.cssClass, n.element._anchorLocationChanged(f)), d = this._computeSingleLocation(e, d, k, n));
                return this._setComputedPosition(f, d, n.timestamp)
            }
        },
        {
            key: "_placeAnchors",
            value: function(f, n) {
                var d = this,
                k = this.instance.viewport.getPosition(f),
                a = function(e, c, h, b, g, m) {
                    if (0 < h.length) {
                        c = h.sort(Ik[e]);
                        h = e === Ma || e === wa;
                        var r = b ? k.w: k.h,
                        t = b ? k.h: k.w;
                        e = [];
                        for (var u = r / (c.length + 1), v = 0; v < c.length; v++) {
                            var w = (v + 1) * u,
                            z = g * t;
                            h && (w = r - w);
                            var y = b ? w: z,
                            E = k.x + y;
                            y /= k.w;
                            z = b ? z: w;
                            w = k.y + z;
                            z /= k.h;
                            0 !== k.r && null != k.r && (w = qb({
                                x: E,
                                y: w
                            },
                            k.c, k.r), E = w.x, w = w.y);
                            e.push({
                                x: E,
                                y: w,
                                xLoc: y,
                                yLoc: z,
                                c: c[v].c
                            })
                        }
                        for (b = 0; b < e.length; b++) g = e[b].c,
                        d._setComputedPosition((g.endpoints[0].elementId === f ? g.endpoints[0] : g.endpoints[1])._anchor, {
                            curX: e[b].x,
                            curY: e[b].y,
                            x: e[b].xLoc,
                            y: e[b].yLoc,
                            ox: m[0],
                            oy: m[1]
                        })
                    }
                };
                a(Ua, k, n.bottom, !0, 1, [0, 1]);
                a(wa, k, n.top, !0, 0, [0, -1]);
                a(La, k, n.left, !1, 0, [ - 1, 0]);
                a(Ma, k, n.right, !1, 1, [1, 0])
            }
        },
        {
            key: "_updateAnchorList",
            value: function(f, n, d, k, a, e, c, h, b, g, m) {
                var r = k.endpoints[c],
                t = r.id,
                u = [1, 0][c];
                n = {
                    theta: n,
                    order: d,
                    c: k,
                    b: a,
                    elId: e,
                    epId: t
                };
                d = f[b];
                if (f = r._continuousAnchorEdge ? f[r._continuousAnchorEdge] : null) if (k = ub(f,
                function(v) {
                    return v.epId === t
                }), -1 !== k) for (f.splice(k, 1), a = 0; a < f.length; a++) k = f[a].c,
                !0 !== k.placeholder && g.add(k),
                m.add(f[a].c.endpoints[c]),
                m.add(f[a].c.endpoints[u]);
                for (f = 0; f < d.length; f++) k = d[f].c,
                !0 !== k.placeholder && g.add(k),
                m.add(d[f].c.endpoints[c]),
                m.add(d[f].c.endpoints[u]);
                d.splice(h ? 0 : d.length, 0, n);
                r._continuousAnchorEdge = b
            }
        },
        {
            key: "_removeEndpointFromAnchorLists",
            value: function(f) {
                var n = 0; (function(d, k) {
                    if (d) {
                        var a = function(e) {
                            return e.epId === k
                        };
                        ma(d.top, a);
                        ma(d.left, a);
                        ma(d.bottom, a);
                        ma(d.right, a);
                        n += d.top.length;
                        n += d.left.length;
                        n += d.bottom.length;
                        n += d.right.length
                    }
                })(this.anchorLists.get(f.elementId), f.id);
                if (0 === n) this.anchorLists["delete"](f.elementId);
                this.anchorLocations["delete"](f._anchor.id)
            }
        },
        {
            key: "computeAnchorLocation",
            value: function(f, n) {
                var d = lb(f) ? this.anchorLocations.get(f.id) || {
                    curX: 0,
                    curY: 0,
                    x: 0,
                    y: 0,
                    ox: 0,
                    oy: 0
                }: !0 === f.isContinuous ? this._floatingAnchorCompute(f, n) : this._defaultAnchorCompute(f, n);
                f.timestamp = n.timestamp;
                return d
            }
        },
        {
            key: "computePath",
            value: function(f, n) {
                var d = this.instance.viewport.getPosition(f.sourceId),
                k = this.instance.viewport.getPosition(f.targetId),
                a = f.endpoints[0],
                e = f.endpoints[1];
                a = this.getEndpointLocation(a, {
                    xy: d,
                    wh: d,
                    element: a,
                    timestamp: n,
                    rotation: this.instance._getRotations(f.sourceId)
                });
                n = this.getEndpointLocation(e, {
                    xy: k,
                    wh: k,
                    element: e,
                    timestamp: n,
                    rotation: this.instance._getRotations(f.targetId)
                });
                f.connector.resetBounds();
                f.connector.compute({
                    sourcePos: a,
                    targetPos: n,
                    sourceEndpoint: f.endpoints[0],
                    targetEndpoint: f.endpoints[1],
                    strokeWidth: f.paintStyleInUse.strokeWidth,
                    sourceInfo: d,
                    targetInfo: k
                })
            }
        },
        {
            key: "getEndpointLocation",
            value: function(f, n) {
                n = n || {};
                f = f._anchor;
                var d = this.anchorLocations.get(f.id);
                if (null == d || null != n.timestamp && f.timestamp !== n.timestamp) d = this.computeAnchorLocation(f, n),
                this._setComputedPosition(f, d, n.timestamp);
                return d
            }
        },
        {
            key: "getEndpointOrientation",
            value: function(f) {
                return f._anchor ? this.getAnchorOrientation(f._anchor) : [0, 0]
            }
        },
        {
            key: "isDynamicAnchor",
            value: function(f) {
                return f._anchor ? !lb(f._anchor) && 1 < f._anchor.locations.length: !1
            }
        },
        {
            key: "isFloating",
            value: function(f) {
                return f._anchor ? !0 === f._anchor.isContinuous: !1
            }
        },
        {
            key: "prepareAnchor",
            value: function(f, n) {
                return Tc(n)
            }
        },
        {
            key: "redraw",
            value: function(f, n, d) {
                var k = this;
                d = new Set;
                var a = new Set,
                e = new Set;
                if (!this.instance._suspendDrawing) {
                    var c = this.instance.endpointsByElement[f] || [];
                    n = n || fa();
                    for (var h = {},
                    b, g, m = 0; m < c.length; m++) if (g = c[m], a.add(g), b = g._anchor, 0 === g.connections.length) lb(b) && (this.anchorLists.has(f) || this.anchorLists.set(f, {
                        top: [],
                        right: [],
                        bottom: [],
                        left: []
                    }), this._updateAnchorList(this.anchorLists.get(f), -Math.PI / 2, 0, {
                        endpoints: [g, g],
                        placeholder: !0
                    },
                    !1, f, 0, !1, 0 === b.faces.length ? wa: b.faces[0], d, a), e.add(f));
                    else for (b = 0; b < g.connections.length; b++) {
                        var r = g.connections[b],
                        t = r.sourceId,
                        u = r.targetId,
                        v = lb(r.endpoints[0]._anchor),
                        w = lb(r.endpoints[1]._anchor);
                        if (v || w) {
                            var z = t + "_" + u,
                            y = h[z],
                            E = r.sourceId === f ? 1 : 0;
                            v && !this.anchorLists.has(t) && this.anchorLists.set(t, {
                                top: [],
                                right: [],
                                bottom: [],
                                left: []
                            });
                            w && !this.anchorLists.has(u) && this.anchorLists.set(u, {
                                top: [],
                                right: [],
                                bottom: [],
                                left: []
                            });
                            var F = this.instance.viewport.getPosition(u),
                            M = this.instance.viewport.getPosition(t);
                            if (u === t && (v || w)) this._updateAnchorList(this.anchorLists.get(t), -Math.PI / 2, 0, r, !1, u, 0, !1, wa, d, a),
                            this._updateAnchorList(this.anchorLists.get(u), -Math.PI / 2, 0, r, !1, t, 1, !1, wa, d, a);
                            else {
                                var S = this.instance._getRotations(t),
                                X = this.instance._getRotations(u);
                                y || (y = this._calculateOrientation(t, u, M, F, r.endpoints[0]._anchor, r.endpoints[1]._anchor, S, X), h[z] = y);
                                v && this._updateAnchorList(this.anchorLists.get(t), y.theta, 0, r, !1, u, 0, !1, y.a[0], d, a);
                                w && this._updateAnchorList(this.anchorLists.get(u), y.theta2, -1, r, !0, t, 1, !0, y.a[1], d, a)
                            }
                            v && e.add(t);
                            w && e.add(u);
                            d.add(r); (v && 0 === E || w && 1 === E) && a.add(r.endpoints[E])
                        } else if (r = g.connections[b].endpoints[r.sourceId === f ? 1 : 0], 1 < r._anchor.locations.length) for (this.instance.paintEndpoint(r, {
                            elementWithPrecedence: f,
                            timestamp: n
                        }), d.add(g.connections[b]), t = 0; t < r.connections.length; t++) r.connections[t] !== g.connections[b] && d.add(r.connections[t]);
                        else d.add(g.connections[b])
                    }
                    e.forEach(function(da) {
                        k._placeAnchors(da, k.anchorLists.get(da))
                    });
                    a.forEach(function(da) {
                        var W = k.instance.viewport.getPosition(da.elementId);
                        k.instance.paintEndpoint(da, {
                            timestamp: n,
                            offset: W
                        })
                    });
                    d.forEach(function(da) {
                        k.instance.paintConnection(da, {
                            timestamp: n
                        })
                    })
                }
                return {
                    c: d,
                    e: a
                }
            }
        },
        {
            key: "reset",
            value: function() {
                this.anchorLocations.clear();
                this.anchorLists.clear()
            }
        },
        {
            key: "setAnchor",
            value: function(f, n) {
                null != n && (f._anchor = n)
            }
        },
        {
            key: "setConnectionAnchors",
            value: function(f, n) {
                f.endpoints[0]._anchor = n[0];
                f.endpoints[1]._anchor = n[1]
            }
        },
        {
            key: "_calculateOrientation",
            value: function(f, n, d, k, a, e, c, h) {
                var b = this;
                if (f === n) return {
                    orientation: "identity",
                    a: [wa, wa]
                };
                f = Math.atan2(k.c.y - d.c.y, k.c.x - d.c.x);
                n = Math.atan2(d.c.y - k.c.y, d.c.x - k.c.x);
                var g = [],
                m = {}; (function(r, t) {
                    for (var u = 0; u < r.length; u++) {
                        var v;
                        m[r[u]] = (v = {},
                        x(v, La, {
                            x: t[u][0].x,
                            y: t[u][0].c.y
                        }), x(v, Ma, {
                            x: t[u][0].x + t[u][0].w,
                            y: t[u][0].c.y
                        }), x(v, wa, {
                            x: t[u][0].c.x,
                            y: t[u][0].y
                        }), x(v, Ua, {
                            x: t[u][0].c.x,
                            y: t[u][0].y + t[u][0].h
                        }), v);
                        if (null != t[u][1] && 0 < t[u][1].length) for (var w in m[r[u]]) m[r[u]][w] = b.instance._applyRotationsXY(m[r[u]][w], t[u][1])
                    }
                })(["source", "target"], [[d, c], [k, h]]);
                d = [wa, La, Ma, Ua];
                for (k = 0; k < d.length; k++) for (c = 0; c < d.length; c++) g.push({
                    source: d[k],
                    target: d[c],
                    dist: Va(m.source[d[k]], m.target[d[c]])
                });
                g.sort(function(r, t) {
                    if (r.dist < t.dist) return - 1;
                    if (t.dist < r.dist) return 1;
                    var u, v = (u = {},
                    x(u, La, 0), x(u, wa, 1), x(u, Ma, 2), x(u, Ua, 3), u);
                    u = v[r.source];
                    var w = v[t.source];
                    r = v[r.target];
                    t = v[t.target];
                    return u < w ? -1 : w < u ? 1 : r < t ? -1 : t < r ? 1 : 0
                });
                d = g[0].source;
                k = g[0].target;
                for (c = 0; c < g.length && (d = lb(a) && a.locked ? a.currentFace: !a.isContinuous || Kf(a, g[c].source) ? g[c].source: null, k = e.isContinuous && e.locked ? e.currentFace: !e.isContinuous || Kf(e, g[c].target) ? g[c].target: null, null == d || null == k); c++);
                a.isContinuous && this.setCurrentFace(a, d);
                e.isContinuous && this.setCurrentFace(e, k);
                return {
                    a: [d, k],
                    theta: f,
                    theta2: n
                }
            }
        },
        {
            key: "setCurrentFace",
            value: function(f, n, d) {
                f.currentFace = n;
                d && null != f.lockedFace && (f.lockedFace = f.currentFace)
            }
        },
        {
            key: "lock",
            value: function(f) {
                f.locked = !0;
                lb(f) && (f.lockedFace = f.currentFace)
            }
        },
        {
            key: "unlock",
            value: function(f) {
                f.locked = !1;
                lb(f) && (f.lockedFace = null)
            }
        },
        {
            key: "selectAnchorLocation",
            value: function(f, n) {
                var d = ub(f.locations,
                function(k) {
                    return k.x === n.x && k.y === n.y
                });
                return - 1 !== d ? (f.currentLocation = d, !0) : !1
            }
        },
        {
            key: "lockCurrentAxis",
            value: function(f) {
                null != f.currentFace && (f.lockedAxis = f.currentFace === La || f.currentFace === Ma ? wk: xk)
            }
        },
        {
            key: "unlockCurrentAxis",
            value: function(f) {
                f.lockedAxis = null
            }
        },
        {
            key: "anchorsEqual",
            value: function(f, n) {
                if (!f || !n) return ! 1;
                f = f.locations[f.currentLocation];
                n = n.locations[n.currentLocation];
                return f.x === n.x && f.y === n.y && f.offx === n.offx && f.offy === n.offy && f.ox === n.ox && f.oy === n.oy
            }
        }]);
        return q
    } (),
    Kk = function(q) {
        function f(d, k) {
            ja(this, f);
            var a = n.call(this);
            a._instanceIndex = d;
            x(C(a), "defaults", void 0);
            x(C(a), "_initialDefaults", {});
            x(C(a), "isConnectionBeingDragged", !1);
            x(C(a), "currentlyDragging", !1);
            x(C(a), "hoverSuspended", !1);
            x(C(a), "_suspendDrawing", !1);
            x(C(a), "_suspendedAt", null);
            x(C(a), "connectorClass", "jtk-connector");
            x(C(a), "connectorOutlineClass", "jtk-connector-outline");
            x(C(a), "connectedClass", "jtk-connected");
            x(C(a), "endpointClass", "jtk-endpoint");
            x(C(a), "endpointConnectedClass", "jtk-endpoint-connected");
            x(C(a), "endpointFullClass", "jtk-endpoint-full");
            x(C(a), "endpointDropAllowedClass", "jtk-endpoint-drop-allowed");
            x(C(a), "endpointDropForbiddenClass", "jtk-endpoint-drop-forbidden");
            x(C(a), "endpointAnchorClassPrefix", "jtk-endpoint-anchor");
            x(C(a), "overlayClass", "jtk-overlay");
            x(C(a), "connections", []);
            x(C(a), "endpointsByElement", {});
            x(C(a), "endpointsByUUID", new Map);
            x(C(a), "sourceSelectors", []);
            x(C(a), "targetSelectors", []);
            x(C(a), "allowNestedGroups", void 0);
            x(C(a), "_curIdStamp", 1);
            x(C(a), "viewport", new Fk(C(a)));
            x(C(a), "router", void 0);
            x(C(a), "groupManager", void 0);
            x(C(a), "_connectionTypes", new Map);
            x(C(a), "_endpointTypes", new Map);
            x(C(a), "_container", void 0);
            x(C(a), "_managedElements", {});
            x(C(a), "DEFAULT_SCOPE", void 0);
            x(C(a), "_zoom", 1);
            a.defaults = {
                anchor: ec.Bottom,
                anchors: [null, null],
                connectionsDetachable: !0,
                connectionOverlays: [],
                connector: Sd.type,
                container: null,
                endpoint: Bc.type,
                endpointOverlays: [],
                endpoints: [null, null],
                endpointStyle: {
                    fill: "#456"
                },
                endpointStyles: [null, null],
                endpointHoverStyle: null,
                endpointHoverStyles: [null, null],
                hoverPaintStyle: null,
                listStyle: {},
                maxConnections: 1,
                paintStyle: {
                    strokeWidth: 2,
                    stroke: "#456"
                },
                reattachConnections: !1,
                scope: "jsplumb_defaultscope",
                allowNestedGroups: !0
            };
            k && A(a.defaults, k);
            A(a._initialDefaults, a.defaults);
            a.DEFAULT_SCOPE = a.defaults.scope;
            a.allowNestedGroups = !1 !== a._initialDefaults.allowNestedGroups;
            a.router = new Jk(C(a));
            a.groupManager = new Bk(C(a));
            a.setContainer(a._initialDefaults.container);
            return a
        }
        xa(f, q);
        var n = ya(f);
        ua(f, [{
            key: "defaultScope",
            get: function() {
                return this.DEFAULT_SCOPE
            }
        },
        {
            key: "currentZoom",
            get: function() {
                return this._zoom
            }
        },
        {
            key: "areDefaultAnchorsSet",
            value: function() {
                return this.validAnchorsSpec(this.defaults.anchors)
            }
        },
        {
            key: "validAnchorsSpec",
            value: function(d) {
                return null != d && null != d[0] && null != d[1]
            }
        },
        {
            key: "getContainer",
            value: function() {
                return this._container
            }
        },
        {
            key: "setZoom",
            value: function(d, k) {
                this._zoom = d;
                this.fire("zoom", this._zoom);
                k && this.repaintEverything();
                return ! 0
            }
        },
        {
            key: "_idstamp",
            value: function() {
                return "" + this._curIdStamp++
            }
        },
        {
            key: "checkCondition",
            value: function(d, k) {
                var a = this.getListener(d),
                e = !0;
                if (a && 0 < a.length) {
                    var c = Array.prototype.slice.call(arguments, 1);
                    try {
                        for (var h = 0,
                        b = a.length; h < b; h++) e = e && a[h].apply(a[h], c)
                    } catch(g) {
                        pa("cannot check condition [" + d + "]" + g)
                    }
                }
                return e
            }
        },
        {
            key: "getId",
            value: function(d, k) {
                if (null == d) return null;
                var a = this.getAttribute(d, "data-jtk-managed");
                if (!a || "undefined" === a) {
                    if (2 === arguments.length && void 0 !== arguments[1]) a = k;
                    else if (1 === arguments.length || 3 === arguments.length && !arguments[2]) a = "jsplumb-" + this._instanceIndex + "-" + this._idstamp();
                    this.setAttribute(d, "data-jtk-managed", a)
                }
                return a
            }
        },
        {
            key: "getConnections",
            value: function(d, k) {
                d ? d.constructor === String && (d = {
                    scope: d
                }) : d = {};
                var a = fc(this, d.scope || this.defaultScope, !0),
                e = fc(this, d.source);
                d = fc(this, d.target);
                for (var c = !k && 1 < a.length ? {}: [], h = 0, b = this.connections.length; h < b; h++) {
                    var g = this.connections[h],
                    m = g.proxies && g.proxies[0] ? g.proxies[0].originalEp.elementId: g.sourceId,
                    r = g.proxies && g.proxies[1] ? g.proxies[1].originalEp.elementId: g.targetId;
                    N(a, g.scope) && N(e, m) && N(d, r) && (m = g.scope, !k && 1 < a.length ? (r = c[m], null == r && (r = c[m] = []), r.push(g)) : c.push(g))
                }
                return c
            }
        },
        {
            key: "select",
            value: function(d) {
                d = d || {};
                d.scope = d.scope || "*";
                return new Dk(this, d.connections || this.getConnections(d, !0))
            }
        },
        {
            key: "selectEndpoints",
            value: function(d) {
                d = d || {};
                d.scope = d.scope || "*";
                var k = !d.element && !d.source && !d.target,
                a = k ? "*": fc(this, d.element),
                e = k ? "*": fc(this, d.source);
                k = k ? "*": fc(this, d.target);
                d = fc(this, d.scope, !0);
                var c = [],
                h;
                for (h in this.endpointsByElement) {
                    var b = N(a, h, !0),
                    g = N(e, h, !0),
                    m = "*" !== e,
                    r = N(k, h, !0),
                    t = "*" !== k;
                    if (b || g || r) a: for (b = 0, g = this.endpointsByElement[h].length; b < g; b++) if (r = this.endpointsByElement[h][b], N(d, r.scope, !0)) {
                        var u = t && 0 < k.length && !r.isTarget;
                        if (m && 0 < e.length && !r.isSource || u) continue a;
                        c.push(r)
                    }
                }
                return new Ck(this, c)
            }
        },
        {
            key: "setContainer",
            value: function(d) {
                this._container = d;
                this.fire("container:change", this._container)
            }
        },
        {
            key: "_set",
            value: function(d, k, a) {
                var e = [{
                    el: "source",
                    elId: "sourceId"
                },
                {
                    el: "target",
                    elId: "targetId"
                }][a],
                c = d[e.elId],
                h = d.endpoints[a];
                c = {
                    index: a,
                    originalEndpoint: h,
                    originalSourceId: 0 === a ? c: d.sourceId,
                    newSourceId: d.sourceId,
                    originalTargetId: 1 === a ? c: d.targetId,
                    newTargetId: d.targetId,
                    connection: d,
                    newEndpoint: h
                };
                if (k instanceof Ud) k.addConnection(d);
                else {
                    var b = this.getId(k);
                    k = b === d[e.elId] ? null: d.makeEndpoint(0 === a, k, b)
                }
                null != k && (c.newEndpoint = k, h.detachFromConnection(d), d.endpoints[a] = k, d[e.el] = k.element, d[e.elId] = k.elementId, c[0 === a ? "newSourceId": "newTargetId"] = k.elementId, this.fireMoveEvent(c), this.paintConnection(d));
                return c
            }
        },
        {
            key: "setSource",
            value: function(d, k) {
                Ed(d, this._managedElements[d.sourceId]);
                k = this._set(d, k, 0);
                Dd(d, this._managedElements[k.newSourceId])
            }
        },
        {
            key: "setTarget",
            value: function(d, k) {
                Ed(d, this._managedElements[d.targetId]);
                k = this._set(d, k, 1);
                Dd(d, this._managedElements[k.newTargetId])
            }
        },
        {
            key: "isHoverSuspended",
            value: function() {
                return this.hoverSuspended
            }
        },
        {
            key: "setSuspendDrawing",
            value: function(d, k) {
                var a = this._suspendDrawing; (this._suspendDrawing = d) ? this._suspendedAt = "" + (new Date).getTime() : (this._suspendedAt = null, this.viewport.recomputeBounds());
                k && this.repaintEverything();
                return a
            }
        },
        {
            key: "getSuspendedAt",
            value: function() {
                return this._suspendedAt
            }
        },
        {
            key: "batch",
            value: function(d, k) {
                var a = !0 === this._suspendDrawing;
                a || this.setSuspendDrawing(!0);
                d();
                a || this.setSuspendDrawing(!1, !k)
            }
        },
        {
            key: "each",
            value: function(d, k) {
                if (null != d) {
                    if (null != d.length) for (var a = 0; a < d.length; a++) k(d[a]);
                    else k(d);
                    return this
                }
            }
        },
        {
            key: "updateOffset",
            value: function(d) {
                var k = d.elId;
                return d.recalc ? this.viewport.refreshElement(k) : this.viewport.getPosition(k)
            }
        },
        {
            key: "deleteConnection",
            value: function(d, k) {
                if (null != d && !0 !== d.deleted && (k = k || {},
                k.force || wf(!0, !1, [[d.endpoints[0], "isDetachAllowed", [d]], [d.endpoints[1], "isDetachAllowed", [d]], [d, "isDetachAllowed", [d]], [this, "checkCondition", ["beforeDetach", d]]]))) {
                    Ed(d, this._managedElements[d.sourceId], this._managedElements[d.targetId]);
                    this.fireDetachEvent(d, !d.pending && !1 !== k.fireEvent, k.originalEvent);
                    var a = d.endpoints[0],
                    e = d.endpoints[1];
                    a !== k.endpointToIgnore && a.detachFromConnection(d, null, !0);
                    e !== k.endpointToIgnore && e.detachFromConnection(d, null, !0);
                    ma(this.connections,
                    function(c) {
                        return d.id === c.id
                    });
                    d.destroy();
                    a !== k.endpointToIgnore && a.deleteOnEmpty && 0 === a.connections.length && this.deleteEndpoint(a);
                    e !== k.endpointToIgnore && e.deleteOnEmpty && 0 === e.connections.length && this.deleteEndpoint(e);
                    return ! 0
                }
                return ! 1
            }
        },
        {
            key: "deleteEveryConnection",
            value: function(d) {
                var k = this;
                d = d || {};
                var a = this.connections.length,
                e = 0;
                this.batch(function() {
                    for (var c = 0; c < a; c++) e += k.deleteConnection(k.connections[0], d) ? 1 : 0
                });
                return e
            }
        },
        {
            key: "deleteConnectionsForElement",
            value: function(d, k) {
                d = this.getId(d);
                if (d = this._managedElements[d]) for (var a = d.connections.length,
                e = 0; e < a; e++) this.deleteConnection(d.connections[0], k);
                return this
            }
        },
        {
            key: "fireDetachEvent",
            value: function(d, k, a) {
                d = null != d.id ? {
                    connection: d,
                    source: d.source,
                    target: d.target,
                    sourceId: d.sourceId,
                    targetId: d.targetId,
                    sourceEndpoint: d.endpoints[0],
                    targetEndpoint: d.endpoints[1]
                }: d;
                k && this.fire("connection:detach", d, a);
                this.fire("internal.connection:detached", d, a)
            }
        },
        {
            key: "fireMoveEvent",
            value: function(d, k) {
                this.fire("connection:move", d, k)
            }
        },
        {
            key: "manageAll",
            value: function(d, k) {
                d = J(d) ? this.getSelector(this.getContainer(), d) : d;
                for (var a = 0; a < d.length; a++) this.manage(d[a], null, k)
            }
        },
        {
            key: "manage",
            value: function(d, k, a) {
                null == this.getAttribute(d, "data-jtk-managed") && (k = k || this.getAttribute(d, "id") || fa(), this.setAttribute(d, "data-jtk-managed", k));
                k = this.getId(d);
                this._managedElements[k] ? a && (this._managedElements[k].viewportElement = this.updateOffset({
                    elId: k,
                    timestamp: null,
                    recalc: !0
                })) : (a = {
                    el: d,
                    endpoints: [],
                    connections: [],
                    rotation: 0
                },
                this._managedElements[k] = a, a.viewportElement = this._suspendDrawing ? this.viewport.registerElement(k, !0) : this.updateOffset({
                    elId: k,
                    recalc: !0
                }), this.fire("element:manage", {
                    el: d
                }));
                return this._managedElements[k]
            }
        },
        {
            key: "getManagedElement",
            value: function(d) {
                return this._managedElements[d] ? this._managedElements[d].el: null
            }
        },
        {
            key: "unmanage",
            value: function(d, k) {
                var a = this;
                this.removeAllEndpoints(d, !0);
                var e = function(c) {
                    var h = a.getId(c);
                    a.removeAttribute(c, "data-jtk-managed");
                    delete a._managedElements[h];
                    a.viewport.remove(h);
                    a.fire("element:unmanage", {
                        el: c
                    });
                    c && k && a._removeElement(c)
                };
                this._getAssociatedElements(d).map(e);
                e(d)
            }
        },
        {
            key: "rotate",
            value: function(d, k, a) {
                var e = this.getId(d);
                return this._managedElements[e] && (this._managedElements[e].rotation = k, this.viewport.rotateElement(e, k), !0 !== a) ? this.revalidate(d) : {
                    c: new Set,
                    e: new Set
                }
            }
        },
        {
            key: "_getRotation",
            value: function(d) {
                d = this._managedElements[d];
                return null != d ? d.rotation || 0 : 0
            }
        },
        {
            key: "_getRotations",
            value: function(d) {
                var k = this,
                a = [];
                d = this._managedElements[d];
                var e = function b(h) {
                    null != h.group && (h = k._managedElements[h.group], null != h && (a.push({
                        r: h.viewportElement.r,
                        c: h.viewportElement.c
                    }), b(h)))
                };
                null != d && (a.push({
                    r: d.viewportElement.r || 0,
                    c: d.viewportElement.c
                }), e(d));
                return a
            }
        },
        {
            key: "_applyRotations",
            value: function(d, k) {
                d = d.slice();
                var a = {
                    x: d[0],
                    y: d[1],
                    cr: 0,
                    sr: 0
                };
                P(k,
                function(e) {
                    a = qb(a, e.c, e.r)
                });
                return a
            }
        },
        {
            key: "_applyRotationsXY",
            value: function(d, k) {
                P(k,
                function(a) {
                    d = qb(d, a.c, a.r)
                });
                return d
            }
        },
        {
            key: "_internal_newEndpoint",
            value: function(d) {
                var k = A({},
                d),
                a = this.manage(k.element);
                k.elementId = this.getId(k.element);
                k.id = "ep_" + this._idstamp();
                k = new Ud(this, k);
                null != a && a.endpoints.push(k);
                d.uuid && this.endpointsByUUID.set(d.uuid, k);
                oe(this.endpointsByElement, k.elementId, k);
                this._suspendDrawing || this.paintEndpoint(k, {
                    timestamp: this._suspendedAt
                });
                return k
            }
        },
        {
            key: "_deriveEndpointAndAnchorSpec",
            value: function(d, k) {
                d = ((k ? "": "default ") + d).split(/[\s]/);
                for (var a = k = null,
                e = null,
                c = null,
                h = 0; h < d.length; h++) {
                    var b = this.getConnectionType(d[h]);
                    b && (b.endpoints && (k = b.endpoints), b.endpoint && (a = b.endpoint), b.anchors && (c = b.anchors), b.anchor && (e = b.anchor))
                }
                return {
                    endpoints: k ? k: [a, a],
                    anchors: c ? c: [e, e]
                }
            }
        },
        {
            key: "revalidate",
            value: function(d, k) {
                var a = this.getId(d);
                this.updateOffset({
                    elId: a,
                    recalc: !0,
                    timestamp: k
                });
                return this.repaint(d)
            }
        },
        {
            key: "repaintEverything",
            value: function() {
                var d = fa(),
                k;
                for (k in this._managedElements) this.viewport.refreshElement(k, !0);
                this.viewport.recomputeBounds();
                for (k in this._managedElements) this.repaint(this._managedElements[k].el, d, !0);
                return this
            }
        },
        {
            key: "setElementPosition",
            value: function(d, k, a) {
                var e = this.getId(d);
                this.viewport.setPosition(e, k, a);
                return this.repaint(d)
            }
        },
        {
            key: "repaint",
            value: function(d, k, a) {
                var e = {
                    c: new Set,
                    e: new Set
                },
                c = function(b) {
                    b.c.forEach(function(g) {
                        return e.c.add(g)
                    });
                    b.e.forEach(function(g) {
                        return e.e.add(g)
                    })
                };
                if (!this._suspendDrawing) {
                    var h = this.getId(d);
                    if (null != d) {
                        d = this._getAssociatedElements(d);
                        null == k && (k = fa());
                        if (!a) for (a = 0; a < d.length; a++) this.updateOffset({
                            elId: this.getId(d[a]),
                            recalc: !0,
                            timestamp: k
                        });
                        c(this.router.redraw(h, k, null));
                        if (0 < d.length) for (h = 0; h < d.length; h++) c(this.router.redraw(this.getId(d[h]), k, null))
                    }
                }
                return e
            }
        },
        {
            key: "unregisterEndpoint",
            value: function(d) {
                var k = d.getUuid();
                if (k) this.endpointsByUUID["delete"](k);
                pj(this._managedElements[d.elementId], d);
                for (var a in this.endpointsByElement) {
                    if (k = this.endpointsByElement[a]) {
                        for (var e = [], c = 0, h = k.length; c < h; c++) k[c] !== d && e.push(k[c]);
                        this.endpointsByElement[a] = e
                    }
                    1 > this.endpointsByElement[a].length && delete this.endpointsByElement[a]
                }
                this.fire("internal.endpoint:unregistered", d)
            }
        },
        {
            key: "_maybePruneEndpoint",
            value: function(d) {
                return d.deleteOnEmpty && 0 === d.connections.length ? (this.deleteEndpoint(d), !0) : !1
            }
        },
        {
            key: "deleteEndpoint",
            value: function(d) {
                var k = this,
                a = "string" === typeof d ? this.endpointsByUUID.get(d) : d;
                if (a) {
                    d = a.proxiedBy;
                    var e = a.connections.slice();
                    P(e,
                    function(c) {
                        a.detachFromConnection(c, null, !0)
                    });
                    this.unregisterEndpoint(a);
                    a.destroy();
                    P(e,
                    function(c) {
                        k.deleteConnection(c, {
                            force: !0,
                            endpointToIgnore: a
                        })
                    });
                    null != d && this.deleteEndpoint(d)
                }
                return this
            }
        },
        {
            key: "addEndpoint",
            value: function(d, k, a) {
                a = a || {};
                a = A({},
                a);
                A(a, k || {});
                d = A({
                    element: d
                },
                a);
                return this._internal_newEndpoint(d)
            }
        },
        {
            key: "addEndpoints",
            value: function(d, k, a) {
                for (var e = [], c = 0, h = k.length; c < h; c++) e.push(this.addEndpoint(d, k[c], a));
                return e
            }
        },
        {
            key: "reset",
            value: function() {
                var d = this;
                this.silently(function() {
                    d.endpointsByElement = {};
                    d._managedElements = {};
                    d.endpointsByUUID.clear();
                    d.viewport.reset();
                    d.router.reset();
                    d.groupManager.reset();
                    d.connections.length = 0
                })
            }
        },
        {
            key: "destroy",
            value: function() {
                this.reset();
                this.unbind();
                this.sourceSelectors.length = 0;
                this.targetSelectors.length = 0;
                this._connectionTypes.clear();
                this._endpointTypes.clear()
            }
        },
        {
            key: "getEndpoints",
            value: function(d) {
                return this.endpointsByElement[this.getId(d)] || []
            }
        },
        {
            key: "getEndpoint",
            value: function(d) {
                return this.endpointsByUUID.get(d)
            }
        },
        {
            key: "setEndpointUuid",
            value: function(d, k) {
                if (d.uuid) this.endpointsByUUID["delete"](d.uuid);
                d.uuid = k;
                this.endpointsByUUID.set(k, d)
            }
        },
        {
            key: "connect",
            value: function(d, k) {
                try {
                    var a = this._prepareConnectionParams(d, k),
                    e = this._newConnection(a);
                    this._finaliseConnection(e, a);
                    return e
                } catch(c) {
                    pa(c)
                }
            }
        },
        {
            key: "_prepareConnectionParams",
            value: function(d, k) {
                var a = A({},
                d);
                k && A(a, k);
                a.source && a.source.endpoint && (a.sourceEndpoint = a.source);
                a.target && a.target.endpoint && (a.targetEndpoint = a.target);
                d.uuids && (a.sourceEndpoint = this.getEndpoint(d.uuids[0]), a.targetEndpoint = this.getEndpoint(d.uuids[1]));
                if (null != a.sourceEndpoint) {
                    if (a.sourceEndpoint.isFull()) throw "Cannot establish connection: source endpoint is full";
                    a.type || (a.type = a.sourceEndpoint.edgeType);
                    if (a.sourceEndpoint.connectorOverlays) for (a.overlays = a.overlays || [], d = 0, k = a.sourceEndpoint.connectorOverlays.length; d < k; d++) a.overlays.push(a.sourceEndpoint.connectorOverlays[d]);
                    a.sourceEndpoint.scope && (a.scope = a.sourceEndpoint.scope)
                } else if (null == a.source) throw "Cannot establish connection: source does not exist";
                if (null != a.targetEndpoint) {
                    if (a.targetEndpoint.isFull()) throw "Cannot establish connection: target endpoint is full";
                } else if (null == a.target) throw "Cannot establish connection: target does not exist";
                if (a.sourceEndpoint && a.targetEndpoint) {
                    a: {
                        k = a.targetEndpoint;
                        d = a.sourceEndpoint.scope.split(/\s/);
                        k = k.scope.split(/\s/);
                        for (var e = 0; e < d.length; e++) for (var c = 0; c < k.length; c++) if (k[c] === d[e]) {
                            d = !0;
                            break a
                        }
                        d = !1
                    }
                    if (!d) throw "Cannot establish connection: scopes do not match";
                }
                return a
            }
        },
        {
            key: "_newConnection",
            value: function(d) {
                d.id = "con_" + this._idstamp();
                d = new mc(this, d);
                Dd(d, this._managedElements[d.sourceId], this._managedElements[d.targetId]);
                this.paintConnection(d);
                return d
            }
        },
        {
            key: "_finaliseConnection",
            value: function(d, k, a) {
                k = k || {};
                d.suspendedEndpoint || this.connections.push(d);
                d.pending = null;
                d.endpoints[0].isTemporarySource = !1;
                this.repaint(d.source);
                d = {
                    connection: d,
                    source: d.source,
                    target: d.target,
                    sourceId: d.sourceId,
                    targetId: d.targetId,
                    sourceEndpoint: d.endpoints[0],
                    targetEndpoint: d.endpoints[1]
                };
                this.fire("internal.connection", d, a);
                k.doNotFireConnectionEvent || !1 === k.fireEvent || this.fire("connection", d, a)
            }
        },
        {
            key: "removeAllEndpoints",
            value: function(d, k) {
                var a = this,
                e = function(c) {
                    c = a.getId(c);
                    var h = a.endpointsByElement[c],
                    b;
                    if (h) {
                        var g = 0;
                        for (b = h.length; g < b; g++) a.deleteEndpoint(h[g])
                    }
                    delete a.endpointsByElement[c]
                };
                k && this._getAssociatedElements(d).map(e);
                e(d);
                return this
            }
        },
        {
            key: "_createSourceDefinition",
            value: function(d, k) {
                k = A({},
                k);
                A(k, d);
                k.edgeType = k.edgeType || "default";
                d = this._deriveEndpointAndAnchorSpec(k.edgeType);
                k.endpoint = k.endpoint || d.endpoints[0];
                k.anchor = k.anchor || d.anchors[0];
                d = k.maxConnections || -1;
                return {
                    def: A({},
                    k),
                    uniqueEndpoint: k.uniqueEndpoint,
                    maxConnections: d,
                    enabled: !0,
                    endpoint: null
                }
            }
        },
        {
            key: "addSourceSelector",
            value: function(d, k) {
                var a = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : !1,
                e = this._createSourceDefinition(k);
                a = new Gk(d, e, a);
                this.sourceSelectors.push(a);
                return a
            }
        },
        {
            key: "removeSourceSelector",
            value: function(d) {
                ma(this.sourceSelectors,
                function(k) {
                    return k === d
                })
            }
        },
        {
            key: "removeTargetSelector",
            value: function(d) {
                ma(this.targetSelectors,
                function(k) {
                    return k === d
                })
            }
        },
        {
            key: "addTargetSelector",
            value: function(d, k) {
                var a = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : !1,
                e = this._createTargetDefinition(k);
                a = new Hk(d, e, a);
                this.targetSelectors.push(a);
                return a
            }
        },
        {
            key: "_createTargetDefinition",
            value: function(d, k) {
                k = A({},
                k);
                A(k, d);
                k.edgeType = k.edgeType || "default";
                d = k.maxConnections || -1;
                return {
                    def: A({},
                    k),
                    uniqueEndpoint: k.uniqueEndpoint,
                    maxConnections: d,
                    enabled: !0,
                    endpoint: null
                }
            }
        },
        {
            key: "show",
            value: function(d, k) {
                return this._setVisible(d, "block", k)
            }
        },
        {
            key: "hide",
            value: function(d, k) {
                return this._setVisible(d, "none", k)
            }
        },
        {
            key: "_setVisible",
            value: function(d, k, a) {
                var e = "block" === k;
                k = null;
                a && (k = function(h) {
                    h.setVisible(e, !0, !0)
                });
                var c = this.getId(d);
                this._operation(d,
                function(h) {
                    e && a ? h.endpoints[h.sourceId === c ? 1 : 0].isVisible() && h.setVisible(!0) : h.setVisible(e)
                },
                k);
                return this
            }
        },
        {
            key: "toggleVisible",
            value: function(d, k) {
                var a = null;
                k && (a = function(e) {
                    var c = e.isVisible();
                    e.setVisible(!c)
                });
                this._operation(d,
                function(e) {
                    var c = e.isVisible();
                    e.setVisible(!c)
                },
                a)
            }
        },
        {
            key: "_operation",
            value: function(d, k, a) {
                d = this.getId(d);
                if ((d = this.endpointsByElement[d]) && d.length) for (var e = 0,
                c = d.length; e < c; e++) {
                    for (var h = 0,
                    b = d[e].connections.length; h < b; h++) if (k(d[e].connections[h])) return;
                    a && a(d[e])
                }
            }
        },
        {
            key: "registerConnectionType",
            value: function(d, k) {
                this._connectionTypes.set(d, A({},
                k));
                if (k.overlays) {
                    for (var a = {},
                    e = 0; e < k.overlays.length; e++) {
                        var c = ve(k.overlays[e]);
                        a[c.options.id] = c
                    }
                    this._connectionTypes.get(d).overlays = a
                }
            }
        },
        {
            key: "registerConnectionTypes",
            value: function(d) {
                for (var k in d) this.registerConnectionType(k, d[k])
            }
        },
        {
            key: "registerEndpointType",
            value: function(d, k) {
                this._endpointTypes.set(d, A({},
                k));
                if (k.overlays) {
                    for (var a = {},
                    e = 0; e < k.overlays.length; e++) {
                        var c = ve(k.overlays[e]);
                        a[c.options.id] = c
                    }
                    this._endpointTypes.get(d).overlays = a
                }
            }
        },
        {
            key: "registerEndpointTypes",
            value: function(d) {
                for (var k in d) this.registerEndpointType(k, d[k])
            }
        },
        {
            key: "getType",
            value: function(d, k) {
                return "connection" === k ? this.getConnectionType(d) : this.getEndpointType(d)
            }
        },
        {
            key: "getConnectionType",
            value: function(d) {
                return this._connectionTypes.get(d)
            }
        },
        {
            key: "getEndpointType",
            value: function(d) {
                return this._endpointTypes.get(d)
            }
        },
        {
            key: "importDefaults",
            value: function(d) {
                for (var k in d) this.defaults[k] = d[k];
                d.container && this.setContainer(d.container);
                return this
            }
        },
        {
            key: "restoreDefaults",
            value: function() {
                this.defaults = A({},
                this._initialDefaults);
                return this
            }
        },
        {
            key: "getManagedElements",
            value: function() {
                return this._managedElements
            }
        },
        {
            key: "proxyConnection",
            value: function(d, k, a, e, c) {
                var h = null != d.proxies[k],
                b = h ? d.proxies[k].originalEp.elementId: d.endpoints[k].elementId;
                h = h ? d.proxies[k].originalEp: d.endpoints[k];
                var g = this.getId(a);
                d.proxies[k] ? d.proxies[k].ep.elementId === g ? e = d.proxies[k].ep: (d.proxies[k].ep.detachFromConnection(d, k), e = this._internal_newEndpoint({
                    element: a,
                    endpoint: e(d, k),
                    anchor: c(d, k),
                    parameters: {
                        isProxyEndpoint: !0
                    }
                })) : e = this._internal_newEndpoint({
                    element: a,
                    endpoint: e(d, k),
                    anchor: c(d, k),
                    parameters: {
                        isProxyEndpoint: !0
                    }
                });
                e.deleteOnEmpty = !0;
                d.proxies[k] = {
                    ep: e,
                    originalEp: h
                };
                this.sourceOrTargetChanged(b, g, d, a, k);
                h.detachFromConnection(d, null, !0);
                e.connections = [d];
                d.endpoints[k] = e;
                h.proxiedBy = e;
                h.setVisible(!1);
                d.setVisible(!0);
                this.revalidate(a)
            }
        },
        {
            key: "unproxyConnection",
            value: function(d, k) {
                if (null != d.proxies && null != d.proxies[k]) {
                    var a = d.proxies[k].originalEp.element,
                    e = d.proxies[k].originalEp.elementId,
                    c = d.proxies[k].ep.elementId;
                    d.endpoints[k] = d.proxies[k].originalEp;
                    delete d.proxies[k].originalEp.proxiedBy;
                    this.sourceOrTargetChanged(c, e, d, a, k);
                    d.proxies[k].ep.detachFromConnection(d, null);
                    d.proxies[k].originalEp.addConnection(d);
                    d.isVisible() && d.proxies[k].originalEp.setVisible(!0);
                    d.proxies[k] = null; - 1 === ub(d.proxies,
                    function(h) {
                        return null != h
                    }) && (d.proxies.length = 0)
                }
            }
        },
        {
            key: "sourceOrTargetChanged",
            value: function(d, k, a, e, c) {
                d !== k && (0 === c ? (a.sourceId = k, a.source = e) : 1 === c && (a.targetId = k, a.target = e), Ed(a, this._managedElements[d]), Dd(a, this._managedElements[k]))
            }
        },
        {
            key: "getGroup",
            value: function(d) {
                return this.groupManager.getGroup(d)
            }
        },
        {
            key: "getGroupFor",
            value: function(d) {
                return this.groupManager.getGroupFor(d)
            }
        },
        {
            key: "addGroup",
            value: function(d) {
                return this.groupManager.addGroup(d)
            }
        },
        {
            key: "addToGroup",
            value: function(d) {
                for (var k, a = arguments.length,
                e = Array(1 < a ? a - 1 : 0), c = 1; c < a; c++) e[c - 1] = arguments[c];
                return (k = this.groupManager).addToGroup.apply(k, [d, !1].concat(e))
            }
        },
        {
            key: "collapseGroup",
            value: function(d) {
                this.groupManager.collapseGroup(d)
            }
        },
        {
            key: "expandGroup",
            value: function(d) {
                this.groupManager.expandGroup(d)
            }
        },
        {
            key: "toggleGroup",
            value: function(d) {
                this.groupManager.toggleGroup(d)
            }
        },
        {
            key: "removeGroup",
            value: function(d, k, a, e) {
                return this.groupManager.removeGroup(d, k, a, e)
            }
        },
        {
            key: "removeAllGroups",
            value: function(d, k) {
                this.groupManager.removeAllGroups(d, k, !1)
            }
        },
        {
            key: "removeFromGroup",
            value: function(d, k, a) {
                this.groupManager.removeFromGroup(d, a, k);
                this._appendElement(k, this.getContainer());
                this.updateOffset({
                    recalc: !0,
                    elId: this.getId(k)
                })
            }
        },
        {
            key: "paintEndpoint",
            value: function(d, k) {
                k = k || {};
                var a = k.timestamp,
                e = !1 !== k.recalc;
                if (!a || d.timestamp !== a) {
                    var c = this.viewport.getPosition(d.elementId),
                    h = k.offset ? {
                        x: k.offset.x,
                        y: k.offset.y
                    }: {
                        x: c.x,
                        y: c.y
                    };
                    if (null != h) {
                        var b = k.anchorLoc;
                        if (null == b) {
                            c = {
                                xy: h,
                                wh: c,
                                element: d,
                                timestamp: a
                            };
                            if (e && this.router.isDynamicAnchor(d) && 0 < d.connections.length) {
                                e = 0;
                                if (null != k.elementWithPrecedence) for (h = 0; h < d.connections.length; h++) if (d.connections[h].sourceId === k.elementWithPrecedence || d.connections[h].targetId === k.elementWithPrecedence) {
                                    e = h;
                                    break
                                }
                                k = d.connections[e];
                                e = k.endpoints[0] === d ? 1 : 0;
                                h = 0 === e ? k.sourceId: k.targetId;
                                b = this.viewport.getPosition(h);
                                c.index = 0 === e ? 1 : 0;
                                c.connection = k;
                                c.txy = b;
                                c.twh = b;
                                c.tElement = k.endpoints[e];
                                c.tRotation = this._getRotations(h)
                            } else 0 < d.connections.length && (c.connection = d.connections[0]);
                            c.rotation = this._getRotations(d.elementId);
                            b = this.router.computeAnchorLocation(d._anchor, c)
                        }
                        d.endpoint.compute(b, this.router.getEndpointOrientation(d), d.paintStyleInUse);
                        this.renderEndpoint(d, d.paintStyleInUse);
                        d.timestamp = a;
                        for (var g in d.overlays) d.overlays.hasOwnProperty(g) && (a = d.overlays[g], a.isVisible() && (d.overlayPlacements[g] = this.drawOverlay(a, d.endpoint, d.paintStyleInUse, d.getAbsoluteOverlayPosition(a)), this.paintOverlay(a, d.overlayPlacements[g], {
                            xmin: 0,
                            ymin: 0
                        })))
                    }
                }
            }
        },
        {
            key: "paintConnection",
            value: function(d, k) {
                if (!this._suspendDrawing && !1 !== d.visible && (k = k || {},
                k = k.timestamp, null == k || k !== d.lastPaintedAt)) {
                    if (null == k || k !== d.lastPaintedAt) {
                        this.router.computePath(d, k);
                        var a = Infinity,
                        e = Infinity,
                        c = -Infinity,
                        h = -Infinity;
                        for (g in d.overlays) if (d.overlays.hasOwnProperty(g)) {
                            var b = d.overlays[g];
                            b.isVisible() && (d.overlayPlacements[g] = this.drawOverlay(b, d.connector, d.paintStyleInUse, d.getAbsoluteOverlayPosition(b)), a = Math.min(a, d.overlayPlacements[g].xmin), c = Math.max(c, d.overlayPlacements[g].xmax), e = Math.min(e, d.overlayPlacements[g].ymin), h = Math.max(h, d.overlayPlacements[g].ymax))
                        }
                        var g = parseFloat("" + d.paintStyleInUse.strokeWidth || "1") / 2;
                        b = parseFloat("" + d.paintStyleInUse.strokeWidth || "0");
                        a = {
                            xmin: Math.min(d.connector.bounds.xmin - (g + b), a),
                            ymin: Math.min(d.connector.bounds.ymin - (g + b), e),
                            xmax: Math.max(d.connector.bounds.xmax + (g + b), c),
                            ymax: Math.max(d.connector.bounds.ymax + (g + b), h)
                        };
                        this.paintConnector(d.connector, d.paintStyleInUse, a);
                        for (var m in d.overlays) d.overlays.hasOwnProperty(m) && (e = d.overlays[m], e.isVisible() && this.paintOverlay(e, d.overlayPlacements[m], a))
                    }
                    d.lastPaintedAt = k
                }
            }
        },
        {
            key: "refreshEndpoint",
            value: function(d) {
                0 < d.connections.length ? this.addEndpointClass(d, this.endpointConnectedClass) : this.removeEndpointClass(d, this.endpointConnectedClass);
                d.isFull() ? this.addEndpointClass(d, this.endpointFullClass) : this.removeEndpointClass(d, this.endpointFullClass)
            }
        },
        {
            key: "makeConnector",
            value: function(d, k, a) {
                return bf.get(d, k, a)
            }
        },
        {
            key: "getPathData",
            value: function(d) {
                for (var k = "",
                a = 0; a < d.segments.length; a++) k += d.segments[a].getPath(0 === a),
                k += " ";
                return k
            }
        }]);
        return f
    } (zc),
    df = function(q) {
        function f(d) {
            ja(this, f);
            var k = n.call(this, d);
            x(C(k), "type", f.segmentType);
            x(C(k), "cx", void 0);
            x(C(k), "cy", void 0);
            x(C(k), "radius", void 0);
            x(C(k), "anticlockwise", void 0);
            x(C(k), "startAngle", void 0);
            x(C(k), "endAngle", void 0);
            x(C(k), "sweep", void 0);
            x(C(k), "length", void 0);
            x(C(k), "circumference", void 0);
            x(C(k), "frac", void 0);
            k.cx = d.cx;
            k.cy = d.cy;
            k.radius = d.r;
            k.anticlockwise = d.ac;
            d.startAngle && d.endAngle ? (k.startAngle = d.startAngle, k.endAngle = d.endAngle, k.x1 = k.cx + k.radius * Math.cos(k.startAngle), k.y1 = k.cy + k.radius * Math.sin(k.startAngle), k.x2 = k.cx + k.radius * Math.cos(k.endAngle), k.y2 = k.cy + k.radius * Math.sin(k.endAngle)) : (k.startAngle = k._calcAngle(k.x1, k.y1), k.endAngle = k._calcAngle(k.x2, k.y2));
            0 > k.endAngle && (k.endAngle += jc);
            0 > k.startAngle && (k.startAngle += jc);
            k.sweep = Math.abs((k.endAngle < k.startAngle ? k.endAngle + jc: k.endAngle) - k.startAngle);
            k.anticlockwise && (k.sweep = jc - k.sweep);
            k.circumference = 2 * Math.PI * k.radius;
            k.frac = k.sweep / jc;
            k.length = k.circumference * k.frac;
            k.extents = {
                xmin: k.cx - k.radius,
                xmax: k.cx + k.radius,
                ymin: k.cy - k.radius,
                ymax: k.cy + k.radius
            };
            return k
        }
        xa(f, q);
        var n = ya(f);
        ua(f, [{
            key: "_calcAngle",
            value: function(d, k) {
                var a = {
                    x: this.cx,
                    y: this.cy
                };
                d = {
                    x: d,
                    y: k
                };
                k = bc(a, d);
                k = Math.atan(k);
                a = yd(a, d);
                if (4 == a || 3 == a) k += Math.PI;
                0 > k && (k += 2 * Math.PI);
                return k
            }
        },
        {
            key: "_calcAngleForLocation",
            value: function(d, k) {
                if (d.anticlockwise) {
                    var a = d.startAngle < d.endAngle ? d.startAngle + jc: d.startAngle;
                    return a - Math.abs(a - d.endAngle) * k
                }
                return d.startAngle + Math.abs((d.endAngle < d.startAngle ? d.endAngle + jc: d.endAngle) - d.startAngle) * k
            }
        },
        {
            key: "getPath",
            value: function(d) {
                return (d ? "M" + this.x1 + " " + this.y1 + " ": "") + "A " + this.radius + " " + this.radius + " 0 " + (this.sweep > Math.PI ? 1 : 0) + "," + (this.anticlockwise ? 0 : 1) + " " + this.x2 + " " + this.y2
            }
        },
        {
            key: "getLength",
            value: function() {
                return this.length
            }
        },
        {
            key: "pointOnPath",
            value: function(d, k) {
                if (0 === d) return {
                    x: this.x1,
                    y: this.y1,
                    theta: this.startAngle
                };
                if (1 === d) return {
                    x: this.x2,
                    y: this.y2,
                    theta: this.endAngle
                };
                k && (d /= length);
                d = this._calcAngleForLocation(this, d);
                k = this.cy + this.radius * Math.sin(d);
                return {
                    x: Xf(this.cx + this.radius * Math.cos(d)),
                    y: Xf(k),
                    theta: d
                }
            }
        },
        {
            key: "gradientAtPoint",
            value: function(d, k) {
                d = this.pointOnPath(d, k);
                d = -1 / bc({
                    x: this.cx,
                    y: this.cy
                },
                d);
                this.anticlockwise || Infinity !== d && -Infinity !== d || (d *= -1);
                return d
            }
        },
        {
            key: "pointAlongPathFrom",
            value: function(d, k, a) {
                d = this.pointOnPath(d, a).theta + k / this.circumference * (this.anticlockwise ? -1 : 1) * 2 * Math.PI;
                return {
                    x: this.cx + this.radius * Math.cos(d),
                    y: this.cy + this.radius * Math.sin(d)
                }
            }
        }]);
        return f
    } (Bh);
    x(df, "segmentType", "Arc");
    var Kb = function(q) {
        function f(d, k, a) {
            ja(this, f);
            var e = n.call(this, d, k, a);
            e.instance = d;
            e.component = k;
            x(C(e), "width", void 0);
            x(C(e), "length", void 0);
            x(C(e), "foldback", void 0);
            x(C(e), "direction", void 0);
            x(C(e), "location", .5);
            x(C(e), "paintStyle", void 0);
            x(C(e), "type", f.type);
            x(C(e), "cachedDimensions", void 0);
            a = a || {};
            e.width = a.width || 20;
            e.length = a.length || 20;
            e.direction = 0 > (a.direction || 1) ? -1 : 1;
            e.foldback = a.foldback || .623;
            e.paintStyle = a.paintStyle || {
                strokeWidth: 1
            };
            e.location = null == a.location ? e.location: Array.isArray(a.location) ? a.location[0] : a.location;
            return e
        }
        xa(f, q);
        var n = ya(f);
        ua(f, [{
            key: "draw",
            value: function(d, k, a) {
                if (d instanceof af) {
                    if (1 < this.location || 0 > this.location) {
                        var e = 0 > this.location ? 1 : 0;
                        a = d.pointAlongPathFrom(e, this.location, !1);
                        var c = d.pointAlongPathFrom(e, this.location - this.direction * this.length / 2, !1);
                        e = dc(a, c, this.length)
                    } else 1 === this.location ? (a = d.pointOnPath(this.location), c = d.pointAlongPathFrom(this.location, -this.length), e = dc(a, c, this.length), -1 === this.direction && (c = e, e = a, a = c)) : 0 === this.location ? (e = d.pointOnPath(this.location), c = d.pointAlongPathFrom(this.location, this.length), a = dc(e, c, this.length), -1 === this.direction && (c = e, e = a, a = c)) : (a = d.pointAlongPathFrom(this.location, this.direction * this.length / 2), c = d.pointOnPath(this.location), e = dc(a, c, this.length));
                    c = e;
                    var h = this.width,
                    b = bc(a, c),
                    g = Math.atan( - 1 / b);
                    b = h / 2 * Math.sin(g);
                    h = h / 2 * Math.cos(g);
                    c = [{
                        x: c.x + h,
                        y: c.y + b
                    },
                    {
                        x: c.x - h,
                        y: c.y - b
                    }];
                    e = dc(a, e, this.foldback * this.length);
                    return {
                        component: d,
                        d: {
                            hxy: a,
                            tail: c,
                            cxy: e
                        },
                        "stroke-width": this.paintStyle.strokeWidth || k.strokeWidth,
                        stroke: this.paintStyle.stroke || k.stroke,
                        fill: this.paintStyle.fill || k.stroke,
                        xmin: Math.min(a.x, c[0].x, c[1].x),
                        xmax: Math.max(a.x, c[0].x, c[1].x),
                        ymin: Math.min(a.y, c[0].y, c[1].y),
                        ymax: Math.max(a.y, c[0].y, c[1].y)
                    }
                }
            }
        },
        {
            key: "updateFrom",
            value: function(d) {}
        }]);
        return f
    } (Td);
    x(Kb, "type", "Arrow");
    lc.register(Kb.type, Kb);
    var dd = function(q) {
        function f(d, k, a) {
            ja(this, f);
            k = n.call(this, d, k, a);
            k.instance = d;
            x(C(k), "type", f.type);
            k.foldback = 1;
            return k
        }
        xa(f, q);
        var n = ya(f);
        return f
    } (Kb);
    x(dd, "type", "PlainArrow");
    lc.register("PlainArrow", dd);
    var uc = function(q) {
        function f(d, k, a) {
            ja(this, f);
            k = n.call(this, d, k, a);
            k.instance = d;
            x(C(k), "type", f.type);
            k.length /= 2;
            k.foldback = 2;
            return k
        }
        xa(f, q);
        var n = ya(f);
        return f
    } (Kb);
    x(uc, "type", "Diamond");
    lc.register(uc.type, uc);
    var ye = function(q) {
        function f(d, k, a) {
            ja(this, f);
            var e = n.call(this, d, k, a);
            e.instance = d;
            e.component = k;
            x(C(e), "create", void 0);
            x(C(e), "type", f.type);
            e.create = a.create;
            return e
        }
        xa(f, q);
        var n = ya(f);
        ua(f, [{
            key: "updateFrom",
            value: function(d) {}
        }]);
        return f
    } (Td);
    x(ye, "type", "Custom");
    lc.register("Custom", ye);
    Zb.registerHandler(tk);
    Zb.registerHandler(vk);
    Zb.registerHandler(uk);
    bf.register(Sd.type, Sd);
    var Lk = function() {
        function q(f) {
            ba(this, q);
            B(this, "vertices", void 0);
            this.vertices = [f]
        }
        return ca(q, [{
            key: "addVertex",
            value: function(f) {
                this.vertices.push(f)
            }
        }]),
        q
    } (),
    Ph = function() {
        function q(f) {
            ba(this, q);
            B(this, "nodes", []);
            B(this, "id", void 0);
            B(this, "edges", []);
            B(this, "groups", []);
            B(this, "_nodeMap", new Map);
            B(this, "_edgeMap", new Map);
            B(this, "_groupMap", new Map);
            B(this, "defaultDirected", void 0);
            B(this, "defaultCost", void 0);
            B(this, "_defaultIdFunction", void 0);
            B(this, "typeFunction", void 0);
            B(this, "enableSubgraphs", void 0);
            B(this, "portSeparator", void 0);
            B(this, "_topLevelCache", {});
            f = f || {};
            this.nodes = [];
            this.edges = [];
            this.groups = [];
            this.id = f.id;
            this.defaultDirected = !1 !== f.defaultDirected;
            this.defaultCost = f.defaultCost || 1;
            this._defaultIdFunction = f.defaultIdFunction || cg;
            this.typeFunction = f.typeFunction ||
            function(n) {
                return n.type || "default"
            };
            this.enableSubgraphs = !0 === f.enableSubgraphs;
            this.portSeparator = f.portSeparator || "."
        }
        return ca(q, [{
            key: "_removeFromTopLevelCache",
            value: function(f) {
                delete this._topLevelCache[f.id]
            }
        },
        {
            key: "_addToTopLevelCache",
            value: function(f) {
                this._topLevelCache[f.id] = f
            }
        },
        {
            key: "_clearTopLevelCache",
            value: function() {
                this._topLevelCache = {}
            }
        },
        {
            key: "getIdFunction",
            value: function() {
                return this._defaultIdFunction
            }
        },
        {
            key: "setIdFunction",
            value: function(f) {
                this._defaultIdFunction = f
            }
        },
        {
            key: "setTypeFunction",
            value: function(f) {
                this.typeFunction = f
            }
        },
        {
            key: "getType",
            value: function(f) {
                return this.typeFunction(f)
            }
        },
        {
            key: "getId",
            value: function(f, n) {
                return null == f ? fa() : "string" == typeof f ? f: (n || this.getIdFunction())(f) || fa()
            }
        },
        {
            key: "getTopLevelElements",
            value: function() {
                return this._topLevelCache
            }
        },
        {
            key: "setEnableSubgraphs",
            value: function(f) {
                this.enableSubgraphs = f
            }
        },
        {
            key: "setPortSeparator",
            value: function(f) {
                this.portSeparator = f
            }
        },
        {
            key: "getPortSeparator",
            value: function() {
                return this.portSeparator
            }
        },
        {
            key: "splitPortId",
            value: function(f) {
                return null != f ? f.split(this.portSeparator) : []
            }
        },
        {
            key: "getVertexByPortId",
            value: function(f) {
                f = this.splitPortId(f);
                if (2 === f.length) return this._nodeMap.get(f[0]) || this._groupMap.get(f[0])
            }
        },
        {
            key: "getVertex",
            value: function(f, n) {
                var d, k = this;
                if (null == f) return null;
                if ("string" != typeof f && (f.constructor === oa || f.constructor === Pa || f.constructor === cb || "string" != typeof(d = this._defaultIdFunction(f)))) return f;
                d = f;
                f = this.enableSubgraphs ? d.split("/") : [d];
                d = function(c) {
                    if (k._nodeMap.has(c)) return k._nodeMap.get(c);
                    if (k._groupMap.has(c)) return k._groupMap.get(c);
                    c = c.split(k.portSeparator);
                    var h = c[0];
                    h = k._nodeMap.get(h) || k._groupMap.get(h);
                    if (2 === c.length && null != h) {
                        var b = h.getPort(c[1]);
                        return null == b && n && (b = h.addPort(c[1])),
                        b
                    }
                    return h
                };
                if (1 == f.length) return d(f[0]);
                if (1 < f.length && 0 == f.length % 2) throw "Subgraph path format error.";
                for (var a = null,
                e = 0; e < f.length - 1; e += 2) a = d(f[e]).getGraph(f[e + 1]);
                return a.getVertex(f[f.length - 1])
            }
        },
        {
            key: "clear",
            value: function() {
                this.nodes.length = 0;
                this.groups.length = 0;
                this._nodeMap.clear();
                this._edgeMap.clear();
                this._groupMap.clear();
                this._clearTopLevelCache()
            }
        },
        {
            key: "getVertices",
            value: function() {
                return this.nodes
            }
        },
        {
            key: "getVertexCount",
            value: function() {
                return this.nodes.length
            }
        },
        {
            key: "getVertexAt",
            value: function(f) {
                return this.nodes[f]
            }
        },
        {
            key: "getEdgeCount",
            value: function() {
                return this._edgeMap.size
            }
        },
        {
            key: "addEdge",
            value: function(f, n, d) {
                var k = null == f.directed ? !0 === this.defaultDirected: !1 !== f.directed,
                a = f.cost || this.defaultCost;
                n = this.getId(f.data, n);
                var e = this.getVertex(f.source, !0),
                c = this.getVertex(f.target, !0);
                if (null == e || null == e.objectType) throw new TypeError("Unknown source node [" + f.source + "]");
                if (null == c || null == c.objectType) throw new TypeError("Unknown target node [" + f.target + "]");
                if (d && !d(e, c)) return null;
                d = new ab({
                    source: e,
                    target: c,
                    cost: a,
                    directed: k,
                    data: f.data || {},
                    id: n,
                    graph: this
                });
                return d.source.addEdge(d),
                d.source !== d.target && d.target.addEdge(d),
                this._edgeMap.set(n, d),
                null != f.geometry && (d.geometry = f.geometry),
                d
            }
        },
        {
            key: "addNode",
            value: function(f, n) {
                f = new Pa(this, f, n || this._defaultIdFunction);
                return this._nodeMap.has(f.id) ? null: (this.nodes.push(f), this._nodeMap.set(f.id, f), f._id = this._nodeMap.size, this._addToTopLevelCache(f), f)
            }
        },
        {
            key: "addNodes",
            value: function(f, n) {
                for (var d = 0; d < f.length; d++) this.addNode(f[d], n || this._defaultIdFunction)
            }
        },
        {
            key: "addGroup",
            value: function(f, n) {
                f = new cb(this, f, n || this._defaultIdFunction);
                return this._groupMap.has(f.id) ? this._groupMap.get(f.id) : (this.groups.push(f), this._groupMap.set(f.id, f), f._id = this._groupMap.size, this._addToTopLevelCache(f), f)
            }
        },
        {
            key: "getGroupCount",
            value: function() {
                return this.groups.length
            }
        },
        {
            key: "getGroupAt",
            value: function(f) {
                return this.groups[f]
            }
        },
        {
            key: "getGroups",
            value: function() {
                return this.groups
            }
        },
        {
            key: "addMemberToGroup",
            value: function(f, n) {
                n = "string" == typeof n ? this._groupMap.get(n) : n; (f = this.getVertex(f)) && n && (n.addMember(f), this._removeFromTopLevelCache(f))
            }
        },
        {
            key: "addMembersToGroup",
            value: function(f, n) {
                for (var d = 0; d < f.length; d++) this.addMemberToGroup(f[d], n)
            }
        },
        {
            key: "removeMemberFromGroup",
            value: function(f) { (f = this.getVertex(f)) && f.group && (f.group.removeMember(f), this._addToTopLevelCache(f))
            }
        },
        {
            key: "removeMembersFromGroup",
            value: function(f) {
                for (var n = 0; n < f.length; n++) this.removeMemberFromGroup(f[n])
            }
        },
        {
            key: "getGroup",
            value: function(f) {
                return "string" == typeof f ? this._groupMap.get(f) : f
            }
        },
        {
            key: "deleteGroup",
            value: function(f, n) {
                var d = this,
                k = {
                    group: "string" == typeof f ? this._groupMap.get(f) : f,
                    edges: [],
                    nodes: [],
                    nestedGroups: [],
                    children: []
                };
                if (k.group) {
                    if (k.parentGroup = k.group.group, k.children = k.group.members.slice(), n) {
                        n = sj(k.group.getMembers(),
                        function(e) {
                            return ra(e)
                        });
                        var a = n.right;
                        n.left.forEach(function(e) {
                            k.nestedGroups.push(d.deleteGroup(e, !0))
                        });
                        a.forEach(function(e) {
                            k.nodes.push(d.deleteNode(e))
                        })
                    } else k.group.getMembers().forEach(function(e) {
                        return delete e.group
                    });
                    k.group.members.length = 0;
                    k.edges = k.group.getAllDirectEdges().slice();
                    a = k.edges.length;
                    for (n = 0; n < a; n++) this.deleteEdge(k.edges[0]);
                    n = k.group.getPorts();
                    for (a = 0; a < n.length; a++) this.deletePort(n[a]);
                    this._groupMap.delete(k.group.id);
                    n = -1;
                    for (a = 0; a < this.groups.length; a++) if (this.groups[a].id === k.group.id) {
                        n = a;
                        break
                    } - 1 < n && this.groups.splice(n, 1);
                    null != k.group.group && k.group.group.removeMember(f);
                    this._removeFromTopLevelCache(k.group)
                }
                return k
            }
        },
        {
            key: "deletePort",
            value: function(f) {
                f = f.getEdges();
                for (var n = 0; n < f.length; n++) this.deleteEdge(f[n]);
                return f
            }
        },
        {
            key: "deleteNode",
            value: function(f) {
                f = this.getVertex(f);
                var n = {
                    node: null,
                    edges: [],
                    parentGroup: null
                };
                if (f) {
                    n.node = f;
                    n.parentGroup = f.group;
                    for (var d = f.getPorts(), k = 0; k < d.length; k++) this.deletePort(d[k]);
                    d = -1;
                    for (k = 0; k < this.nodes.length; k++) if (this.nodes[k].id === f.id) {
                        d = k;
                        break
                    } - 1 < d && (this.nodes.splice(d, 1), null != f.group && f.group.removeMember(f));
                    n.edges = f.getEdges().slice();
                    for (d = 0; d < n.edges.length; d++) this.deleteEdge(n.edges[d]);
                    this._nodeMap.delete(f.getFullId());
                    this._removeFromTopLevelCache(f)
                }
                return n
            }
        },
        {
            key: "deleteEdge",
            value: function(f) {
                if (null != (f = this.getEdge(f))) {
                    var n = this.getVertex(f.source);
                    n && n.deleteEdge(f); (n = this.getVertex(f.target)) && n.deleteEdge(f);
                    this._edgeMap.delete(f.getId())
                }
            }
        },
        {
            key: "getEdge",
            value: function(f) {
                if (null != f) {
                    if ("string" != typeof f) {
                        if (f.constructor === ab) return f;
                        var n = f;
                        if ("string" != typeof(f = this._defaultIdFunction(f))) return n
                    }
                    return this._edgeMap.get(f)
                }
            }
        },
        {
            key: "getEdges",
            value: function(f) {
                var n, d = null != (f = f || {}).source,
                k = null != f.target,
                a = f.node ? this.getVertex(f.node) : null,
                e = f.filter ||
                function() {
                    return ! 0
                },
                c = [],
                h = function(g) { ! e(g) || d && (!0 === f.source ? g.source !== a: g.source === a) || k && (!0 === f.target ? g.target !== a: g.target === a) || c.push(g)
                };
                if (f.node) {
                    var b = this.getVertex(f.node).getAllEdges();
                    for (n = 0; n < b.length; n++) h(b[n])
                } else this._edgeMap.forEach(function(g, m) {
                    return h(g)
                });
                return c
            }
        },
        {
            key: "getAllEdges",
            value: function() {
                var f = [];
                return this._edgeMap.forEach(function(n, d) {
                    return f.push(n)
                }),
                f
            }
        },
        {
            key: "renamePort",
            value: function(f, n) {
                return !! f.getParent().renamePort(f, n) && (f.id = n, !0)
            }
        },
        {
            key: "getAncestors",
            value: function(f) {
                var n = [];
                for (f = f.group; null != f;) n.push(f),
                f = f.group;
                return n
            }
        },
        {
            key: "isAncestor",
            value: function(f, n) {
                return null != f && null != n && -1 !== this.getAncestors(f).indexOf(n)
            }
        },
        {
            key: "findPath",
            value: function(f, n, d, k, a) {
                return Ae({
                    graph: this,
                    source: this.getVertex(f),
                    target: this.getVertex(n),
                    strict: !1 !== d,
                    nodeFilter: k,
                    edgeFilter: a
                })
            }
        },
        {
            key: "getDistance",
            value: function(f, n, d) {
                return this.findPath(f, n, d).pathDistance
            }
        },
        {
            key: "setTarget",
            value: function(f, n) {
                n = this.getVertex(n);
                if (null == n) return {
                    success: !1
                };
                var d = f.target;
                return f.target.deleteEdge(f),
                f.target = n,
                n.addEdge(f),
                {
                    old: d,
                    edge: f,
                    new: n,
                    success: !0
                }
            }
        },
        {
            key: "setSource",
            value: function(f, n) {
                n = this.getVertex(n);
                if (null == n) return {
                    success: !1
                };
                var d = f.source;
                return f.source.deleteEdge(f),
                f.source = n,
                n.addEdge(f),
                {
                    old: d,
                    edge: f,
                    new: n,
                    success: !0
                }
            }
        },
        {
            key: "printPath",
            value: function(f, n) {
                f = this.getVertex(f);
                var d = this.getVertex(n);
                n = this.findPath(f, d).path;
                f = "[" + f.id + " - " + d.id + "] : ";
                for (d = 0; d < n.length; d++) f = f + "{ vertex:" + n[d].vertex.id + ", cost:" + n[d].cost + ", edge: " + (n[d].edge && n[d].edge.getId()) + " } ";
                return f
            }
        },
        {
            key: "getDiameter",
            value: function(f) {
                for (var n = 0,
                d = 0; d < this.nodes.length; d++) for (var k = 0; k < this.nodes.length; k++) if (k != d) {
                    var a = Ae({
                        graph: this,
                        source: this.nodes[d],
                        target: this.nodes[k]
                    });
                    if (null == a.path || 0 == a.path.length) {
                        if (!f) return 1 / 0
                    } else n = Math.max(n, a.pathDistance)
                }
                return n
            }
        },
        {
            key: "getCentrality",
            value: function(f) {
                f = this.getVertex(f);
                return (f.getIndegreeCentrality() + f.getOutdegreeCentrality()) / (this.getVertexCount() - 1)
            }
        },
        {
            key: "getIndegreeCentrality",
            value: function(f) {
                return this.getVertex(f).getIndegreeCentrality() / (this.getVertexCount() - 1)
            }
        },
        {
            key: "getOutdegreeCentrality",
            value: function(f) {
                return this.getVertex(f).getOutdegreeCentrality() / (this.getVertexCount() - 1)
            }
        },
        {
            key: "getCloseness",
            value: function(f) {
                return 1 / this.getFarness(f)
            }
        },
        {
            key: "getFarness",
            value: function(f) {
                f = this.getVertex(f);
                f = Ae({
                    graph: this,
                    source: f,
                    target: f,
                    processAll: !0
                });
                var n = 0,
                d;
                for (d in f.dist) n += f.dist[d];
                return n / (this.getVertexCount() - 1)
            }
        },
        {
            key: "getBetweenness",
            value: function(f) {
                var n = this.getVertexCount();
                n = (n - 1) * (n - 2) / 2;
                var d = 0,
                k = function y(t, u, v, w, z) {
                    u = v.parents[t][u];
                    if (0 == u.length) v = w.slice(),
                    v.unshift(t),
                    z.push(v);
                    else for (var E = 0; E < u.length; E++) if ( - 1 == w.indexOf(u[E][0].id)) {
                        var F = w.slice();
                        F.unshift(u[E][0].id);
                        y(t, u[E][0].id, v, F, z)
                    }
                };
                f = this.getVertex(f);
                var a = rj({
                    graph: this,
                    focus: f
                }),
                e;
                for (e in a.paths) for (var c in a.paths[e]) if (e != c) {
                    var h = [],
                    b = 0;
                    k(e, c, a, [c], h);
                    for (var g = 0; g < h.length; g++) {
                        var m = h[g].indexOf(f.id);
                        0 < m && m < h[g].length - 1 && b++
                    }
                    d += b / h.length
                }
                return d / n
            }
        },
        {
            key: "inspect",
            value: function() {
                for (var f = "",
                n = 0; n < this.nodes.length; n++) f += this.nodes[n].inspect() + "\n";
                return f
            }
        },
        {
            key: "serialize",
            value: function() {
                for (var f, n, d, k = {
                    nodes: [],
                    edges: [],
                    ports: [],
                    groups: []
                },
                a = 0; a < this.nodes.length; a++) {
                    f = this.nodes[a];
                    k.nodes.push(f.data);
                    n = f.getAllEdges();
                    d = f.getPorts();
                    for (var e = 0; e < n.length; e++) if (n[e].source == f || "Port" === n[e].source.objectType && n[e].source.getParent() == f) {
                        var c = {
                            source: n[e].source.getFullId(),
                            target: n[e].target.getFullId()
                        };
                        n[e].data && (c.data = n[e].data);
                        n[e].geometry && (c.geometry = n[e].geometry);
                        k.edges.push(c)
                    }
                    for (n = 0; n < d.length; n++) {
                        f = {};
                        for (var h in d[n].data) f[h] = d[n].data[h];
                        f.id = d[n].getFullId();
                        k.ports.push(f)
                    }
                }
                for (a = 0; a < this.groups.length; a++) for (d = this.groups[a], k.groups.push(d.data), n = d.getEdges(), h = 0; h < n.length; h++) n[h].source === d && (f = {
                    source: d.getFullId(),
                    target: n[h].target.getFullId()
                },
                n[h].data && (f.data = n[h].data), k.edges.push(f));
                return k
            }
        },
        {
            key: "getClusters",
            value: function() {
                var f, n = [],
                d = {},
                k = function h(e, c) {
                    if (null != e && !d[e.id]) {
                        null == c ? (c = new Lk(e), n.push(c)) : c.addVertex(e);
                        d[e.id] = !0;
                        for (var b = e.getAllEdges(), g = 0; g < b.length; g++) h(b[g].source === e ? b[g].target: b[g].source, c)
                    }
                };
                for (f = 0; f < this.nodes.length; f++) k(this.nodes[f]);
                for (f = 0; f < this.groups.length; f++) k(this.groups[f]);
                return n
            }
        }]),
        q
    } (),
    Qh = function() {
        function q(f, n) {
            ba(this, q);
            this.graph = f;
            this.data = n;
            B(this, "atts", new Map);
            B(this, "type", void 0);
            B(this, "objectType", void 0);
            this.data = this.data || {};
            this.type = f.getType(this.data)
        }
        return ca(q, [{
            key: "setAttribute",
            value: function(f, n) {
                this.atts.set(f, n)
            }
        },
        {
            key: "getAttribute",
            value: function(f) {
                return this.atts.get(f)
            }
        },
        {
            key: "getType",
            value: function() {
                return this.type
            }
        },
        {
            key: "setType",
            value: function(f) {
                this.type = f
            }
        }]),
        q
    } (),
    Rh = function(q) {
        function f(d, k, a) {
            var e;
            return ba(this, f),
            (e = n.call(this, d, k)).graph = d,
            e.idFunction = a,
            B(L(e), "id", void 0),
            B(L(e), "_id", void 0),
            B(L(e), "data", void 0),
            B(L(e), "edges", []),
            B(L(e), "indegreeCentrality", 0),
            B(L(e), "outdegreeCentrality", 0),
            B(L(e), "nestedGraphs", []),
            B(L(e), "graphs", []),
            e.id = d.getId(k, a),
            e.data = "string" == typeof k ? {
                id: k
            }: k,
            e
        }
        Fa(f, Qh);
        var n = Ga(f);
        return ca(f, [{
            key: "getIndegreeCentrality",
            value: function() {
                return this.indegreeCentrality
            }
        },
        {
            key: "getOutdegreeCentrality",
            value: function() {
                return this.outdegreeCentrality
            }
        },
        {
            key: "addGraph",
            value: function(d) {
                return d = "string" == typeof d ? new Ph({
                    id: d
                }) : d,
                this.graphs.push(d),
                d.id || (d.id = "" + this.graphs.length),
                d
            }
        },
        {
            key: "getGraph",
            value: function(d) {
                for (var k = 0; k < this.graphs.length; k++) if (this.graphs[k].id === d) return this.graphs[k]
            }
        },
        {
            key: "getFullId",
            value: function() {
                return this.id
            }
        },
        {
            key: "getEdges",
            value: function(d) {
                if (null == d || null == d.filter) return this.edges;
                for (var k = [], a = 0; a < this.edges.length; a++) d.filter(this.edges[a]) && k.push(this.edges[a]);
                return k
            }
        },
        {
            key: "getAllEdges",
            value: function(d) {
                return this.getEdges(d)
            }
        },
        {
            key: "getSourceEdges",
            value: function() {
                var d = this;
                return this.getEdges({
                    filter: function(k) {
                        return k.source == d
                    }
                })
            }
        },
        {
            key: "getTargetEdges",
            value: function() {
                var d = this;
                return this.getEdges({
                    filter: function(k) {
                        return k.target == d
                    }
                })
            }
        },
        {
            key: "addEdge",
            value: function(d) {
                this.edges.push(d);
                d.source !== this && d.isDirected() || this.outdegreeCentrality++;
                d.target !== this && d.isDirected() || this.indegreeCentrality++
            }
        },
        {
            key: "deleteEdge",
            value: function(d) {
                for (var k = -1,
                a = 0; a < this.edges.length; a++) if (this.edges[a].getId() === d.getId()) {
                    k = a;
                    break
                }
                return - 1 < k && (this.edges.splice(k, 1), d.source !== this && d.isDirected() || this.outdegreeCentrality--, d.target !== this && d.isDirected() || this.indegreeCentrality--, !0)
            }
        },
        {
            key: "inspect",
            value: function() {
                for (var d = "{ id:" + this.id + ", edges:[\n",
                k = 0; k < this.edges.length; k++) d += this.edges[k].inspect() + "\n";
                return d + "]}"
            }
        },
        {
            key: "isChildOf",
            value: function(d) {
                return ! 1
            }
        }]),
        f
    } (),
    Pa = function(q) {
        function f(d, k, a) {
            var e;
            return ba(this, f),
            B(L(e = n.call(this, d, k, a)), "objectType", f.objectType),
            B(L(e), "ports", []),
            B(L(e), "group", void 0),
            B(L(e), "portMap", {}),
            B(L(e), "defaultInternalCost", 0),
            B(L(e), "internalEdges", {}),
            e
        }
        Fa(f, Rh);
        var n = Ga(f);
        return ca(f, [{
            key: "getAllEdges",
            value: function(d) {
                for (var k = this.getEdges(d).slice(0), a = 0; a < this.ports.length; a++) k.push.apply(k, this.ports[a].getEdges(d));
                return k
            }
        },
        {
            key: "getAllSourceEdges",
            value: function() {
                for (var d = this.getSourceEdges().slice(0), k = 0; k < this.ports.length; k++) d.push.apply(d, this.ports[k].getSourceEdges());
                return d
            }
        },
        {
            key: "getAllTargetEdges",
            value: function() {
                for (var d = this.getTargetEdges().slice(0), k = 0; k < this.ports.length; k++) d.push.apply(d, this.ports[k].getTargetEdges());
                return d
            }
        },
        {
            key: "getDirectEdges",
            value: function(d) {
                return this.getEdges(d)
            }
        },
        {
            key: "getDirectSourceEdges",
            value: function() {
                return this.getSourceEdges()
            }
        },
        {
            key: "getDirectTargetEdges",
            value: function() {
                return this.getTargetEdges()
            }
        },
        {
            key: "getPortEdges",
            value: function(d) {
                for (var k = [], a = 0; a < this.ports.length; a++) k.push.apply(k, this.ports[a].getEdges(d));
                return k
            }
        },
        {
            key: "getPortSourceEdges",
            value: function() {
                for (var d = [], k = 0; k < this.ports.length; k++) d.push.apply(d, this.ports[k].getSourceEdges());
                return d
            }
        },
        {
            key: "getPortTargetEdges",
            value: function() {
                for (var d = [], k = 0; k < this.ports.length; k++) d.push.apply(d, this.ports[k].getTargetEdges());
                return d
            }
        },
        {
            key: "getIndegreeCentrality",
            value: function() {
                for (var d = 0,
                k = 0; k < this.ports.length; k++) d += this.ports[k].getIndegreeCentrality();
                return this.indegreeCentrality + d
            }
        },
        {
            key: "getOutdegreeCentrality",
            value: function() {
                for (var d = 0,
                k = 0; k < this.ports.length; k++) d += this.ports[k].getOutdegreeCentrality();
                return this.outdegreeCentrality + d
            }
        },
        {
            key: "getPorts",
            value: function() {
                return this.ports
            }
        },
        {
            key: "addPort",
            value: function(d, k) {
                var a = this.graph.getId(d, k);
                a = this.getPort(a);
                return null == a && (a = new oa(this, d, k), this.ports.push(a), this.portMap[a.id] = a),
                a
            }
        },
        {
            key: "setPort",
            value: function(d, k) {
                var a = this.getPort(d);
                return a || (a = this.addPort({
                    id: d
                })),
                a.data = k,
                a.setType(this.graph.getType(k)),
                a
            }
        },
        {
            key: "getPort",
            value: function(d) {
                return this.portMap[d]
            }
        },
        {
            key: "_portId",
            value: function(d) {
                return d instanceof oa ? d.id: d
            }
        },
        {
            key: "renamePort",
            value: function(d, k) {
                return !! this.portMap[d.id] && (this.portMap[k] = this.portMap[d.id], delete this.portMap[d.id], !0)
            }
        },
        {
            key: "removePort",
            value: function(d) {
                var k = !1;
                if (d) {
                    d = this._portId(d);
                    for (var a = -1,
                    e = 0; e < this.ports.length; e++) if (this.ports[e].id === d) {
                        a = e;
                        break
                    } - 1 != a && (this.graph.deletePort(this.ports[a]), this.ports.splice(a, 1), k = !0);
                    delete this.portMap[d]
                }
                return k
            }
        },
        {
            key: "setDefaultInternalCost",
            value: function(d) {
                this.defaultInternalCost = d
            }
        },
        {
            key: "getInternalEdge",
            value: function(d, k) {
                d = this._portId(d);
                var a = this._portId(k);
                k = {
                    source: this.portMap[d],
                    target: this.portMap[a],
                    cost: 1 / 0
                };
                if (k.source && k.target) {
                    d = this.internalEdges[d + "-" + a] || {
                        cost: this.defaultInternalCost,
                        directed: !1
                    };
                    for (var e in d) k[e] = d[e]
                }
                return k
            }
        },
        {
            key: "setInternalEdge",
            value: function(d, k, a, e) {
                var c = this._portId(d),
                h = this._portId(k);
                return this.internalEdges[c + "-" + h] = {
                    cost: a || this.defaultInternalCost,
                    directed: e
                },
                this.getInternalEdge(d, k)
            }
        }]),
        f
    } ();
    B(Pa, "objectType", "Node");
    var oa = function(q) {
        function f(d, k, a) {
            var e;
            return ba(this, f),
            (e = n.call(this, d.graph, k, a)).parent = d,
            B(L(e), "objectType", f.objectType),
            e
        }
        Fa(f, Rh);
        var n = Ga(f);
        return ca(f, [{
            key: "getParent",
            value: function() {
                return this.parent
            }
        },
        {
            key: "getFullId",
            value: function() {
                return this.parent.id + this.graph.getPortSeparator() + this.id
            }
        },
        {
            key: "isChildOf",
            value: function(d) {
                return this.parent === d
            }
        }]),
        f
    } ();
    B(oa, "objectType", "Port");
    var cb = function(q) {
        function f(d, k, a) {
            var e;
            return ba(this, f),
            B(L(e = n.call(this, d, k, a)), "objectType", f.objectType),
            B(L(e), "members", []),
            B(L(e), "_memberMap", {}),
            e
        }
        Fa(f, Pa);
        var n = Ga(f);
        return ca(f, [{
            key: "addMember",
            value: function(d) {
                return null == this._memberMap[d.id] && (this.members.push(d), this._memberMap[d.id] = d, d.group = this, !0)
            }
        },
        {
            key: "getMemberCount",
            value: function() {
                return this.members.length
            }
        },
        {
            key: "getMembers",
            value: function() {
                return this.members
            }
        },
        {
            key: "removeMember",
            value: function(d) {
                if (d = "string" == typeof d ? this._memberMap[d] : d) {
                    var k = this.members.indexOf(d);
                    return - 1 != k && (this.members.splice(k, 1), delete this._memberMap[d.id]),
                    delete d.group,
                    !0
                }
                return ! 1
            }
        },
        {
            key: "getAllDirectEdges",
            value: function(d) {
                var k, a = [];
                a.push.apply(a, this.getEdges(d).slice(0));
                var e = this.getPorts();
                for (k = 0; k < e.length; k++) a.push.apply(a, e[k].getEdges(d));
                return a
            }
        },
        {
            key: "getAllEdges",
            value: function(d) {
                for (var k = [], a = {},
                e = 0; e < this.members.length; e++) Array.prototype.push.apply(k, this.members[e].getAllEdges(d).filter(function(c) {
                    c = c.getId();
                    var h = null == a[c];
                    return a[c] = !0,
                    h
                }));
                return k.push.apply(k, this.getAllDirectEdges(d)),
                k
            }
        }]),
        f
    } ();
    B(cb, "objectType", "Group");
    var ab = function(q) {
        function f(d) {
            var k;
            return ba(this, f),
            B(L(k = n.call(this, d.graph, d.data)), "objectType", f.objectType),
            B(L(k), "source", void 0),
            B(L(k), "target", void 0),
            B(L(k), "cost", void 0),
            B(L(k), "directed", void 0),
            B(L(k), "id", void 0),
            B(L(k), "connectionId", void 0),
            B(L(k), "geometry", void 0),
            k.source = d.source,
            k.target = d.target,
            k.cost = d.cost || 1,
            k.directed = !1 !== d.directed,
            k.id = d.id,
            k
        }
        Fa(f, Qh);
        var n = Ga(f);
        return ca(f, [{
            key: "getCost",
            value: function() {
                return this.cost
            }
        },
        {
            key: "setCost",
            value: function(d) {
                this.cost = d
            }
        },
        {
            key: "getId",
            value: function() {
                return null == this.id ? this.source.id + "_" + this.target.id: this.id
            }
        },
        {
            key: "getFullId",
            value: function() {
                return this.getId()
            }
        },
        {
            key: "setId",
            value: function(d) {
                this.id = d
            }
        },
        {
            key: "isDirected",
            value: function() {
                return this.directed
            }
        },
        {
            key: "setDirected",
            value: function(d) {
                this.directed = d
            }
        },
        {
            key: "inspect",
            value: function() {
                if (null != this.id) return "{ id:" + this.id + ", connectionId:" + this.connectionId + ", cost:" + this.cost + ", directed:" + this.directed + ", source:" + this.source.id + ", target:" + this.target.id + "}"
            }
        }]),
        f
    } ();
    B(ab, "objectType", "Edge");
    var Mk = function() {
        function q(f, n) {
            if (ba(this, q), this.toolkit = f, B(this, "nodeDefinitions", new Map), B(this, "groupDefinitions", new Map), B(this, "portDefinitions", new Map), null != n) {
                f = n.nodes || {};
                for (var d in f) this.nodeDefinitions.set(d, f[d]);
                d = n.groups || {};
                for (var k in d) this.groupDefinitions.set(k, d[k]);
                n = n.ports || {};
                for (var a in n) this.portDefinitions.set(a, n[a])
            }
        }
        return ca(q, [{
            key: "getNodeDefinition",
            value: function(f) {
                return this.nodeDefinitions.get(f) || {}
            }
        },
        {
            key: "getGroupDefinition",
            value: function(f) {
                return this.groupDefinitions.get(f) || {}
            }
        },
        {
            key: "getPortDefinition",
            value: function(f) {
                return this.portDefinitions.get(f) || {}
            }
        }]),
        q
    } (),
    Sh = function() {
        function q(f, n) {
            ba(this, q);
            this.toolkit = f;
            B(this, "result", void 0);
            B(this, "vertices", []);
            B(this, "vertexMap", {});
            this.result = f.getGraph().findPath(n.source, n.target, n.strict, n.nodeFilter, n.edgeFilter);
            for (f = 0; f < this.result.path.length; f++) this.vertices.push(this.result.path[f].vertex),
            this.vertexMap[this.result.path[f].vertex.getFullId()] = [this.result.path[f].vertex, f]
        }
        return ca(q, [{
            key: "deleteEdges",
            value: function() {
                for (var f = 0; f < this.result.path.length; f++) this.result.path[f].edge && this.toolkit.removeEdge(this.result.path[f].edge);
                return this
            }
        },
        {
            key: "deleteVertices",
            value: function() {
                for (var f = 0; f < this.result.path.length; f++) this.toolkit.removeNode(this.result.path[f].vertex);
                return this
            }
        },
        {
            key: "contains",
            value: function(f, n) {
                f = this.toolkit.findGraphObject(f);
                var d = !1;
                if (f) for (var k = 0; k < this.result.path.length; k++) if (this.result.path[k].vertex == f || this.result.path[k].edge == f || !n && this.result.path[k].vertex.objectType == oa.objectType && this.result.path[k].vertex.isChildOf(f)) {
                    d = !0;
                    break
                }
                return d
            }
        },
        {
            key: "getVertices",
            value: function() {
                return this.vertices
            }
        },
        {
            key: "getVertex",
            value: function(f) {
                return this.vertexMap["string" == typeof f ? f: f.id][0]
            }
        },
        {
            key: "getAllEdgesFor",
            value: function(f) {
                f = this.vertexMap[f.id][1];
                return f < this.result.path.length - 1 ? [this.result.path[f + 1].edge] : []
            }
        },
        {
            key: "filter",
            value: function(f, n) {
                console.log("not implemented.")
            }
        },
        {
            key: "_each",
            value: function(f, n) {
                for (n = n || 0; n < this.result.path.length; n++) try {
                    f(n, this.result.path[n])
                } catch(d) {
                    console.log("Path iterator function failed", d)
                }
            }
        },
        {
            key: "each",
            value: function(f) {
                this._each(function(n, d) {
                    f(n, d)
                })
            }
        },
        {
            key: "eachVertex",
            value: function(f) {
                this._each(function(n, d) {
                    f(n, d.vertex)
                })
            }
        },
        {
            key: "eachEdge",
            value: function(f) {
                this._each(function(n, d) {
                    f(n, d.edge)
                },
                1)
            }
        },
        {
            key: "eachNode",
            value: function(f) {
                this._each(function(n, d) {
                    ka(d.vertex) && f(n, d.vertex)
                })
            }
        },
        {
            key: "eachGroup",
            value: function(f) {
                this._each(function(n, d) {
                    ra(d.vertex) && f(n, d.vertex)
                })
            }
        },
        {
            key: "getVertexCount",
            value: function() {
                return this.result.path.length
            }
        },
        {
            key: "getNodeAt",
            value: function(f) {
                return this.result.path[f].vertex
            }
        },
        {
            key: "getEdgeCount",
            value: function() {
                return 0 == this.result.path.length ? 0 : this.result.path.length - 1
            }
        },
        {
            key: "getEdgeAt",
            value: function(f) {
                return 0 > f && (f = this.result.path.length - 1 + f),
                this.result.path.length > f + 1 ? this.result.path[f + 1].edge: null
            }
        },
        {
            key: "deleteAll",
            value: function() {
                this.deleteVertices()
            }
        },
        {
            key: "isEmpty",
            value: function() {
                return 0 == this.result.path.length
            }
        },
        {
            key: "getCost",
            value: function() {
                return this.result.pathDistance
            }
        },
        {
            key: "exists",
            value: function() {
                return null != this.result.pathDistance
            }
        }]),
        q
    } (),
    Vd = [function(q, f) {
        return q.x + q.w - f.x
    },
    function(q, f) {
        return q.x - (f.x + f.w)
    }],
    Wd = [function(q, f) {
        return q.y + q.h - f.y
    },
    function(q, f) {
        return q.y - (f.y + f.h)
    }],
    eg = [null, [Vd[0], Wd[1]], [Vd[0], Wd[0]], [Vd[1], Wd[0]], [Vd[1], Wd[1]]],
    Th = {
        x: 20,
        y: 20
    },
    Uh = function() {
        function q(f) {
            ba(this, q);
            B(this, "origin", void 0);
            B(this, "elements", void 0);
            B(this, "debug", void 0);
            B(this, "container", void 0);
            B(this, "getContainerPosition", void 0);
            B(this, "originDebugMarker", void 0);
            B(this, "constrain", void 0);
            B(this, "padding", void 0);
            B(this, "filter", void 0);
            B(this, "exclude", void 0);
            B(this, "currentFocus", void 0);
            B(this, "focusElement", null);
            B(this, "getSize", void 0);
            B(this, "getId", void 0);
            B(this, "getPosition", void 0);
            B(this, "setPosition", void 0);
            B(this, "positionArray", []);
            B(this, "positions", new Map);
            B(this, "originalPositions", new Map);
            B(this, "sizes", new Map);
            this.getPosition = f.getPosition;
            this.setPosition = f.setPosition;
            this.getId = f.getId;
            this.getSize = f.getSize;
            this.elements = fg(f.elements || []);
            this.debug = !0 === f.debug;
            this.padding = f.padding || Th;
            this.filter = f.filter ||
            function(n) {
                return ! 0
            };
            this.exclude = f.exclude ||
            function(n) {
                return ! 1
            };
            this.container = f.container;
            this.getContainerPosition = f.getContainerPosition;
            this.constrain = f.constrain ||
            function(n, d, k) {
                return k
            }
        }
        return ca(q, [{
            key: "executeAtPoint",
            value: function(f, n) {
                return this._updatePositions(),
                this.setOrigin(f),
                this.focusElement = null,
                this._run(n)
            }
        },
        {
            key: "executeAtCenter",
            value: function(f) {
                var n = this._updatePositions();
                return this.setOrigin({
                    x: (n[0] + n[1]) / 2,
                    y: (n[2] + n[3]) / 2
                }),
                this.focusElement = null,
                this._run(f)
            }
        },
        {
            key: "executeWithFocus",
            value: function(f, n) {
                return this._updatePositions(),
                this.focusElement = {
                    id: f,
                    bounds: this.positions.get(f)
                },
                this.setOrigin(this.focusElement.bounds.center),
                this._run(n)
            }
        },
        {
            key: "snapToGrid",
            value: function(f) {
                var n = {};
                this._updatePositions();
                for (var d = 0; d < this.positionArray.length; d++) {
                    var k = this.positions.get(this.positionArray[d].id),
                    a = this._snapPositionToGrid(this.positionArray[d].bounds, f),
                    e = a.pos;
                    a.moved && (n[this.positionArray[d].id] = {
                        original: k,
                        current: e
                    })
                }
                return this._positionElements(n),
                n
            }
        },
        {
            key: "setElements",
            value: function(f) {
                return this.elements = fg(f),
                this
            }
        },
        {
            key: "addElement",
            value: function(f, n) {
                return null == f || !n && -1 !== this.elements.indexOf(f) || this.elements.push(f),
                this
            }
        },
        {
            key: "addElements",
            value: function(f, n) {
                if (n) Array.prototype.push.apply(this.elements, f);
                else for (n = 0; n < f.length; n++) this.addElement(f[n]);
                return this
            }
        },
        {
            key: "removeElement",
            value: function(f) {
                for (var n = -1,
                d = 0; d < this.elements.length; d++) if (this.elements[d] === f) {
                    n = d;
                    break
                }
                return - 1 !== n && this.elements.splice(n, 1),
                this
            }
        },
        {
            key: "reset",
            value: function() {
                this.elements.length = 0
            }
        },
        {
            key: "setOrigin",
            value: function(f) {
                null != f && (this.origin = f)
            }
        },
        {
            key: "_updatePositions",
            value: function() {
                return this.positionArray.length = 0,
                this.positions.clear(),
                this.originalPositions.clear(),
                this.sizes.clear(),
                this._computeExtents(this.elements)
            }
        },
        {
            key: "_computeExtents",
            value: function(f) {
                var n, d;
                var k = n = 1 / 0;
                var a = d = -1 / 0;
                for (var e = 0; e < f.length; e++) {
                    var c = this.getPosition(f[e]),
                    h = this.getSize(f[e]),
                    b = this.getId(f[e]),
                    g = {
                        x: c.x,
                        y: c.y,
                        w: h.w,
                        h: h.h,
                        center: {
                            x: c.x + h.w / 2,
                            y: c.y + h.h / 2
                        }
                    };
                    this.positions.set(b, g);
                    this.originalPositions.set(b, A({},
                    g));
                    this.positionArray.push({
                        bounds: g,
                        id: b,
                        element: f[e]
                    });
                    this.sizes.set(b, h);
                    k = Math.min(k, c.x);
                    n = Math.min(n, c.y);
                    a = Math.max(a, c.x + h.w);
                    d = Math.max(d, c.y + h.h)
                }
                return [k, a, n, d]
            }
        },
        {
            key: "_run",
            value: function(f) {
                var n = {};
                if (1 < this.elements.length) {
                    var d = (f = f || {}).filter || this.filter,
                    k = f.padding || Th,
                    a = f.iterations,
                    e = f.exclude || this.exclude;
                    f.gather && A(n, this._gather(k, this.constrain, d, e));
                    A(n, this._magnetize(k, this.constrain, d, a, e, f.grid))
                }
                f = {};
                for (var c in n) f[c] = {
                    original: this.originalPositions.get(c),
                    current: n[c]
                };
                return this._positionElements(f),
                f
            }
        },
        {
            key: "_snapPositionToGrid",
            value: function(f, n) {
                var d = f.x,
                k = f.y;
                null != n && (n = Ff(f, n), f.x = n.x, f.y = n.y, f.center.x = f.x + f.w / 2, f.center.y = f.y + f.h / 2);
                return {
                    moved: d !== f.x || k !== f.y,
                    pos: f
                }
            }
        },
        {
            key: "_gather",
            value: function(f, n, d, k) {
                var a = this,
                e = {},
                c = gc(this.origin, {
                    w: 0,
                    h: 0
                },
                f),
                h = {};
                this.positionArray.sort(function(m, r) {
                    var t = h[m.id] || Math.min(Va(m.bounds, a.origin), Va(ac(m.bounds, {
                        x: m.bounds.w,
                        y: 0
                    }), a.origin), Va(ac(m.bounds, {
                        x: m.bounds.w,
                        y: m.bounds.h
                    }), a.origin), Va(ac(m.bounds, {
                        x: 0,
                        y: m.bounds.h
                    }), a.origin)),
                    u = h[r.id] || Math.min(Va(r.bounds, a.origin), Va(ac(r.bounds, {
                        x: r.bounds.w,
                        y: 0
                    }), a.origin), Va(ac(r.bounds, {
                        x: r.bounds.w,
                        y: r.bounds.h
                    }), a.origin), Va(ac(r.bounds, {
                        x: 0,
                        y: r.bounds.h
                    }), a.origin));
                    return h[m.id] = t,
                    h[r.id] = u,
                    t === u ? 0 : t < u ? -1 : 1
                });
                var b = {};
                n = function(m) {
                    if (k(a.positionArray[m].id, a.positionArray[m].element)) return "continue";
                    var r = a.positionArray[m].bounds,
                    t = gc(r.center, a.positionArray[m].bounds, f);
                    if (d(a.positionArray[m].id, a.positionArray[m].element)) {
                        var u = function(v) {
                            var w = [a.origin, v],
                            z = [];
                            Array.prototype.push.apply(z, Ef(w, c).map(function(E) {
                                return [c, E, null]
                            }));
                            v = function(E) {
                                var F = a.positions.get(E);
                                Array.prototype.push.apply(z, Ef(w, F).map(function(M) {
                                    return [F, M, E]
                                }))
                            };
                            for (var y in b) v(y);
                            return z.filter(function(E) {
                                return null != E
                            })
                        } (r.center);
                        0 < u.length && (u.sort(function(v, w) {
                            return Va(v[1], r) < Va(w[1], r) ? -1 : 1
                        }), t = De(u[0][0], t), r.x += t.x, r.y += t.y, r.center.x += t.x, r.center.y += t.y, e[a.positionArray[m].id] = r, b[a.positionArray[m].id] = !0)
                    }
                };
                for (var g = 0; g < this.positionArray.length; g++) n(g);
                return e
            }
        },
        {
            key: "_magnetize",
            value: function(f, n, d, k, a, e) {
                var c, h, b = this;
                k = k || 2;
                null != this.focusElement ? (c = gc(this.origin, this.focusElement.bounds, {
                    x: 0,
                    y: 0
                }), h = this.focusElement.id) : c = gc(this.origin, {
                    w: 0,
                    h: 0
                },
                f);
                var g, m, r = 1,
                t = !0,
                u = {},
                v = function(w, z) {
                    if (null == e) return z;
                    var y = ac(w, z),
                    E = y.x / e.w;
                    y = y.y / e.h;
                    return {
                        x: e.w * (0 <= z.x ? Math.ceil(E) : Math.floor(E)) - w.x,
                        y: e.h * (0 <= z.y ? Math.ceil(y) : Math.floor(y)) - w.y
                    }
                };
                return function z() {
                    for (var y, E, F = 0; F < b.positionArray.length; F++) if ((y = b.positionArray[F]).id !== h && !a(y.id, y.element)) {
                        var M = y.bounds,
                        S = gc(M.center, M, f);
                        if (d(y.id, y.element) && cc(c, S)) {
                            g = De(c, S);
                            g = v(M, g);
                            m = n(y.id, M, g);
                            S = y.id;
                            var X = M,
                            da = m.x,
                            W = m.y;
                            X.x += da;
                            X.y += W;
                            X.center.x += da;
                            X.center.y += W;
                            u[S] = X;
                            S = gc(M.center, M, f)
                        }
                        for (M = 0; M < b.positionArray.length; M++) if (F !== M && (E = b.positionArray[M]).id !== h && !a(E.id, E.element) && d(E.id, E.element) && (da = E.bounds, X = gc(da.center, da, f), cc(S, X))) {
                            t = !0;
                            g = De(S, X);
                            g = v(da, g);
                            m = n(E.id, da, g);
                            X = E.id;
                            W = m.x;
                            var Xa = m.y;
                            da.x += W;
                            da.y += Xa;
                            da.center.x += W;
                            da.center.y += Xa;
                            u[X] = da
                        }
                    }
                    t && r < k && (t = !1, r++, z())
                } (),
                u
            }
        },
        {
            key: "_positionElements",
            value: function(f) {
                for (var n = 0; n < this.elements.length; n++) {
                    var d = this.getId(this.elements[n]);
                    f[d] && this.setPosition(this.elements[n], f[d].current)
                }
            }
        }]),
        q
    } (),
    Vh = function() {
        function q(f) {
            ba(this, q);
            B(this, "toolkit", void 0);
            B(this, "adapter", void 0);
            B(this, "_vertices", []);
            B(this, "magnetizer", void 0);
            B(this, "magnetizerIterations", void 0);
            B(this, "positions", new Map);
            B(this, "sizes", new Map);
            B(this, "positionArray", []);
            B(this, "parameters", void 0);
            B(this, "done", void 0);
            B(this, "_minx", 1 / 0);
            B(this, "_miny", 1 / 0);
            B(this, "_maxx", -1 / 0);
            B(this, "_maxy", -1 / 0);
            B(this, "entries", {});
            B(this, "xmax", []);
            B(this, "ymax", []);
            B(this, "xmin", []);
            B(this, "ymin", []);
            B(this, "width", void 0);
            B(this, "height", void 0);
            B(this, "container", void 0);
            B(this, "containerSize", void 0);
            B(this, "negativeValuesAllowed", void 0);
            B(this, "_locationFunction", void 0);
            B(this, "_vertexMap", {});
            B(this, "defaultMagnetized", void 0);
            B(this, "type", void 0);
            this._locationFunction = f.options.locationFunction;
            this.adapter = f.adapter;
            this.initialiseMagnetizer(f.options);
            this.negativeValuesAllowed = !1 !== f.negativeValuesAllowed;
            this.toolkit = f.toolkit;
            this.container = f.container;
            this.containerSize = this.adapter.getSize(this.container);
            this.width = f.options.width || this.containerSize.w;
            this.height = f.options.height || this.containerSize.h;
            this.done = !1;
            this.parameters = f.options || {}
        }
        return ca(q, [{
            key: "_reset",
            value: function() {
                this.done = !1;
                this._minx = 1 / 0;
                this._maxx = -1 / 0;
                this._miny = 1 / 0;
                this._maxy = -1 / 0;
                this.positions.clear();
                this.positionArray.splice(0);
                this.entries = {};
                this.xmin.length = 0;
                this.ymin.length = 0;
                this.xmax.length = 0;
                this.ymax.length = 0;
                this._vertices.length = 0;
                this.sizes.clear();
                this.magnetizer.reset();
                this.reset()
            }
        },
        {
            key: "_prepareParameters",
            value: function() {
                var f = A(q._defaultParameters(), this.getDefaultParameters() || {});
                return A(f, this.parameters || {}),
                this.parameters = f,
                this.parameters
            }
        },
        {
            key: "_getEntry",
            value: function(f, n) {
                this.entries[f] || (n = n || {
                    x: 0,
                    y: 0
                },
                this.entries[f] = {
                    id: f,
                    size: this._getSize(f),
                    position: n,
                    xmax: n.x,
                    ymax: n.y,
                    xmin: n.x,
                    ymin: n.y
                });
                return this.entries[f]
            }
        },
        {
            key: "_cleanupEntry",
            value: function(f) {
                delete this.entries[f]
            }
        },
        {
            key: "_calculateExtents",
            value: function() {
                for (var f in this.xmax.length = 0,
                this.xmin.length = 0,
                this.ymax.length = 0,
                this.ymin.length = 0,
                this.entries) Fd(this.xmax, this.entries[f], "xmax"),
                Fd(this.ymax, this.entries[f], "ymax"),
                Fd(this.xmin, this.entries[f], "xmin"),
                Fd(this.ymin, this.entries[f], "ymin");
                if (this._minx = 0 < this.xmin.length ? this.xmin[0].xmin: 0, this._maxx = 0 < this.xmax.length ? this.xmax[this.xmax.length - 1].xmax: 0, this._miny = 0 < this.ymin.length ? this.ymin[0].ymin: 0, this._maxy = 0 < this.ymax.length ? this.ymax[this.ymax.length - 1].ymax: 0, !this.negativeValuesAllowed && (0 > this._minx || 0 > this._miny)) {
                    var n = 0 > this._minx ? this._minx: 0,
                    d = 0 > this._miny ? this._miny: 0;
                    if (0 > n || 0 > d) {
                        for (var k in this.positions.forEach(function(a, e) {
                            a.x -= n;
                            a.y -= d
                        }), this.entries) this.entries[k].position.x -= n,
                        this.entries[k].xmin -= n,
                        this.entries[k].xmax -= n,
                        this.entries[k].position.y -= d,
                        this.entries[k].ymin -= d,
                        this.entries[k].ymax -= d;
                        this._minx -= n;
                        this._miny -= d;
                        this._maxx -= n;
                        this._maxy -= d
                    }
                }
            }
        },
        {
            key: "snapToGrid",
            value: function(f, n) {
                return null != n ? this.magnetizer.setElements([n]) : this.magnetizer.setElements(this._vertices.map(function(d) {
                    return d.id
                })),
                this.magnetizer.snapToGrid(f)
            }
        },
        {
            key: "magnetize",
            value: function(f) { (f = f || {}).options = f.options || {};
                f.options.iterations = f.options.iterations || this.magnetizerIterations;
                return this.magnetizer.setElements(this._vertices.map(function(n) {
                    return n.id
                })),
                f.origin ? this.magnetizer.executeAtPoint(f.origin, f.options) : f.focus ? this.magnetizer.executeWithFocus(f.focus, f.options) : this.magnetizer.executeAtCenter(f.options)
            }
        },
        {
            key: "vertexAdded",
            value: function(f, n) {
                if (this.adapter.filter(f.vertex)) {
                    var d = n && n.position ? n.position: f.vertex.data && f.vertex.data.left && f.vertex.data.top ? {
                        x: f.vertex.data.left,
                        y: f.vertex.data.top
                    }: this.adapter.getOffset(f.el);
                    n = this._vertexAdded(f, n);
                    return ! n || isNaN(n.x) || isNaN(n.y) || (d.x = n.x, d.y = n.y),
                    this._vertices.push(f.vertex),
                    this._vertexMap[f.vertex.id] = f.vertex,
                    this._setPosition(f.vertex.id, d),
                    this._getSize(f.vertex.id),
                    this.magnetizer.addElement(f.vertex.id),
                    d
                }
            }
        },
        {
            key: "vertexRemoved",
            value: function(f) {
                this.positions.delete(f.id);
                this.sizes.delete(f.id);
                this._vertices = this._vertices.filter(function(n) {
                    return n !== f
                });
                delete this._vertexMap[f.id];
                this._cleanupEntry(f.id);
                this._vertexRemoved(f);
                this.magnetizer.removeElement(f.id)
            }
        },
        {
            key: "_getSize",
            value: function(f) {
                var n = this;
                return vd(this.sizes, f,
                function() {
                    var d = n.adapter.getViewportPositionById(f);
                    return null != d ? {
                        w: d.w,
                        h: d.h
                    }: {
                        w: 0,
                        h: 0
                    }
                })
            }
        },
        {
            key: "_getPosition",
            value: function(f, n, d, k) {
                var a = this.positions.get(f);
                if (!a) {
                    if (null != n && null != d) a = {
                        x: n,
                        y: d
                    };
                    else {
                        if (k) return null;
                        a = {
                            x: Math.floor(Math.random() * (this.width + 1)),
                            y: Math.floor(Math.random() * (this.height + 1))
                        }
                    }
                    this._setPosition(f, a)
                }
                return a
            }
        },
        {
            key: "_doSetPosition",
            value: function(f, n, d) {
                if (null != f) {
                    isNaN(n) && (n = 0);
                    isNaN(d) && (d = 0);
                    var k = this.positions.get(f);
                    k || (k = {
                        x: n,
                        y: d
                    },
                    this.positions.set(f, k), this.positionArray.push([k, f]));
                    k = this._getEntry(f, {
                        x: n,
                        y: d
                    });
                    k.position.x = n;
                    k.position.y = d;
                    this.updateEntry(k);
                    this.positions.set(f, {
                        x: n,
                        y: d
                    })
                }
            }
        },
        {
            key: "_doUpdateAfterMove",
            value: function(f, n, d) {
                this._vertexMap[f] && this._vertexMoved(f, n, d)
            }
        },
        {
            key: "_vertexMoved",
            value: function(f, n, d) {}
        },
        {
            key: "_vertexAdded",
            value: function(f, n) {
                return null
            }
        },
        {
            key: "_vertexRemoved",
            value: function(f) {}
        },
        {
            key: "setMagnetizedPosition",
            value: function(f, n, d, k, a) {
                var e = this;
                this._doSetPosition(f, n, d);
                n = this.magnetize({
                    focus: !0 === k ? f: null,
                    options: {
                        filter: function(c) {
                            c = c !== f;
                            return ! 0 !== k ? !c: c
                        },
                        exclude: function(c, h) {
                            return null != e._vertexMap[c] && null != e._vertexMap[c].group
                        },
                        grid: a
                    }
                });
                d = this._getPosition(f);
                return this._doUpdateAfterMove(f, d.x, d.y),
                n
            }
        },
        {
            key: "_setPosition",
            value: function(f, n) {
                this._doSetPosition(f, n.x, n.y);
                this._doUpdateAfterMove(f, n.x, n.y)
            }
        },
        {
            key: "_getRandomPosition",
            value: function(f, n, d, k) {
                n = Math.floor(Math.random() * (n || 10));
                d = Math.floor(Math.random() * (d || 10));
                var a = this._getEntry(f, {
                    x: n,
                    y: d
                });
                return a.position = {
                    x: n,
                    y: d
                },
                this.updateEntry(a, !0 !== k),
                this.positions.set(f, {
                    x: n,
                    y: d
                }),
                {
                    x: n,
                    y: d
                }
            }
        },
        {
            key: "dumpPos",
            value: function() {
                this.positions.forEach(function(f, n) {
                    console.log(n, f.x, f.y)
                })
            }
        },
        {
            key: "initialiseMagnetizer",
            value: function(f) {
                var n = this;
                this.magnetizer = new Uh({
                    getPosition: function(d) {
                        return n.positions.get(d)
                    },
                    getSize: function(d) {
                        return n.sizes.get(d)
                    },
                    getId: function(d) {
                        return d
                    },
                    setPosition: function(d, k) {
                        var a = n.adapter.getViewportPositionById(d);
                        if (0 !== a.r) {
                            var e = {
                                x: k.x + a.w,
                                y: k.y
                            },
                            c = {
                                x: k.x + a.w,
                                y: k.y + a.h
                            },
                            h = {
                                x: k.x,
                                y: k.y + a.h
                            },
                            b = {
                                x: (k.x + e.x) / 2,
                                y: (k.y + h.y) / 2
                            };
                            k = qb(k, b, -a.r);
                            e = qb(e, b, -a.r);
                            h = qb(h, b, -a.r);
                            a = qb(c, b, -a.r);
                            n.setPosition(d, Math.min(k.x, e.x, h.x, a.x), Math.min(k.y, e.y, h.y, a.y))
                        } else n.setPosition(d, k.x, k.y)
                    },
                    padding: f.padding,
                    filter: function(d) {
                        return (!n._vertexMap[d] || !n._vertexMap[d].group) && n.canMagnetize(d)
                    }
                });
                this.magnetizerIterations = f.magnetizer && f.magnetizer.iterations || 10
            }
        },
        {
            key: "setPosition",
            value: function(f, n, d) {
                var k = 3 < arguments.length && void 0 !== arguments[3] && arguments[3],
                a = {};
                return a[f] = {
                    original: this.positions.get(f) || {
                        x: 0,
                        y: 0
                    },
                    current: {
                        x: n,
                        y: d
                    }
                },
                this._setPosition(f, {
                    x: n,
                    y: d
                }),
                k || this._calculateExtents(),
                a
            }
        },
        {
            key: "getPositions",
            value: function() {
                return this.positions
            }
        },
        {
            key: "getPosition",
            value: function(f) {
                return this.positions.get(f)
            }
        },
        {
            key: "_getExtents",
            value: function() {
                return {
                    xmin: this._minx,
                    ymin: this._miny,
                    xmax: this._maxx,
                    ymax: this._maxy
                }
            }
        },
        {
            key: "setSize",
            value: function(f, n) {
                this.sizes.set(f, n);
                f = this._getEntry(f);
                f.size = n;
                this.updateEntry(f, !0)
            }
        },
        {
            key: "getSizes",
            value: function() {
                return this.sizes
            }
        },
        {
            key: "updateEntry",
            value: function(f, n) {
                f.xmax = f.position.x + f.size.w;
                f.ymax = f.position.y + f.size.h;
                f.xmin = f.position.x;
                f.ymin = f.position.y;
                n && this._calculateExtents()
            }
        },
        {
            key: "_layout",
            value: function(f, n) {
                if (null != this.toolkit) {
                    this.containerSize = this.adapter.getSize(this.container);
                    this.width = this.containerSize.w;
                    this.height = this.containerSize.h;
                    var d = this._prepareParameters();
                    this._vertices = this.adapter.getElements().slice();
                    for (this.begin(this.toolkit, d); ! this.done;) this.step(this.toolkit, d); (n || this.defaultMagnetized) && this.magnetize();
                    this._calculateExtents();
                    this.end(this.toolkit, d);
                    f && f({
                        positions: this.positions,
                        bounds: {
                            xmin: this._minx,
                            ymin: this._miny,
                            xmax: this._maxx,
                            ymax: this._maxy
                        },
                        sizes: this.sizes
                    })
                }
            }
        },
        {
            key: "relayout",
            value: function(f, n, d) {
                this._reset();
                null != f && (this.parameters = f);
                this._layout(n, d)
            }
        },
        {
            key: "layout",
            value: function(f, n) {
                this.done = !1;
                this._layout(f, n)
            }
        }], [{
            key: "_defaultParameters",
            value: function() {
                return {
                    padding: {
                        x: 0,
                        y: 0
                    }
                }
            }
        }]),
        q
    } (),
    Nk = function f() {
        ba(this, f)
    },
    Wh = {},
    od = {
        get: function(f, n) {
            var d = Wh[f];
            if (d) return n.options = n.options || {},
            new d(n);
            throw {
                message: "jsPlumb: unknown layout type '" + f + "'"
            };
        },
        register: function(f, n) {
            Wh[f] = n
        }
    },
    Xh = new Map,
    Xd = function(f) {
        function n(k) {
            var a;
            return ba(this, n),
            B(L(a = d.call(this, k)), "type", n.type),
            B(L(a), "defaultMagnetized", void 0),
            a
        }
        Fa(n, Vh);
        var d = Ga(n);
        return ca(n, [{
            key: "getDefaultParameters",
            value: function() {
                return {}
            }
        },
        {
            key: "layout",
            value: function() {}
        },
        {
            key: "refresh",
            value: function() {
                this.layout()
            }
        },
        {
            key: "relayout",
            value: function() {
                this.layout()
            }
        },
        {
            key: "getPositions",
            value: function() {
                return Xh
            }
        },
        {
            key: "getPosition",
            value: function(k) {
                return {
                    x: 0,
                    y: 0
                }
            }
        },
        {
            key: "setPosition",
            value: function(k, a, e) {
                return B({},
                k, {
                    original: {
                        x: a,
                        y: e
                    },
                    current: {
                        x: a,
                        y: e
                    }
                })
            }
        },
        {
            key: "getExtents",
            value: function() {
                return [0, 0, 0, 0]
            }
        },
        {
            key: "getSize",
            value: function(k) {
                return {
                    w: 0,
                    h: 0
                }
            }
        },
        {
            key: "begin",
            value: function(k, a) {}
        },
        {
            key: "canMagnetize",
            value: function(k) {
                return ! 1
            }
        },
        {
            key: "end",
            value: function(k, a) {}
        },
        {
            key: "reset",
            value: function() {}
        },
        {
            key: "step",
            value: function(k, a) {
                this.done = !0
            }
        },
        {
            key: "getSizes",
            value: function() {
                return Xh
            }
        }]),
        n
    } ();
    B(Xd, "type", "Empty");
    od.register(Xd.type, Xd);
    var Ok = function(f) {
        function n(k) {
            var a;
            return ba(this, n),
            B(L(a = d.call(this, k)), "_suppliedLocationFunction", void 0),
            B(L(a), "defaultMagnetized", !1),
            B(L(a), "absoluteBacked", void 0),
            a.absoluteBacked = !0 === k.options.absoluteBacked,
            a._suppliedLocationFunction = k.options.locationFunction,
            a
        }
        Fa(n, Vh);
        var d = Ga(n);
        return ca(n, [{
            key: "_vertexAdded",
            value: function(k, a) {
                return this._findLocation(k.vertex, k.parameters)
            }
        },
        {
            key: "_defaultLocationFunction",
            value: function(k) {
                return {
                    x: k.data.left,
                    y: k.data.top
                }
            }
        },
        {
            key: "_findLocation",
            value: function(k, a) {
                return (null != a && a.locationFunction ? a.locationFunction: this._suppliedLocationFunction || this._defaultLocationFunction)(k)
            }
        },
        {
            key: "begin",
            value: function(k, a) {
                k = this.adapter.getElements();
                for (var e = k.length,
                c = 0; c < e; c++) {
                    var h = k[c],
                    b = h.getFullId(),
                    g = this.getPosition(b);
                    null == g && (g = this._findLocation(h, a));
                    this.setPosition(b, g.x, g.y, !0)
                }
            }
        },
        {
            key: "step",
            value: function(k, a) {
                this.done = !0
            }
        },
        {
            key: "canMagnetize",
            value: function(k) {
                return ! 0
            }
        },
        {
            key: "end",
            value: function(k, a) {}
        },
        {
            key: "reset",
            value: function() {}
        },
        {
            key: "getAbsolutePosition",
            value: function(k, a) {
                return this._findLocation(k, a)
            }
        }]),
        n
    } (),
    Hc = function(f) {
        function n(k) {
            var a;
            return ba(this, n),
            B(L(a = d.call(this, k)), "type", n.type),
            a
        }
        Fa(n, Ok);
        var d = Ga(n);
        return ca(n, [{
            key: "getDefaultParameters",
            value: function() {
                return {}
            }
        }]),
        n
    } ();
    B(Hc, "type", "Absolute");
    od.register(Hc.type, Hc);
    var Yh = ["node", "port", "edge", "group"],
    Zh = [":added", ":removed", ":updated", ":moved"],
    $h = ["edge"],
    ai = [":source", ":target"],
    Ic = function(f, n, d, k) {
        for (var a = 0; a < n.length; a++) for (var e = 0; e < d.length; e++) pd(f, n[a] + d[e], k)
    },
    pd = function(f, n, d) {
        f.instance.bind(n, d);
        f.bindings.push([n, d])
    },
    bi = function() {
        function f(n, d) {
            function k(b) {
                return function() {
                    b && b.apply(b, arguments);
                    d.onAfterAutoSave && d.onAfterAutoSave()
                }
            }
            var a = this;
            if (ba(this, f), this.instance = n, B(this, "bindings", []), B(this, "timer", null), null == d.saveUrl && null == d.autoSaveHandler) throw Error("JSPLUMB autosave: neither saveUrl nor autoSaveHandler was specified");
            var e = !1,
            c = function() {
                if (!e) {
                    try {
                        d.onBeforeAutoSave && d.onBeforeAutoSave()
                    } catch(b) {}
                    null != d.autoSaveHandler ? d.autoSaveHandler(n) : n.save({
                        url: d.saveUrl,
                        success: k(d.onAutoSaveSuccess),
                        error: k(d.onAutoSaveError),
                        headers: d.saveHeaders
                    })
                }
            },
            h = function() {
                null == d.autoSaveDebounceTimeout ? c() : (null == a.timer || clearTimeout(a.timer), a.timer = setTimeout(c, d.autoSaveDebounceTimeout))
            };
            pd(this, "dataLoadStart",
            function() {
                e = !0
            });
            pd(this, "dataLoadEnd",
            function() {
                e = !1
            });
            pd(this, "graphClearStart",
            function() {
                e = !0
            });
            pd(this, "graphCleared",
            function() {
                e = !1
            });
            Ic(this, Yh, Zh, h);
            Ic(this, $h, ai, h);
            Ic(this, ["group:"], ["member:added", "member:removed"], h)
        }
        return ca(f, [{
            key: "discard",
            value: function() {
                var n = this;
                this.bindings.forEach(function(d) {
                    return n.instance.unbind(d[0], d[1])
                });
                this.bindings.length = 0
            }
        }]),
        f
    } (),
    Pk = function d(n) {
        ba(this, d);
        this.instance = n;
        B(this, "bindings", []);
        var k = function() {
            n.fire("dataUpdated")
        };
        Ic(this, Yh, Zh, k);
        Ic(this, $h, ai, k);
        Ic(this, ["group:"], ["member:added", "member:removed"], k)
    },
    Cb,
    Qk = function(n) {
        function d(a) {
            var e;
            return ba(this, d),
            (e = k.call(this)).toolkit = a,
            e
        }
        Fa(d, zc);
        var k = Ga(d);
        return ca(d, [{
            key: "_createSelection",
            value: function(a) {
                return new Db(this.toolkit, {
                    onClear: a ||
                    function() {}
                })
            }
        },
        {
            key: "filter",
            value: function(a, e) {
                var c = "function" == typeof a ? a: function(b) {
                    b = b.data;
                    var g = !1,
                    m;
                    for (m in a) {
                        var r = a[m] === b[m];
                        if (!r && !e) return ! 1;
                        g = g || r
                    }
                    return g
                },
                h = this._createSelection();
                return this.eachNode(function(b, g) {
                    c(g) && h.append(g);
                    b = g.getPorts();
                    for (g = 0; g < b.length; g++) c(b[g]) && h.append(b[g])
                }),
                this.eachEdge(function(b, g) {
                    c(g) && h.append(g)
                }),
                this.eachGroup(function(b, g) {
                    c(g) && h.append(g)
                }),
                h
            }
        }]),
        d
    } (),
    Db = function(n) {
        function d(a, e) {
            var c;
            return ba(this, d),
            (c = k.call(this, a)).toolkit = a,
            B(L(c), "maxNodes", 1 / 0),
            B(L(c), "maxEdges", 1 / 0),
            B(L(c), "maxGroups", 1 / 0),
            B(L(c), "_nodes", []),
            B(L(c), "_groups", []),
            B(L(c), "_edges", []),
            B(L(c), "capacityPolicy", void 0),
            B(L(c), "generator", void 0),
            B(L(c), "onReload", void 0),
            B(L(c), "onBeforeReload", void 0),
            B(L(c), "onClear", void 0),
            B(L(c), "autoFill", void 0),
            B(L(c), "dataSource", void 0),
            B(L(c), "_objMap", {}),
            B(L(c), "_loading", !1),
            B(L(c), "edgeFactory", void 0),
            c.edgeFactory = a.edgeFactory,
            c.generator = e.generator,
            c.onReload = e.onReload,
            c.onBeforeReload = e.onBeforeReload,
            c.autoFill = !0 === e.autoFill,
            c.onClear = e.onClear ||
            function() {},
            c.toolkit.bind("node:removed",
            function(h) {
                c._removeOne(h.node)
            }),
            c.toolkit.bind("group:removed",
            function(h) {
                c._removeOne(h.group)
            }),
            c.toolkit.bind("port:removed",
            function(h) {
                c._removeOne(h.port)
            }),
            c.toolkit.bind("edge:removed",
            function(h) {
                c._removeOne(h.edge)
            }),
            c.toolkit.bind("edge:target",
            function(h) {
                c._objMap[h.edge.getFullId()] && c.fire("edge:target", h)
            }),
            c.toolkit.bind("edge:source",
            function(h) {
                c._objMap[h.edge.getFullId()] && c.fire("edge:source", h)
            }),
            c.toolkit.bind("node:added",
            function(h) {
                c.generator && c.autoFill && !c._loading && c.reload()
            }),
            c.toolkit.bind("group:added",
            function(h) {
                c.generator && c.autoFill && !c._loading && c.reload()
            }),
            c.toolkit.bind("node:updated",
            function(h) {
                c._objMap[h.vertex.getFullId()] && c.fire("node:updated", h)
            }),
            c.toolkit.bind("group:updated",
            function(h) {
                c._objMap[h.vertex.getFullId()] && c.fire("group:updated", h)
            }),
            c.toolkit.bind("edge:updated",
            function(h) {
                c._objMap[h.edge.getFullId()] && c.fire("edge:updated", h)
            }),
            c.toolkit.bind("port:updated",
            function(h) {
                null != h.port && c._objMap[h.port.getFullId()] && c.fire("port:updated", h)
            }),
            c.toolkit.bind("graphCleared",
            function() {
                c.clear()
            }),
            c.toolkit.bind("dataLoadEnd",
            function() {
                c.reload()
            }),
            c.setCapacityPolicy(d.DISCARD_EXISTING),
            !0 !== e.lazy && c.reload(),
            c
        }
        Fa(d, Qk);
        var k = Ga(d);
        return ca(d, [{
            key: "_getList",
            value: function(a) {
                return a.objectType === ab.objectType ? this._edges: a.objectType === Pa.objectType ? this._nodes: this._groups
            }
        },
        {
            key: "_pushToList",
            value: function(a) {
                var e = [],
                c = this._getList(a);
                if (c.length >= (a.objectType === ab.objectType ? this.maxEdges: a.objectType === Pa.objectType ? this.maxNodes: this.maxGroups)) {
                    if (this.capacityPolicy === d.DISCARD_NEW) return ! 1;
                    e = c.splice(0, 1);
                    this._fireListEvent(e[0], ":removed");
                    delete this._objMap[e[0].getFullId()]
                }
                return c.push(a),
                this._fireListEvent(a, ":added"),
                e
            }
        },
        {
            key: "_fireListEvent",
            value: function(a, e) {
                e = a.objectType.toLowerCase() + e;
                var c = {
                    Group: function(h) {
                        return {
                            data: h.data,
                            group: h
                        }
                    },
                    Node: function(h) {
                        return {
                            data: h.data,
                            node: h
                        }
                    },
                    Port: function(h) {
                        function b(g) {
                            return h.apply(this, arguments)
                        }
                        return b.toString = function() {
                            return h.toString()
                        },
                        b
                    } (function(h) {
                        return {
                            data: h.data,
                            node: h.getParent(),
                            port: h
                        }
                    }),
                    Edge: function(h) {
                        return {
                            data: h.data,
                            edge: h
                        }
                    }
                };
                this.fire(e, c[a.objectType](a))
            }
        },
        {
            key: "_addOne",
            value: function(a, e) {
                if (!this._objMap[a.getFullId()]) {
                    var c = this._pushToList(a);
                    return ! 1 === c ? [[], []] : (this._objMap[a.getFullId()] = a, e && e(a, !0), [[a], c])
                }
                return [[], []]
            }
        },
        {
            key: "_removeOne",
            value: function(a, e, c) {
                var h = a.getFullId();
                return ma(this._getList(a),
                function(b) {
                    return b.getFullId() == h
                }) && this._fireListEvent(a, ":removed"),
                delete this._objMap[a.getFullId()],
                e && e(a, !1),
                [[], []]
            }
        },
        {
            key: "_toggle",
            value: function(a, e) {
                return this._objMap[a.getFullId()] ? this._removeOne(a, e) : this._addOne(a, e)
            }
        },
        {
            key: "_makeSenseOf",
            value: function(a, e, c) {
                var h, b = this,
                g = [],
                m = [];
                return null == a ? g: (function u(t) {
                    var v;
                    if (J(t)) null != (v = b.toolkit.getNode(t) || b.toolkit.getEdge(t) || b.toolkit.getGroup(t)) && (h = e(v, c), g.push.apply(g, h[0]), m.push.apply(m, h[1]));
                    else if (t.eachVertex && t.eachEdge) t.eachVertex(function(w, z) {
                        u(z)
                    }),
                    t.eachEdge(function(w, z) {
                        u(z)
                    });
                    else if (t.each) t.each(function(w, z) {
                        u(z.vertex || z)
                    });
                    else if (null != t.length) for (v = 0; v < t.length; v++) u(t[v]);
                    else h = e(t, c),
                    g.push.apply(g, h[0]),
                    m.push.apply(m, h[1])
                } (a), [g, m])
            }
        },
        {
            key: "remove",
            value: function(a, e) {
                return this._makeSenseOf(a, this._removeOne.bind(this), e)
            }
        },
        {
            key: "append",
            value: function(a, e) {
                return this._makeSenseOf(a, this._addOne.bind(this), e)
            }
        },
        {
            key: "toggle",
            value: function(a, e) {
                return this._makeSenseOf(a, this._toggle.bind(this), e)
            }
        },
        {
            key: "setMaxNodes",
            value: function(a) {
                this.maxNodes = a
            }
        },
        {
            key: "setMaxGroups",
            value: function(a) {
                this.maxGroups = a
            }
        },
        {
            key: "setMaxEdges",
            value: function(a) {
                this.maxEdges = a
            }
        },
        {
            key: "setCapacityPolicy",
            value: function(a) {
                this.capacityPolicy = a
            }
        },
        {
            key: "clear",
            value: function(a) {
                this._nodes.length = 0;
                this._edges.length = 0;
                this._groups.length = 0;
                this._objMap = {};
                this.fire("graphClearStart", {});
                a || this.onClear(this)
            }
        },
        {
            key: "_filterEdgeList",
            value: function(a) {
                for (var e = [], c = 0; c < a.length; c++) null != this._objMap[a[c].getId()] && e.push(a[c]);
                return e
            }
        },
        {
            key: "reload",
            value: function() {
                null != this.generator && (this.onBeforeReload && this.onBeforeReload(), this.clear(), this._loading = !0, this.fire("dataLoadStart", {}), this.generator(this, this.toolkit), this.fire("dataLoadEnd", {}), this.onReload && this.onReload(), this._loading = !1)
            }
        },
        {
            key: "each",
            value: function(a, e) {
                e = e === ab.objectType ? this._edges: e === cb.objectType ? this._groups: this._nodes;
                for (var c = 0; c < e.length; c++) try {
                    a(c, e[c])
                } catch(h) {}
            }
        },
        {
            key: "eachNode",
            value: function(a) {
                this.each(a, Pa.objectType)
            }
        },
        {
            key: "eachGroup",
            value: function(a) {
                this.each(a, cb.objectType)
            }
        },
        {
            key: "eachVertex",
            value: function(a) {
                this.each(a, Pa.objectType);
                this.each(a, cb.objectType)
            }
        },
        {
            key: "eachEdge",
            value: function(a) {
                this.each(a, ab.objectType)
            }
        },
        {
            key: "getNodeCount",
            value: function() {
                return this._nodes.length
            }
        },
        {
            key: "getNodeAt",
            value: function(a) {
                return this._nodes[a]
            }
        },
        {
            key: "getNodes",
            value: function() {
                return this._nodes
            }
        },
        {
            key: "getNode",
            value: function(a) {
                var e = ub(this._nodes,
                function(c) {
                    return c.id === a
                });
                return - 1 === e ? null: this._nodes[e]
            }
        },
        {
            key: "getGroupAt",
            value: function(a) {
                return this._groups[a]
            }
        },
        {
            key: "getGroups",
            value: function() {
                return this._groups
            }
        },
        {
            key: "getGroup",
            value: function(a) {
                var e = ub(this._groups,
                function(c) {
                    return c.id === a
                });
                return - 1 === e ? null: this._groups[e]
            }
        },
        {
            key: "getGroupCount",
            value: function() {
                return this._groups.length
            }
        },
        {
            key: "getAll",
            value: function() {
                var a = [];
                return Array.prototype.push.apply(a, this._nodes),
                Array.prototype.push.apply(a, this._edges),
                Array.prototype.push.apply(a, this._groups),
                a
            }
        },
        {
            key: "getAllEdgesFor",
            value: function(a, e) {
                return this._filterEdgeList(a.getAllEdges({
                    filter: e
                }))
            }
        },
        {
            key: "getSourceEdgesFor",
            value: function(a) {
                return this._filterEdgeList(a.getSourceEdges())
            }
        },
        {
            key: "getEdgeCount",
            value: function() {
                return this._edges.length
            }
        },
        {
            key: "getEdgeAt",
            value: function(a) {
                return this._edges[a]
            }
        },
        {
            key: "getEdges",
            value: function() {
                return this._edges
            }
        },
        {
            key: "shouldFireEvent",
            value: function(a, e, c) {
                return ! 0
            }
        },
        {
            key: "getNodeType",
            value: function(a) {
                return this.toolkit.getNodeType(a)
            }
        },
        {
            key: "getModel",
            value: function() {
                return this.toolkit.getModel()
            }
        },
        {
            key: "getGraph",
            value: function() {
                return this.toolkit.getGraph()
            }
        },
        {
            key: "setSuspendGraph",
            value: function(a) {
                this.toolkit.setSuspendGraph(a)
            }
        },
        {
            key: "getNodeId",
            value: function(a) {
                return this.toolkit.getNodeId(a)
            }
        },
        {
            key: "getPortType",
            value: function(a) {
                return this.toolkit.getPortType(a)
            }
        },
        {
            key: "addPort",
            value: function(a, e, c) {
                return this.toolkit.addPort(a, e, c)
            }
        },
        {
            key: "getPortId",
            value: function(a) {
                return this.toolkit.getPortId(a)
            }
        },
        {
            key: "getEdge",
            value: function(a) {
                return this.toolkit.getEdge(a)
            }
        },
        {
            key: "addEdge",
            value: function(a, e, c) {
                return this.toolkit.addEdge(a, e, c)
            }
        },
        {
            key: "edgeMoved",
            value: function(a, e, c) {
                this.toolkit.edgeMoved(a, e, c)
            }
        },
        {
            key: "removeEdge",
            value: function(a) {
                this.toolkit.removeEdge(a)
            }
        },
        {
            key: "setEdgeGeometry",
            value: function(a, e, c) {
                this.toolkit.setEdgeGeometry(a, e, c)
            }
        },
        {
            key: "getEdgeType",
            value: function(a) {
                return this.toolkit.getEdgeType(a)
            }
        },
        {
            key: "addToGroup",
            value: function(a, e, c, h) {
                return this.toolkit.addToGroup(a, e, h)
            }
        },
        {
            key: "removeFromGroup",
            value: function(a, e, c, h) {
                return this.toolkit.removeFromGroup(a, e, c, h)
            }
        },
        {
            key: "getVertex",
            value: function(a) {
                return this.getNode(a) || this.getGroup(a)
            }
        },
        {
            key: "containsVertex",
            value: function(a) {
                return null != this.getVertex(a)
            }
        },
        {
            key: "getObjectInfo",
            value: function(a) {
                return this.toolkit.getObjectInfo(a)
            }
        },
        {
            key: "beforeConnect",
            value: function(a, e, c) {
                return this.toolkit.beforeConnect(a, e, c)
            }
        },
        {
            key: "beforeMoveConnection",
            value: function(a, e, c) {
                return this.toolkit.beforeMoveConnection(a, e, c)
            }
        },
        {
            key: "beforeStartConnect",
            value: function(a, e) {
                return this.toolkit.beforeStartConnect(a, e)
            }
        },
        {
            key: "beforeDetach",
            value: function(a, e, c, h) {
                return this.toolkit.beforeDetach(a, e, c, h)
            }
        },
        {
            key: "beforeStartDetach",
            value: function(a, e) {
                return this.toolkit.beforeStartDetach(a, e)
            }
        },
        {
            key: "debugEnabled",
            get: function() {
                return this.toolkit.debugEnabled
            }
        },
        {
            key: "batch",
            value: function(a) {
                this.toolkit.batch(a)
            }
        }]),
        d
    } ();
    B(Db, "DISCARD_EXISTING", "discardExisting");
    B(Db, "DISCARD_NEW", "discardNew");
    var Na, Rk = {
        json: function(n, d) {
            return n.getGraph().serialize()
        }
    },
    Sk = {
        json: function(n, d, k) {
            var a = n.nodes || [];
            k = n.edges || [];
            var e = n.ports || [];
            n = n.groups || [];
            for (var c = new Map,
            h = [], b = 0; b < n.length; b++) {
                var g = n[b];
                if (null != g.group && -1 === h.indexOf(g.group)) vd(c, g.group,
                function() {
                    return []
                }).push(g);
                else {
                    g = d.addGroup(g);
                    h.push(g.id);
                    var m = c.get(g.id);
                    null != m && P(m,
                    function(r) {
                        h.push(d.addGroup(r).id)
                    });
                    c.delete(g.id)
                }
            }
            c.forEach(function(r, t) {
                if ( - 1 === h.indexOf(t)) throw Error("Parent group [" + t + "] not found");
                P(r,
                function(u) {
                    return h.push(d.addGroup(u).id)
                })
            });
            for (n = 0; n < a.length; n++) d.addNode(a[n]);
            for (a = 0; a < e.length; a++) if (e[a].nodeId) {
                n = d.getNode(e[a].nodeId);
                if (null == n) throw Error("Unknown node [" + e[a].nodeId + "]");
                n.addPort(e[a])
            } else if (e[a].id) {
                if (n = d.getGraph().getVertexByPortId(e[a].id)) c = A(e[a], {}),
                c.id = d.getGraph().splitPortId(e[a].id)[1],
                n.addPort(c)
            } else console.log("could not add port with definition " + e[a] + "; no nodeId or id found");
            for (e = 0; e < k.length; e++) a = {
                source: k[e].source,
                target: k[e].target,
                cost: k[e].cost || 1,
                directed: k[e].directed,
                data: k[e].data
            },
            k[e].geometry && (a.geometry = k[e].geometry),
            d.addEdge(a)
        },
        "hierarchical-json": function(n, d, k) { !
            function c(e) {
                var h = d.addNode(e);
                if (e.children) for (var b = 0; b < e.children.length; b++) {
                    var g = d.addNode(e.children[b]);
                    d.addEdge({
                        source: h,
                        target: g
                    });
                    c(e.children[b])
                }
            } (n)
        }
    }; !
    function(n) {
        n.removeGroup = "removeGroup";
        n.removeNode = "removeNode";
        n.removePort = "removePort";
        n.removeEdge = "removeEdge";
        n.addNode = "addNode";
        n.addGroup = "addGroup";
        n.addEdge = "addEdge";
        n.addPort = "addPort"
    } (Na || (Na = {}));
    var Ee = {
        json: (Cb = {},
        B(Cb, Na.removeNode,
        function(n, d, k) {
            var a = k(d.data);
            ma(n.nodes,
            function(e) {
                return e.id === a
            })
        }), B(Cb, Na.removeGroup,
        function(n, d, k) {
            var a = k(d.data);
            ma(n.groups,
            function(e) {
                return e.id === a
            })
        }), B(Cb, Na.removeEdge,
        function(n, d, k) {
            var a = k(d.data);
            ma(n.edges,
            function(e) {
                return e.data && e.data.id === a
            })
        }), B(Cb, Na.addNode,
        function(n, d, k) {
            n.nodes = n.nodes || [];
            n.nodes.push(d.data)
        }), B(Cb, Na.addGroup,
        function(n, d, k) {
            n.groups = n.groups || [];
            n.groups.push(d.data)
        }), B(Cb, Na.addEdge,
        function(n, d, k) {
            d = {
                source: d.source.getFullId(),
                target: d.target.getFullId(),
                data: d.data || {}
            };
            n.edges = n.edges || [];
            n.edges.push(d)
        }), B(Cb, Na.addPort,
        function(n, d, k) {
            n.ports = n.ports || [];
            k = A({},
            d.port.data || {});
            k.id = d.port.getFullId();
            n.ports.push(k)
        }), B(Cb, Na.removePort,
        function(n, d, k) {
            var a = d.port.getFullId();
            ma(n.ports,
            function(e) {
                return e.id === a
            })
        }), Cb)
    },
    Yd = function() {
        function n(d, k, a) {
            ba(this, n);
            this.obj = d;
            this.toolkit = k;
            this.manager = a;
            B(this, "source", void 0);
            B(this, "target", void 0);
            B(this, "edgeId", void 0);
            B(this, "sourcePort", void 0);
            B(this, "targetPort", void 0);
            B(this, "geometry", void 0);
            this.source = d.source.getFullId();
            this.target = d.target.getFullId();
            qa(d.source) && (this.sourcePort = d.source.id, this.source = d.source.getParent().getFullId());
            qa(d.target) && (this.targetPort = d.target.id, this.target = d.target.getParent().getFullId());
            this.edgeId = d.getId();
            this.geometry = d.geometry
        }
        return ca(n, [{
            key: "generateSourceId",
            value: function() {
                return null == this.sourcePort ? this.source: this.source + this.toolkit.getGraph().getPortSeparator() + this.sourcePort
            }
        },
        {
            key: "generateTargetId",
            value: function() {
                return null == this.targetPort ? this.target: this.target + this.toolkit.getGraph().getPortSeparator() + this.targetPort
            }
        },
        {
            key: "_add",
            value: function() {
                var d = {
                    source: this.generateSourceId(),
                    target: this.generateTargetId(),
                    data: this.obj.data,
                    geometry: this.geometry
                };
                d = this.toolkit.connect(d);
                this.manager.edgeChange(this.edgeId, d)
            }
        },
        {
            key: "_remove",
            value: function() {
                this.toolkit.removeEdge(this.obj)
            }
        },
        {
            key: "edgeChange",
            value: function(d) {
                this.obj = d;
                this.edgeId = this.obj.getId()
            }
        }]),
        n
    } (),
    Tk = function(n) {
        function d() {
            return ba(this, d),
            k.apply(this, arguments)
        }
        Fa(d, Yd);
        var k = Ga(d);
        return ca(d, [{
            key: "undo",
            value: function() {
                this._remove()
            }
        },
        {
            key: "redo",
            value: function() {
                this._add()
            }
        },
        {
            key: "hasDeltas",
            value: function() {
                return null != this.obj
            }
        }]),
        d
    } (),
    Uk = function(n) {
        function d() {
            return ba(this, d),
            k.apply(this, arguments)
        }
        Fa(d, Yd);
        var k = Ga(d);
        return ca(d, [{
            key: "undo",
            value: function() {
                this._add()
            }
        },
        {
            key: "redo",
            value: function() {
                this._remove()
            }
        },
        {
            key: "hasDeltas",
            value: function() {
                return null != this.obj
            }
        }]),
        d
    } (),
    qd = function() {
        function n(d) {
            ba(this, n);
            this.actions = d;
            null == this.actions && (this.actions = [])
        }
        return ca(n, [{
            key: "addAction",
            value: function(d) {
                this.actions.push(d)
            }
        },
        {
            key: "undo",
            value: function() {
                this.actions.slice().reverse().forEach(function(d) {
                    return d.undo()
                })
            }
        },
        {
            key: "redo",
            value: function() {
                this.actions.forEach(function(d) {
                    return d.redo()
                })
            }
        },
        {
            key: "edgeChange",
            value: function(d, k) {
                this.actions.forEach(function(a) {
                    a instanceof Yd && a.edgeId === d && a.edgeChange(k)
                })
            }
        },
        {
            key: "hasDeltas",
            value: function() {
                for (var d = 0; d < this.actions.length; d++) if (this.actions[d].hasDeltas()) return ! 0;
                return ! 1
            }
        }]),
        n
    } (),
    ci = function() {
        function n(d, k, a, e) {
            ba(this, n);
            this.obj = d;
            this.originalPosition = k;
            this.pos = a;
            this.renderer = e
        }
        return ca(n, [{
            key: "redo",
            value: function() {
                this.renderer.setPosition(this.obj, this.pos.x, this.pos.y)
            }
        },
        {
            key: "undo",
            value: function() {
                this.renderer.setPosition(this.obj, this.originalPosition.x, this.originalPosition.y)
            }
        },
        {
            key: "hasDeltas",
            value: function() {
                return this.pos.x !== this.originalPosition.x && this.pos.y !== this.originalPosition.y
            }
        }]),
        n
    } (),
    di = function() {
        function n(d, k) {
            ba(this, n);
            this.obj = d;
            this.toolkit = k
        }
        return ca(n, [{
            key: "_add",
            value: function() {
                this.obj.objectType === Pa.objectType ? this.obj = this.toolkit.addNode(this.obj.data) : this.obj.objectType === cb.objectType && (this.obj = this.toolkit.addGroup(this.obj.data))
            }
        },
        {
            key: "_remove",
            value: function() {
                this.toolkit.remove(this.obj)
            }
        },
        {
            key: "getTerminusId",
            value: function() {
                return this.obj.getFullId()
            }
        },
        {
            key: "hasDeltas",
            value: function() {
                return null != this.obj
            }
        }]),
        n
    } (),
    ei = function(n) {
        function d() {
            return ba(this, d),
            k.apply(this, arguments)
        }
        Fa(d, di);
        var k = Ga(d);
        return ca(d, [{
            key: "undo",
            value: function() {
                this._remove()
            }
        },
        {
            key: "redo",
            value: function() {
                this._add()
            }
        }]),
        d
    } (),
    fi = function(n) {
        function d() {
            return ba(this, d),
            k.apply(this, arguments)
        }
        Fa(d, di);
        var k = Ga(d);
        return ca(d, [{
            key: "undo",
            value: function() {
                this._add()
            }
        },
        {
            key: "redo",
            value: function() {
                this._remove()
            }
        },
        {
            key: "isConnectedTo",
            value: function(a) {
                var e = this.getTerminusId();
                return a.source === e || a.target === e
            }
        }]),
        d
    } (),
    Vk = function(n) {
        function d(a, e) {
            var c;
            return ba(this, d),
            (c = k.call(this, a.group, e)).params = a,
            B(L(c), "childrenRemoved", void 0),
            B(L(c), "orphanedChildren", void 0),
            c.childrenRemoved = a.removeChildren,
            c.orphanedChildren = a.children.map(function(h) {
                return h.data
            }),
            c
        }
        Fa(d, fi);
        var k = Ga(d);
        return ca(d, [{
            key: "_add",
            value: function() {
                var a = this;
                $f(Vc(d.prototype), "_add", this).call(this);
                this.childrenRemoved || this.orphanedChildren.forEach(function(e) {
                    return a.toolkit.addToGroup(e, a.obj)
                })
            }
        }]),
        d
    } (),
    Zd = function() {
        function n(d, k, a) {
            ba(this, n);
            this.obj = d;
            this.toolkit = a;
            B(this, "newData", void 0);
            B(this, "originalData", void 0);
            this.newData = A({},
            d.data);
            this.originalData = A({},
            k)
        }
        return ca(n, [{
            key: "_getMethod",
            value: function() {
                return "update" + this.obj.objectType
            }
        },
        {
            key: "undo",
            value: function() {
                this.toolkit[this._getMethod()](this.obj, this.originalData)
            }
        },
        {
            key: "redo",
            value: function() {
                this.toolkit[this._getMethod()](this.obj, this.newData)
            }
        },
        {
            key: "hasDeltas",
            value: function() {
                return ! me(this.newData, this.originalData)
            }
        }]),
        n
    } (),
    gi = function() {
        function n(d, k, a) {
            ba(this, n);
            this.obj = d;
            this.parent = k;
            this.toolkit = a
        }
        return ca(n, [{
            key: "_add",
            value: function() {
                this.toolkit.addPort(this.parent, this.obj.data)
            }
        },
        {
            key: "_remove",
            value: function() {
                this.toolkit.removePort(this.parent, this.obj.id)
            }
        },
        {
            key: "getTerminusId",
            value: function() {
                return this.obj.getFullId()
            }
        }]),
        n
    } (),
    Wk = function(n) {
        function d() {
            return ba(this, d),
            k.apply(this, arguments)
        }
        Fa(d, gi);
        var k = Ga(d);
        return ca(d, [{
            key: "undo",
            value: function() {
                this._remove()
            }
        },
        {
            key: "redo",
            value: function() {
                this._add()
            }
        },
        {
            key: "hasDeltas",
            value: function() {
                return null != this.obj
            }
        }]),
        d
    } (),
    Xk = function(n) {
        function d() {
            return ba(this, d),
            k.apply(this, arguments)
        }
        Fa(d, gi);
        var k = Ga(d);
        return ca(d, [{
            key: "undo",
            value: function() {
                this._add()
            }
        },
        {
            key: "redo",
            value: function() {
                this._remove()
            }
        },
        {
            key: "isConnectedTo",
            value: function(a) {
                var e = this.getTerminusId();
                return a.generateSourceId() === e || a.generateTargetId() === e
            }
        },
        {
            key: "hasDeltas",
            value: function() {
                return null != this.obj
            }
        }]),
        d
    } (),
    hi = function() {
        function n(d, k, a) {
            ba(this, n);
            this.node = d;
            this.group = k;
            this.toolkit = a
        }
        return ca(n, [{
            key: "hasDeltas",
            value: function() {
                return null != this.node
            }
        }]),
        n
    } (),
    Yk = function(n) {
        function d() {
            return ba(this, d),
            k.apply(this, arguments)
        }
        Fa(d, hi);
        var k = Ga(d);
        return ca(d, [{
            key: "redo",
            value: function() {
                this.toolkit.addToGroup(this.node, this.group)
            }
        },
        {
            key: "undo",
            value: function() {
                this.toolkit.removeFromGroup(this.node)
            }
        }]),
        d
    } (),
    Zk = function(n) {
        function d() {
            return ba(this, d),
            k.apply(this, arguments)
        }
        Fa(d, hi);
        var k = Ga(d);
        return ca(d, [{
            key: "redo",
            value: function() {
                this.toolkit.removeFromGroup(this.node)
            }
        },
        {
            key: "undo",
            value: function() {
                this.toolkit.addToGroup(this.node, this.group)
            }
        }]),
        d
    } (),
    $k = function() {
        function n(d, k) {
            ba(this, n);
            this.group = d;
            this.renderer = k
        }
        return ca(n, [{
            key: "redo",
            value: function() {
                this.renderer.collapseGroup(this.group)
            }
        },
        {
            key: "undo",
            value: function() {
                this.renderer.expandGroup(this.group)
            }
        },
        {
            key: "hasDeltas",
            value: function() {
                return null != this.group
            }
        }]),
        n
    } (),
    al = function() {
        function n(d, k) {
            ba(this, n);
            this.group = d;
            this.renderer = k
        }
        return ca(n, [{
            key: "redo",
            value: function() {
                this.renderer.expandGroup(this.group)
            }
        },
        {
            key: "undo",
            value: function() {
                this.renderer.collapseGroup(this.group)
            }
        },
        {
            key: "hasDeltas",
            value: function() {
                return null != this.group
            }
        }]),
        n
    } (),
    ii = function() {
        function n(d, k, a) {
            ba(this, n);
            this.renderer = d;
            this.vertex = k;
            this.pos = a
        }
        return ca(n, [{
            key: "redo",
            value: function() {}
        },
        {
            key: "undo",
            value: function() {
                this.renderer.setPosition(this.vertex, this.pos.x, this.pos.y)
            }
        },
        {
            key: "hasDeltas",
            value: function() {
                return null != this.vertex
            }
        }]),
        n
    } (),
    bl = function() {
        function n(d, k, a, e, c) {
            ba(this, n);
            this.toolkit = d;
            this.edge = k;
            this.originalGeometry = a;
            this.geometry = e;
            this.renderer = c
        }
        return ca(n, [{
            key: "_apply",
            value: function(d) {
                this.toolkit.fire("edge:pathRestored", {
                    edge: this.edge,
                    geometry: d,
                    renderer: this.renderer
                })
            }
        },
        {
            key: "undo",
            value: function() {
                this._apply(this.originalGeometry)
            }
        },
        {
            key: "redo",
            value: function() {
                this._apply(this.geometry)
            }
        },
        {
            key: "hasDeltas",
            value: function() {
                return ! me(this.originalGeometry, this.geometry)
            }
        }]),
        n
    } (),
    el = function() {
        function n(d) {
            ba(this, n);
            B(this, "toolkit", void 0);
            B(this, "maximumSize", void 0);
            B(this, "suspend", void 0);
            B(this, "onChange", void 0);
            B(this, "undoStack", void 0);
            B(this, "redoStack", void 0);
            B(this, "currentTransaction", void 0);
            B(this, "appendStack", 0);
            this.toolkit = d.toolkit;
            this.suspend = !1;
            this.undoStack = [];
            this.redoStack = [];
            this.maximumSize = d.maximumSize || 50;
            this.onChange = d.onChange;
            this._bindListeners()
        }
        return ca(n, [{
            key: "_bindListeners",
            value: function() {
                var d = this;
                this.toolkit.bind("dataLoadStart",
                function() {
                    d.clear();
                    d.suspend = !0
                });
                this.toolkit.bind("dataLoadEnd",
                function() {
                    d.suspend = !1
                });
                this.toolkit.bind("graphCleared",
                function() {
                    d.clear()
                });
                this.toolkit.bind("node:added",
                function(k) {
                    d.command(new ei(k.node, d.toolkit))
                });
                this.toolkit.bind("node:removed",
                function(k) {
                    d.command(new fi(k.node, d.toolkit))
                });
                this.toolkit.bind("node:updated",
                function(k) {
                    pb(k.updates) || d.command(new Zd(k.vertex, k.originalData, d.toolkit))
                });
                this.toolkit.bind("group:added",
                function(k) {
                    d.command(new ei(k.group, d.toolkit))
                });
                this.toolkit.bind("group:removed",
                function(k) {
                    d.command(new Vk(k, d.toolkit))
                });
                this.toolkit.bind("group:updated",
                function(k) {
                    pb(k.updates) || d.command(new Zd(k.vertex, k.originalData, d.toolkit))
                });
                this.toolkit.bind("edge:added",
                function(k) {
                    d.command(new Tk(k.edge, d.toolkit, d))
                });
                this.toolkit.bind("edge:removed",
                function(k) {
                    d.command(new Uk(k.edge, d.toolkit, d))
                });
                this.toolkit.bind("edge:updated",
                function(k) {
                    pb(k.updates) || d.command(new Zd(k.edge, k.originalData, d.toolkit))
                });
                this.toolkit.bind("edge:pathEdited",
                function(k) {
                    d.command(new bl(d.toolkit, k.edge, k.originalGeometry, k.geometry, k.renderer))
                });
                this.toolkit.bind("port:added",
                function(k) {
                    d.command(new Wk(k.port, k.vertex, d.toolkit))
                });
                this.toolkit.bind("port:removed",
                function(k) {
                    d.command(new Xk(k.port, k.vertex, d.toolkit))
                });
                this.toolkit.bind("port:updated",
                function(k) {
                    pb(k.updates) || d.command(new Zd(k.port, k.originalData, d.toolkit))
                });
                this.toolkit.bind("group:member:added",
                function(k) { ! 0 !== k.vertexIsNew && d.command(new Yk(k.vertex, k.group, d.toolkit))
                });
                this.toolkit.bind("group:member:removed",
                function(k) {
                    d.command(new Zk(k.vertex, k.group, d.toolkit))
                });
                this.toolkit.bind("renderer:added",
                function(k) {
                    k.renderer.bind("node:move:end",
                    function(a) {
                        null != a.originalPosition && d.command(new ci(a.vertex, a.originalPosition, a.pos, a.renderer))
                    });
                    k.renderer.bind("group:move:end",
                    function(a) {
                        null != a.originalPosition && d.command(new ci(a.vertex, a.originalPosition, a.pos, a.renderer))
                    });
                    k.renderer.bind("group:collapse",
                    function(a) {
                        d.command(new $k(a.group, a.renderer))
                    });
                    k.renderer.bind("group:expand",
                    function(a) {
                        d.command(new al(a.group, a.renderer))
                    });
                    k.renderer.bind("node:removed",
                    function(a) {
                        d.command(new ii(k.renderer, a.vertex, a.pos))
                    });
                    k.renderer.bind("group:removed",
                    function(a) {
                        d.command(new ii(k.renderer, a.vertex, a.pos))
                    })
                })
            }
        },
        {
            key: "_fireUpdate",
            value: function() {
                this.onChange && this.onChange(this, this.undoStack.length, this.redoStack.length)
            }
        },
        {
            key: "command",
            value: function(d) { ! this.suspend && d.hasDeltas() && (null != this.currentTransaction ? this.currentTransaction.addAction(d) : (this.undoStack.push(d), this.undoStack.length > this.maximumSize && this.undoStack.splice(this.undoStack.length - this.maximumSize - 1, this.undoStack.length - this.maximumSize), this.redoStack.length = 0, this._fireUpdate()))
            }
        },
        {
            key: "edgeChange",
            value: function(d, k) {
                var a = function(e) {
                    e.forEach(function(c) {
                        c instanceof Yd && c.edgeId === d ? c.edgeChange(k) : c instanceof qd && c.edgeChange(d, k)
                    })
                };
                a(this.undoStack);
                a(this.redoStack)
            }
        },
        {
            key: "undo",
            value: function() {
                var d = this.undoStack.pop();
                d && (this.suspend = !0, this.redoStack.push(d), d.undo(), this.suspend = !1, this._fireUpdate())
            }
        },
        {
            key: "redo",
            value: function() {
                var d = this.redoStack.pop();
                d && (this.suspend = !0, this.undoStack.push(d), d.redo(), this.suspend = !1, this._fireUpdate())
            }
        },
        {
            key: "clear",
            value: function() {
                this.undoStack.length = 0;
                this.redoStack.length = 0;
                this.currentTransaction = null;
                this.appendStack = 0;
                this._fireUpdate()
            }
        },
        {
            key: "transaction",
            value: function(d, k) {
                if (null != this.currentTransaction && null == k) pa("Cannot start a new transaction while one is active. Either commit/rollback the current transaction before creating a new one, or pass a cleanup flag in to this method");
                else {
                    this.openTransaction(k);
                    try {
                        var a = d();
                        if (!1 !== a) {
                            var e = this.currentTransaction;
                            return this.currentTransaction = null,
                            this.command(e),
                            a
                        }
                        this.rollbackTransaction()
                    } catch(c) {
                        pa("Exception thrown in transaction " + c.message + "; rolling transaction back"),
                        this.rollbackTransaction()
                    }
                }
            }
        },
        {
            key: "_createNewTransaction",
            value: function() {
                this.currentTransaction = new qd;
                this.appendStack = 0
            }
        },
        {
            key: "openTransaction",
            value: function(d) {
                var k = !0;
                if (null != this.currentTransaction) {
                    if (null == d) throw Error("Cannot start a new transaction while one is active. Either commit/rollback the current transaction before creating a new one, or pass a cleanup flag in to this method");
                    if (d === cl) this.commitTransaction();
                    else if (d === dl) this.rollbackTransaction();
                    else {
                        if (d !== Jc) throw Error("Cannot start a new transaction while one is active. Either commit/rollback the current transaction before creating a new one, or pass a cleanup flag in to this method");
                        k = !1;
                        this.appendStack++
                    }
                }
                return k && this._createNewTransaction(),
                k
            }
        },
        {
            key: "rollbackTransaction",
            value: function() {
                null != this.currentTransaction && (0 < this.appendStack ? (this.appendStack--, pa("Cannot rollback transaction from here; it has been appended to. Close all transaction appenders before attempting to rollback the transaction.")) : (this.currentTransaction.undo(), this.currentTransaction = null, this._fireUpdate()))
            }
        },
        {
            key: "commitTransaction",
            value: function() {
                if (null != this.currentTransaction) if (0 < this.appendStack) this.appendStack--;
                else {
                    var d = this.currentTransaction;
                    this.currentTransaction = null;
                    this.command(d)
                }
            }
        },
        {
            key: "_attach",
            value: function(d) {
                if (0 === this.undoStack.length) {
                    var k = new qd;
                    k.addAction(d);
                    this.command(k)
                } else if (k = this.undoStack[this.undoStack.length - 1], k instanceof qd) k.addAction(d);
                else {
                    this.undoStack.pop();
                    var a = new qd;
                    a.addAction(k);
                    a.addAction(d);
                    this.undoStack.push(a)
                }
            }
        }]),
        n
    } (),
    cl = "commitCurrent",
    dl = "rollbackCurrent",
    Jc = "appendToCurrent",
    $d = function() {},
    fl = function(n) {
        function d(a) {
            var e;
            ba(this, d);
            B(L(e = k.call(this)), "graph", void 0);
            B(L(e), "autoSaver", void 0);
            B(L(e), "idFunction", void 0);
            B(L(e), "typeProperty", void 0);
            B(L(e), "edgeTypeProperty", void 0);
            B(L(e), "portTypeProperty", void 0);
            B(L(e), "typeFunction", void 0);
            B(L(e), "edgeIdFunction", void 0);
            B(L(e), "edgeTypeFunction", void 0);
            B(L(e), "portIdFunction", void 0);
            B(L(e), "portTypeFunction", void 0);
            B(L(e), "portExtractor", void 0);
            B(L(e), "portUpdater", void 0);
            B(L(e), "portDataProperty", void 0);
            B(L(e), "portOrderProperty", void 0);
            B(L(e), "model", void 0);
            B(L(e), "suspendGraph", void 0);
            B(L(e), "dataLoading", void 0);
            B(L(e), "_originalData", void 0);
            B(L(e), "_originalDataType", void 0);
            B(L(e), "debugEnabled", void 0);
            B(L(e), "defaultObjectFactory", void 0);
            B(L(e), "nodeFactory", void 0);
            B(L(e), "edgeFactory", void 0);
            B(L(e), "portFactory", void 0);
            B(L(e), "groupFactory", void 0);
            B(L(e), "autoSave", void 0);
            B(L(e), "saveUrl", void 0);
            B(L(e), "autoSaveDebounceTimeout", void 0);
            B(L(e), "autoSaveHandler", void 0);
            B(L(e), "saveHeaders", void 0);
            B(L(e), "onAutoSaveSuccess", void 0);
            B(L(e), "onAutoSaveError", void 0);
            B(L(e), "doNotUpdateOriginalData", void 0);
            B(L(e), "onBeforeAutoSave", void 0);
            B(L(e), "onAfterAutoSave", void 0);
            B(L(e), "portSeparator", ".");
            B(L(e), "defaultCost", void 0);
            B(L(e), "defaultDirected", void 0);
            B(L(e), "enableSubgraphs", void 0);
            B(L(e), "undoRedo", void 0);
            B(L(e), "graphParams", void 0);
            B(L(e), "beforeConnect", void 0);
            B(L(e), "beforeMoveConnection", void 0);
            B(L(e), "beforeStartConnect", void 0);
            B(L(e), "beforeDetach", void 0);
            B(L(e), "beforeStartDetach", void 0);
            B(L(e), "_currentSelection", void 0);
            B(L(e), "_renderersById", new Map);
            var c = (a = a || {}).undoRedo || {}; ! 1 !== c.enabled && (e.undoRedo = new el({
                toolkit: L(e),
                maximumSize: c.maximumSize,
                onChange: function(h, b, g) {
                    e.fire("undoredo:update", {
                        undoCount: b,
                        redoCount: g
                    })
                }
            }));
            e.idFunction = a.idFunction || cg;
            e.typeProperty = a.typeProperty || "type";
            e.edgeTypeProperty = a.edgeTypeProperty || "type";
            e.portTypeProperty = a.portTypeProperty || "type";
            e.typeFunction = a.typeFunction ||
            function(h) {
                return h[e.typeProperty] || "default"
            };
            e.edgeIdFunction = a.edgeIdFunction || e.idFunction;
            e.edgeTypeFunction = a.edgeTypeFunction ||
            function(h) {
                return h[e.edgeTypeProperty] || "default"
            };
            e.portIdFunction = a.portIdFunction || e.idFunction;
            e.portTypeFunction = a.portTypeFunction ||
            function(h) {
                return h[e.portTypeProperty] || "default"
            };
            e.portExtractor = a.portExtractor;
            e.portUpdater = a.portUpdater;
            e.portDataProperty = a.portDataProperty;
            e.portOrderProperty = a.portOrderProperty;
            e.suspendGraph = !1;
            e.debugEnabled = !1;
            e.model = new Mk(L(e), a.model);
            e.defaultObjectFactory = function(h, b, g) {
                return b = null != b && V(b) ? b: {},
                (b = O(b)).id = b.id || fa(),
                b.type = b.type || (null == h ? null: h.type || h),
                g(b),
                !0
            };
            e.nodeFactory = a.nodeFactory || e.defaultObjectFactory;
            e.edgeFactory = a.edgeFactory || e.defaultObjectFactory;
            e.portFactory = a.portFactory || e.defaultObjectFactory;
            e.groupFactory = a.groupFactory || e.defaultObjectFactory;
            e.autoSave = !0 === a.autoSave && (null != a.saveUrl || null != a.autoSaveHandler);
            e.autoSaveDebounceTimeout = a.autoSaveDebounceTimeout;
            e.autoSaveHandler = a.autoSaveHandler;
            e.saveUrl = a.saveUrl;
            e.saveHeaders = a.saveHeaders;
            e.onAutoSaveSuccess = a.onAutoSaveSuccess || $d;
            e.onAutoSaveError = a.onAutoSaveError || $d;
            e.doNotUpdateOriginalData = !0 === a.doNotUpdateOriginalData;
            e.onBeforeAutoSave = a.onBeforeAutoSave || $d;
            e.onAfterAutoSave = a.onAfterAutoSave || $d;
            e.graphParams = {
                portSeparator: a.portSeparator,
                defaultCost: a.defaultCost,
                defaultDirected: a.defaultDirected,
                enableSubgraphs: a.enableSubgraphs
            };
            null != e.portDataProperty && null == e.portExtractor && (e.portExtractor = function(h) {
                h = h[e.portDataProperty] || [];
                return null != e.portOrderProperty && h.sort(function(b, g) {
                    b = b[e.portOrderProperty];
                    g = g[e.portOrderProperty];
                    return (null == b ? 1 / 0 : b) - (null == g ? 1 / 0 : g)
                }),
                h
            });
            null != e.portDataProperty && null == e.portUpdater && (e.portUpdater = function(h, b, g) {
                b = {};
                return null != e.portOrderProperty && g.sort(function(m, r) {
                    m = m.data[e.portOrderProperty];
                    r = r.data[e.portOrderProperty];
                    return (null == m ? 1 / 0 : m) - (null == r ? 1 / 0 : r)
                }),
                b[e.portDataProperty] = g.map(function(m) {
                    return m.data
                }),
                A(h, b)
            });
            e.graph = new Ph(e.graphParams);
            e.autoSave && (e.autoSaver = new bi(L(e), {
                saveUrl: e.saveUrl,
                saveHeaders: e.saveHeaders,
                onAutoSaveSuccess: e.onAutoSaveSuccess,
                onAutoSaveError: e.onAutoSaveError,
                onBeforeAutoSave: e.onBeforeAutoSave,
                onAfterAutoSave: e.onAfterAutoSave,
                autoSaveDebounceTimeout: e.autoSaveDebounceTimeout,
                autoSaveHandler: e.autoSaveHandler
            }));
            new Pk(L(e));
            c = function(h, b) {
                if (null == e.model) return ! 0;
                var g = e.getType(h),
                m = e.getType(b),
                r = qa(h) ? h.getParent() : h,
                t = qa(b) ? b.getParent() : b,
                u = qa(h) ? e.model.getPortDefinition(g) : ka(h) ? e.model.getNodeDefinition(g) : e.model.getGroupDefinition(g),
                v = qa(b) ? e.model.getPortDefinition(m) : ka(b) ? e.model.getNodeDefinition(m) : e.model.getGroupDefinition(m);
                g = ka(r) ? e.model.getNodeDefinition(g) : e.model.getGroupDefinition(g);
                m = ka(t) ? e.model.getNodeDefinition(m) : e.model.getGroupDefinition(m);
                return ! (null != u.maxConnections && h.getEdges().length >= u.maxConnections) && !(null != v.maxConnections && b.getEdges().length >= v.maxConnections) && (h === b ? !(!1 === g.allowLoopback || !1 === u.allowLoopback || !1 === v.allowLoopback || !1 === m.allowLoopback) : r !== t || !(!1 === g.allowVertexLoopback || !1 === u.allowVertexLoopback || !1 === v.allowVertexLoopback || !1 === m.allowVertexLoopback))
            };
            return e.beforeConnect = a.beforeConnect || c,
            e.beforeMoveConnection = a.beforeMoveConnection || c,
            e.beforeStartConnect = a.beforeStartConnect ||
            function(h, b) {
                return {}
            },
            e.beforeDetach = a.beforeDetach ||
            function(h, b, g) {
                return ! 0
            },
            e.beforeStartDetach = a.beforeStartDetach ||
            function(h, b) {
                return ! 0
            },
            e._currentSelection = e._createSelection(function(h) {
                e.fire("selection:cleared", {
                    selection: h
                })
            }),
            a.maxSelectedNodes && e._currentSelection.setMaxNodes(a.maxSelectedNodes),
            a.maxSelectedGroups && e._currentSelection.setMaxGroups(a.maxSelectedGroups),
            a.maxSelectedEdges && e._currentSelection.setMaxEdges(a.maxSelectedEdges),
            a.selectionCapacityPolicy && e._currentSelection.setCapacityPolicy(a.selectionCapacityPolicy),
            null != a.data && e.load({
                data: a.data
            }),
            e
        }
        Fa(d, $e);
        var k = Ga(d);
        return ca(d, [{
            key: "_createSelection",
            value: function(a) {
                return new Db(this, {
                    onClear: a ||
                    function() {}
                })
            }
        },
        {
            key: "filter",
            value: function(a, e) {
                var c = "function" == typeof a ? a: function(b) {
                    b = b.data;
                    var g = !1,
                    m;
                    for (m in a) {
                        var r = a[m] === b[m];
                        if (!r && !e) return ! 1;
                        g = g || r
                    }
                    return g
                },
                h = this._createSelection();
                return this.eachNode(function(b, g) {
                    c(g) && h.append(g);
                    b = g.getPorts();
                    for (g = 0; g < b.length; g++) c(b[g]) && h.append(b[g])
                }),
                this.eachEdge(function(b, g) {
                    c(g) && h.append(g)
                }),
                this.eachGroup(function(b, g) {
                    c(g) && h.append(g)
                }),
                h
            }
        },
        {
            key: "getModel",
            value: function() {
                return this.model
            }
        },
        {
            key: "setSuspendGraph",
            value: function(a) {
                this.suspendGraph = a
            }
        },
        {
            key: "setAutoSave",
            value: function(a) {
                null != this.autoSaver && this.autoSaver.discard();
                this.autoSaver = new bi(this, a)
            }
        },
        {
            key: "setDoNotUpdateOriginalData",
            value: function(a) {
                this.doNotUpdateOriginalData = a
            }
        },
        {
            key: "getTypeFunction",
            value: function() {
                return this.typeFunction
            }
        },
        {
            key: "connect",
            value: function(a) {
                var e;
                if (!this.suspendGraph) {
                    var c = this.graph.getVertex(a.source),
                    h = this.graph.getVertex(a.target),
                    b = a.cost,
                    g = a.directed;
                    if (!c) {
                        if (a.doNotCreateMissingNodes) return;
                        c = this.graph.addNode(a.source);
                        this.fire("node:added", {
                            data: {},
                            node: c
                        })
                    }
                    if (!h) {
                        if (a.doNotCreateMissingNodes) return;
                        h = this.graph.addNode(a.target);
                        this.fire("node:added", {
                            data: {},
                            node: h
                        })
                    }
                    var m = a.data || {},
                    r = this.beforeStartConnect(c, this.edgeTypeFunction(m));
                    r && ("object" === Uc(r) && (m = A(r, m)), !1 !== this.beforeConnect(c, h, m) && (e = this.graph.addEdge({
                        source: c,
                        target: h,
                        cost: b,
                        directed: g,
                        data: m,
                        geometry: a.geometry
                    }), this.fire("edge:added", {
                        edge: e,
                        geometry: a.geometry,
                        addedByMouse: !1
                    })))
                }
                return e
            }
        },
        {
            key: "clear",
            value: function() {
                return this.fire("graphClearStart"),
                this.graph.clear(),
                this.fire("graphCleared"),
                this
            }
        },
        {
            key: "getGraph",
            value: function() {
                return this.graph
            }
        },
        {
            key: "getNodeCount",
            value: function() {
                return this.graph.getVertexCount()
            }
        },
        {
            key: "getNodeAt",
            value: function(a) {
                return this.graph.getVertexAt(a)
            }
        },
        {
            key: "getNodes",
            value: function() {
                return this.graph.getVertices()
            }
        },
        {
            key: "eachNode",
            value: function(a) {
                for (var e = 0,
                c = this.graph.getVertexCount(); e < c; e++) a(e, this.graph.getVertexAt(e))
            }
        },
        {
            key: "eachGroup",
            value: function(a) {
                for (var e = 0,
                c = this.graph.getGroupCount(); e < c; e++) a(e, this.graph.getGroupAt(e))
            }
        },
        {
            key: "eachVertex",
            value: function(a) {
                this.eachNode(a);
                this.eachGroup(a)
            }
        },
        {
            key: "eachEdge",
            value: function(a) {
                for (var e = this.graph.getEdges(), c = 0, h = e.length; c < h; c++) a(c, e[c])
            }
        },
        {
            key: "getEdgeCount",
            value: function() {
                return this.graph.getEdgeCount()
            }
        },
        {
            key: "getGroupCount",
            value: function() {
                return this.graph.getGroupCount()
            }
        },
        {
            key: "getGroupAt",
            value: function(a) {
                return this.graph.getGroupAt(a)
            }
        },
        {
            key: "getGroups",
            value: function() {
                return this.graph.getGroups()
            }
        },
        {
            key: "getClusters",
            value: function() {
                return this.graph.getClusters()
            }
        },
        {
            key: "getNodeId",
            value: function(a) {
                return "string" == typeof a ? a: this.idFunction(a)
            }
        },
        {
            key: "getNodeType",
            value: function(a) {
                return this.typeFunction(a) || "default"
            }
        },
        {
            key: "getEdgeId",
            value: function(a) {
                return this.edgeIdFunction(a)
            }
        },
        {
            key: "getEdgeType",
            value: function(a) {
                return this.edgeTypeFunction(a) || "default"
            }
        },
        {
            key: "getPortId",
            value: function(a) {
                return this.portIdFunction(a)
            }
        },
        {
            key: "getPortType",
            value: function(a) {
                return this.portTypeFunction(a) || "default"
            }
        },
        {
            key: "getType",
            value: function(a) {
                return (ka(a) ? this.typeFunction: qa(a) ? this.portTypeFunction: this.edgeTypeFunction)(a.data) || "default"
            }
        },
        {
            key: "setType",
            value: function(a, e) {
                var c = this.getType(a);
                if (c !== e) {
                    var h, b = a.objectType === Pa.objectType ? this.typeProperty: a.objectType === oa.objectType ? this.portTypeProperty: this.edgeTypeProperty;
                    ka(a) ? h = "node:typeChanged": qa(a) ? h = "port:typeChanged": Wc(a) ? h = "edge:typeChanged": ra(a) && (h = "group:typeChanged");
                    a.data[b] = e;
                    null != h && this.fire(h, {
                        obj: a,
                        previousType: c,
                        newType: e
                    })
                }
            }
        },
        {
            key: "addNode",
            value: function(a, e, c) {
                var h = this.idFunction(a),
                b = null;
                null == h && "string" != typeof a && (a.id = fa());
                var g = this.graph.addNode(a, this.idFunction);
                if (null != g) {
                    if (null != this.portExtractor && (h = this.portExtractor(g.data, g), null != h)) for (var m = 0; m < h.length; m++) g.addPort(h[m], this.portIdFunction);
                    if ("string" != typeof a && null != a.group) {
                        if (null == (b = this.getGroup(a.group))) throw Error("parent group [" + a.group + "] not found");
                        b.addMember(g)
                    }
                    return this.dataLoading || this.doNotUpdateOriginalData || Ub(Na.addNode, this._originalData, this._originalDataType, g, this.idFunction || this.graph.getIdFunction()),
                    c || this.fire("node:added", {
                        data: a,
                        node: g,
                        eventInfo: e,
                        parentGroup: b
                    }),
                    null != b && this.fire("group:member:added", {
                        group: b,
                        vertex: g,
                        vertexIsNew: !0
                    }),
                    g
                }
                return this.graph.getVertex(h)
            }
        },
        {
            key: "addFactoryNode",
            value: function(a, e, c, h) {
                var b = this;
                null == c && (null != e ? (e = "object" === Uc(e) ? e: {},
                c = "function" == typeof e ? e: null) : e = {});
                e.type = e.type || a;
                this.openTransaction();
                this.nodeFactory(a, e,
                function(g) {
                    g = b.addNode(g);
                    c && c(g);
                    b.commitTransaction()
                },
                function() {
                    h && h();
                    b.rollbackTransaction()
                })
            }
        },
        {
            key: "addNodes",
            value: function(a) {
                for (var e = 0; e < a.length; e++) this.addNode(a[e]);
                return this
            }
        },
        {
            key: "addFactoryGroup",
            value: function(a, e, c, h) {
                var b = this;
                null == c && (null != e ? (e = "object" === Uc(e) ? e: {},
                c = "function" == typeof e ? e: null) : null == e && null == c && (e = {}));
                e.type = e.type || a;
                this.openTransaction();
                this.groupFactory(a, e,
                function(g) {
                    g = b.addGroup(g);
                    c && c(g);
                    b.commitTransaction()
                },
                function() {
                    h && h();
                    b.rollbackTransaction()
                })
            }
        },
        {
            key: "addGroup",
            value: function(a, e, c) {
                var h, b;
                if (null == this.idFunction(a) && "string" != typeof a && (a.id = fa()), null != (b = this.graph.addGroup(a, this.idFunction))) {
                    if ("string" != typeof a && null != a.group) {
                        if (null == (h = this.getGroup(a.group))) throw Error("Cannot find parent group [" + a.group + "]");
                        h.addMember(b)
                    }
                    this.dataLoading || this.doNotUpdateOriginalData || Ub(Na.addGroup, this._originalData, this._originalDataType, b, this.idFunction || this.graph.getIdFunction());
                    c || (this.fire("group:added", {
                        data: a,
                        group: b,
                        eventInfo: e,
                        parentGroup: h
                    }), null != h && this.fire("group:member:added", {
                        group: h,
                        vertex: b,
                        vertexIsNew: !0
                    }))
                }
                return b
            }
        },
        {
            key: "addToGroup",
            value: function(a, e, c, h, b) {
                var g = !1;
                e = this.getObjectInfo(e);
                a = this.getObjectInfo(a);
                a.obj && e.obj && (g = e.obj.addMember(a.obj)) && (a.obj.data.group = e.obj.id, h = {
                    vertex: a.obj,
                    group: e.obj,
                    pos: h,
                    source: b
                },
                c && (h.sourceGroup = c), this.fire("group:member:added", h), this.fire("dataUpdated"));
                return g
            }
        },
        {
            key: "removeFromGroup",
            value: function(a, e, c, h) {
                var b;
                a = this.getObjectInfo(a);
                a.obj && a.obj.group && (b = a.obj.group).removeMember(a.obj) && ((delete a.obj.data.group, e) || (e = {
                    group: b,
                    source: h,
                    vertex: a.obj
                },
                c && (e.targetGroup = c), this.fire("group:member:removed", e)), this.fire("dataUpdated"));
                return b
            }
        },
        {
            key: "_notifyGroupRemoved",
            value: function(a, e, c) {
                var h = this;
                a.nestedGroups.forEach(function(g) {
                    return h._notifyGroupRemoved(g, e, c)
                });
                a.nodes.forEach(function(g) {
                    return h._notifyNodeRemoved(g, c)
                });
                for (var b = 0; b < a.edges.length; b++) this._notifyEdgeRemoved(a.edges[b]);
                e || a.children.forEach(function(g) {});
                this.dataLoading || this.doNotUpdateOriginalData || Ub(Na.removeGroup, this._originalData, this._originalDataType, a.group, this.idFunction || this.graph.getIdFunction());
                c || this.fire("group:removed", {
                    group: a.group,
                    groupId: a.group.id,
                    removeChildren: e,
                    children: a.children,
                    parentGroup: a.parentGroup
                })
            }
        },
        {
            key: "_notifyNodeRemoved",
            value: function(a, e) {
                for (var c = 0; c < a.edges.length; c++) this._notifyEdgeRemoved(a.edges[c]);
                this.dataLoading || this.doNotUpdateOriginalData || Ub(Na.removeNode, this._originalData, this._originalDataType, a.node, this.idFunction || this.graph.getIdFunction());
                e || this.fire("node:removed", {
                    node: a.node,
                    nodeId: a.node.id,
                    edges: a.edges,
                    parentGroup: a.parentGroup
                })
            }
        },
        {
            key: "removeGroup",
            value: function(a, e, c) { (a = this.getObjectInfo(a)) && a.obj && (a = a.obj, this.openTransaction(Jc), a = this.graph.deleteGroup(a, e), a.group && this._notifyGroupRemoved(a, e, c), this.commitTransaction())
            }
        },
        {
            key: "getNode",
            value: function(a) {
                return this.graph.getVertex(a)
            }
        },
        {
            key: "getEdge",
            value: function(a) {
                return this.graph.getEdge(a)
            }
        },
        {
            key: "getGroup",
            value: function(a) {
                return this.graph.getGroup(a)
            }
        },
        {
            key: "getVertex",
            value: function(a) {
                return this.getNode(a) || this.getGroup(a)
            }
        },
        {
            key: "getPort",
            value: function(a) {
                var e = this.graph.getVertexByPortId(a);
                if (e) return e.getPort(this.graph.splitPortId(a)[1])
            }
        },
        {
            key: "exists",
            value: function() {
                for (var a = 0; a < arguments.length; a++) if (null == this.graph.getVertex(0 > a || arguments.length <= a ? void 0 : arguments[a])) return ! 1;
                return ! 0
            }
        },
        {
            key: "removeNode",
            value: function(a, e) {
                this.openTransaction(Jc);
                a = this.graph.getVertex(a);
                for (var c = a.getAllEdges() || [], h = 0; h < c.length; h++) this.removeEdge(c[h]);
                a.group;
                a = this.graph.deleteNode(a);
                return this._notifyNodeRemoved(a, e),
                this.commitTransaction(),
                this
            }
        },
        {
            key: "addEdge",
            value: function(a, e, c) {
                var h = this.graph.addEdge(a, this.edgeIdFunction, this.beforeConnect);
                return null != h ? (this.dataLoading || this.doNotUpdateOriginalData || Ub(Na.addEdge, this._originalData, this._originalDataType, h, this.idFunction || this.graph.getIdFunction()), c || this.fire("edge:added", {
                    edge: h,
                    source: e,
                    geometry: a.geometry,
                    addedByMouse: a.addedByMouse
                },
                null)) : this.debugEnabled && pa("Could not add edge"),
                h
            }
        },
        {
            key: "_notifyEdgeRemoved",
            value: function(a, e) {
                this.dataLoading || this.doNotUpdateOriginalData || Ub(Na.removeEdge, this._originalData, this._originalDataType, a, this.idFunction || this.graph.getIdFunction());
                this.fire("edge:removed", {
                    edge: a,
                    source: e
                },
                null)
            }
        },
        {
            key: "removeEdge",
            value: function(a, e) {
                a = this.graph.getEdge(a);
                return null != a && (this.graph.deleteEdge(a), this._notifyEdgeRemoved(a, e)),
                this
            }
        },
        {
            key: "edgeMoved",
            value: function(a, e, c) {
                0 === c ? this.setSource(a, e) : 1 === c && this.setTarget(a, e)
            }
        },
        {
            key: "setTarget",
            value: function(a, e, c) {
                a = this.graph.setTarget(a, e);
                return ! 1 === a.success || c || this.fire("edge:target", a),
                a
            }
        },
        {
            key: "setSource",
            value: function(a, e, c) {
                a = this.graph.setSource(a, e);
                return ! 1 === a.success || c || this.fire("edge:source", a),
                a
            }
        },
        {
            key: "addNewPort",
            value: function(a, e, c, h) {
                var b = this,
                g = this.graph.getVertex(a);
                this.portFactory({
                    node: g,
                    type: e
                },
                c,
                function(m) {
                    var r = b.portIdFunction(m);
                    r = g.addPort(r);
                    r.data = m;
                    b._updateVertexAfterPortChange(g, "addnewport");
                    b.dataLoading || b.doNotUpdateOriginalData || Ub(Na.addPort, b._originalData, b._originalDataType, {
                        node: g,
                        port: r
                    },
                    b.idFunction || b.graph.getIdFunction());
                    h || b.fire("port:added", {
                        vertex: g,
                        data: m,
                        port: r
                    },
                    null)
                },
                function() {})
            }
        },
        {
            key: "addPort",
            value: function(a, e, c) {
                a = this.graph.getVertex(a);
                var h = a.addPort(e, this.portIdFunction);
                return this._updateVertexAfterPortChange(a, "addport"),
                this.dataLoading || this.doNotUpdateOriginalData || Ub(Na.addPort, this._originalData, this._originalDataType, {
                    node: a,
                    port: h
                },
                this.idFunction || this.graph.getIdFunction()),
                c || this.fire("port:added", {
                    vertex: a,
                    data: e,
                    port: h
                },
                null),
                h
            }
        },
        {
            key: "removePort",
            value: function(a, e) {
                var c;
                if ("string" == typeof a) {
                    var h = this.graph.splitPortId(a);
                    2 === h.length ? (c = this.graph.getVertex(h[0]), e = h[1]) : c = this.graph.getVertex(a)
                } else qa(a) ? (e = a.id, c = a.getParent()) : c = this.graph.getVertex(a);
                if (null != c && null != e && (a = c.getPort(e))) {
                    e = a.getAllEdges();
                    h = e.length;
                    for (var b = 0; b < h; b++) this.removeEdge(e[0]);
                    return c.removePort(a),
                    this._updateVertexAfterPortChange(c, "removeport"),
                    this.fire("port:removed", {
                        vertex: c,
                        port: a,
                        edges: e
                    },
                    null),
                    !0
                }
                return ! 1
            }
        },
        {
            key: "remove",
            value: function(a) {
                if (null != a) {
                    var e = this.getObjectInfo(a);
                    this.setSuspendRendering(!0);
                    try {
                        if (!e.obj || e.type !== Pa.objectType && e.type !== ab.objectType && e.type !== cb.objectType) {
                            for (; 0 < a.getNodeCount();) this.removeNode(a.getNodeAt(0));
                            for (; 0 < a.getEdgeCount();) this.removeEdge(a.getEdgeAt(0));
                            for (; 0 < a.getGroupCount();) this.removeGroup(a.getGroupAt(0))
                        } else this["remove" + e.type](e.obj)
                    } finally {
                        this.setSuspendRendering(!1, !0)
                    }
                }
            }
        },
        {
            key: "setSuspendRendering",
            value: function(a, e) {
                for (var c in this._renderersById) this._renderersById[c].setSuspendRendering(a, e)
            }
        },
        {
            key: "batch",
            value: function(a) {
                this.setSuspendRendering(!0);
                try {
                    a()
                } catch(e) {
                    console.log("Error in transaction " + e)
                } finally {
                    this.setSuspendRendering(!1, !0)
                }
            }
        },
        {
            key: "updateGroup",
            value: function(a, e) {
                this.updateVertex(a, e)
            }
        },
        {
            key: "updateNode",
            value: function(a, e) {
                this.updateVertex(a, e)
            }
        },
        {
            key: "updateVertex",
            value: function(a, e) {
                a = this.getObjectInfo(a);
                if (a.obj) {
                    var c = (qa(a.obj) ? a.obj.getParent() : a.obj).objectType === Pa.objectType ? "node:updated": "group:updated";
                    this._updateVertex(a.obj, e, c,
                    function(h, b) {
                        return {
                            vertex: h,
                            updates: e || {},
                            originalData: b
                        }
                    })
                }
            }
        },
        {
            key: "updatePort",
            value: function(a, e) {
                a = this.getObjectInfo(a);
                a.obj && this._updateVertex(a.obj, e, "port:updated",
                function(c, h) {
                    return {
                        port: c,
                        vertex: c.getParent(),
                        updates: e || {},
                        originalData: h
                    }
                })
            }
        },
        {
            key: "updateEdge",
            value: function(a, e) {
                a = "string" == typeof a ? this.graph.getEdge(a) : a;
                if (null != a) {
                    var c = A({},
                    a.data);
                    if (e) for (var h in e) null == a.data[h] ? a.data[h] = e[h] : vf(a.data, h, e[h]);
                    this.fire("edge:updated", {
                        edge: a,
                        updates: e || {},
                        originalData: c
                    },
                    null)
                }
            }
        },
        {
            key: "update",
            value: function(a, e) {
                ka(a) || ra(a) ? this.updateVertex(a, e) : Wc(a) ? this.updateEdge(a, e) : qa(a) && this.updatePort(a, e)
            }
        },
        {
            key: "setEdgeGeometry",
            value: function(a, e, c) {
                var h = O(a.geometry);
                a.geometry = e;
                this.fire("edge:pathEdited", {
                    edge: a,
                    geometry: e,
                    originalGeometry: h,
                    renderer: c
                });
                this.fire("dataUpdated")
            }
        },
        {
            key: "getPath",
            value: function(a) {
                return new Sh(this, a)
            }
        },
        {
            key: "findGraphObject",
            value: function(a) {
                return null == a ? null: "*" === a ? this.graph: a.constructor === Pa || a.constructor === oa || a.constructor === cb || a.constructor === ab ? a: J(a) || V(a) ? this.graph.getVertex(a) : null
            }
        },
        {
            key: "_select",
            value: function(a, e, c, h) {
                var b = this;
                return e || c.clear(),
                c.append(a,
                function(g) {
                    h && b.fire("select", {
                        append: e,
                        obj: g,
                        selection: c
                    })
                })
            }
        },
        {
            key: "_selectEdges",
            value: function(a, e, c) {
                var h = this;
                a = a || {};
                var b = [],
                g = {},
                m = function(r, t, u, v) {
                    if (null != r) for (var w = r[e]({
                        filter: a.filter
                    }), z = 0; z < w.length; z++) {
                        var y = t && r === h.graph || w[z].source === r || c && qa(w[z].source) && w[z].source.getParent() === r,
                        E = u && r === h.graph || w[z].target === r || c && qa(w[z].target) && w[z].target.getParent() === r; (t && y || u && E || v && (y || E)) && (F = w[z], g[F.getId()] || (b.push(F), g[F.getId()] = !0))
                    }
                    var F
                };
                return m(this.findGraphObject(a.source), !0, !1, !1),
                m(this.findGraphObject(a.target), !1, !0, !1),
                m(this.findGraphObject(a.element), !1, !1, !0),
                b
            }
        },
        {
            key: "_updateVertex",
            value: function(a, e, c, h) {
                if (a && a.objectType) {
                    var b, g = A({},
                    a.data),
                    m = a.objectType === oa.objectType ? a.getFullId() : a.id,
                    r = a.objectType === oa.objectType ? this.portIdFunction(g) : null;
                    if (e) {
                        for (var t in e) vf(a.data, t, e[t]);
                        a.objectType === oa.objectType && ((b = this.portIdFunction(a.data)) !== a.id && this.graph.renamePort(a, b), this._updateVertexAfterPortChange(a.getParent(), "updateport"))
                    }
                    a = h(a, g);
                    a.originalId = m;
                    null != r && (a.originalPortId = r);
                    this.fire(c, a, null)
                }
            }
        },
        {
            key: "_updateVertexAfterPortChange",
            value: function(a, e) {
                if (null != this.portUpdater) {
                    var c = this.portUpdater(a.data, a, a.getPorts());
                    null == c || (a.data = c, this.dataLoading) || (c = ra(a) ? "group:updated": "node:updated", this.fire(c, {
                        vertex: a,
                        updates: {},
                        originalData: a.data,
                        reason: e
                    }))
                }
            }
        },
        {
            key: "getEdges",
            value: function(a) {
                return this._selectEdges(a, "getEdges", !1)
            }
        },
        {
            key: "getAllEdges",
            value: function() {
                return this.graph.getAllEdges()
            }
        },
        {
            key: "getAllEdgesFor",
            value: function(a, e) {
                return a.getAllEdges({
                    filter: e
                })
            }
        },
        {
            key: "selectAllEdges",
            value: function() {
                return this.filter(Wc)
            }
        },
        {
            key: "addAllEdgesToSelection",
            value: function() {
                this.addToSelection(this.getAllEdges())
            }
        },
        {
            key: "setSelection",
            value: function(a) {
                a = this._resolveObjectForSelection(a);
                this._select(a, !1, this._currentSelection, !0)
            }
        },
        {
            key: "select",
            value: function(a, e) {
                var c = this._createSelection();
                a = this._resolveObjectForSelection(a);
                a = this._select(a, !0, c);
                if (e) for (e = 0; e < a[0].length; e++) {
                    var h = a[0][e];
                    if (ka(h || ra(h) || qa(h))) {
                        h = h.getAllEdges();
                        for (var b = 0; b < h.length; b++) c.append(h[b])
                    }
                }
                return c
            }
        },
        {
            key: "_descendants",
            value: function(a, e, c, h) {
                for (var b = a.getAllEdges(), g = 0, m = b.length; g < m; g++) if (b[g].source === a) {
                    var r = b[g].target,
                    t = r.getFullId();
                    h[t] || (e.append(r), c && e.append(b[g]), h[t] = !0, this._descendants(r, e, c, h))
                }
            }
        },
        {
            key: "selectDescendants",
            value: function(a, e, c) {
                a = this.getObjectInfo(a);
                var h = this._createSelection();
                a.obj && a.obj.objectType === Pa.objectType && (e && this._select(a.obj, !0, h), e = {},
                e[a.obj.getFullId()] = !0, this._descendants(a.obj, h, c, e));
                return h
            }
        },
        {
            key: "_resolveObjectForSelection",
            value: function(a) {
                var e = this;
                return a instanceof Sh || a instanceof Db ? a: J(a) ? this.getVertex(a) || this.getEdge(a) : Array.isArray(a) ? pe(a,
                function(c) {
                    return J(c) ? e.getVertex(a) || e.getEdge(a) : c
                }) : a
            }
        },
        {
            key: "addToSelection",
            value: function(a) {
                if (a = this._resolveObjectForSelection(a)) a = this._select(a, !0, this._currentSelection, !0),
                null != a[1] && this._adhocSel("deselect", a[1]),
                null != a[0] && this._adhocSel("select", a[0])
            }
        },
        {
            key: "_adhocSel",
            value: function(a, e) {
                for (var c = 0; c < e.length; c++) this.fire(a, {
                    obj: e[c],
                    selection: this._currentSelection
                })
            }
        },
        {
            key: "toggleSelection",
            value: function(a) {
                if (a = this._resolveObjectForSelection(a)) {
                    var e = [];
                    a = this._currentSelection.toggle(a,
                    function(c, h) {
                        h || e.push(c)
                    });
                    this._adhocSel("deselect", a[1]);
                    this._adhocSel("deselect", e);
                    this._adhocSel("select", a[0])
                }
            }
        },
        {
            key: "removeFromSelection",
            value: function(a) {
                var e = this; (a = this._resolveObjectForSelection(a)) && this._currentSelection.remove(a,
                function(c) {
                    e.fire("deselect", {
                        obj: c,
                        selection: e._currentSelection
                    })
                })
            }
        },
        {
            key: "addPathToSelection",
            value: function(a) {
                this.addToSelection(this.getPath(a))
            }
        },
        {
            key: "clearSelection",
            value: function() {
                this._currentSelection.clear()
            }
        },
        {
            key: "getSelection",
            value: function() {
                return this._currentSelection
            }
        },
        {
            key: "setMaxSelectedNodes",
            value: function(a) {
                this._currentSelection.setMaxNodes(a)
            }
        },
        {
            key: "setMaxSelectedEdges",
            value: function(a) {
                this._currentSelection.setMaxEdges(a)
            }
        },
        {
            key: "setSelectionCapacityPolicy",
            value: function(a) {
                this._currentSelection.setCapacityPolicy(a)
            }
        },
        {
            key: "_notifyDataLoaded",
            value: function(a) {
                this.setSuspendGraph(!0);
                this.fire(a);
                this.setSuspendGraph(!1);
                this.dataLoading = !1
            }
        },
        {
            key: "_doLoad",
            value: function(a, e, c) {
                var h = this,
                b = (a = a || {}).type || "json",
                g = a.data,
                m = a.url,
                r = a.jsonp,
                t = a.onload,
                u = a.parameters || {},
                v = a.error ||
                function(z) {};
                if (null == g && null == m) throw new TypeError("You must supply either data or url to load.");
                var w = function(z) {
                    h._originalData = z;
                    h._originalDataType = b;
                    h.dataLoading = !0;
                    h.fire(e);
                    var y = Sk[b];
                    if (null == y) throw Error("jsPlumb Toolkit - parse - [" + b + "] is an unsupported type");
                    y(z, h, u);
                    h._notifyDataLoaded(c);
                    t && t(h, z);
                    h.fire("graphChanged")
                };
                g ? w(g) : m && (r && (g = -1 === m.indexOf("?") ? "?": "&", m = m + g + "callback=?"), this.loadData({
                    url: m,
                    success: w,
                    dataType: "json" === b ? b: a.dataType,
                    error: v,
                    headers: a.headers || {
                        Accept: "application/json"
                    }
                }));
                return this
            }
        },
        {
            key: "load",
            value: function(a) {
                return this._doLoad(a, "dataLoadStart", "dataLoadEnd")
            }
        },
        {
            key: "append",
            value: function(a) {
                return this._doLoad(a, "dataAppendStart", "dataAppendEnd")
            }
        },
        {
            key: "save",
            value: function(a) {
                if (null == a) throw Error("JSPLUMB: save method requires at least URL parameter - no params given.");
                if (null == a.url) throw Error("JSPLUMB: save method requires at least URL parameter");
                var e = this.exportData(a),
                c = {
                    "Content-Type": "application/json"
                };
                return A(c, a.headers || {}),
                this.loadData({
                    url: a.url,
                    type: "POST",
                    data: e,
                    success: a.success ||
                    function(h) {},
                    error: a.error ||
                    function(h) {},
                    headers: c
                }),
                this
            }
        },
        {
            key: "exportData",
            value: function(a) {
                var e = (a = a || {}).type || "json",
                c = Rk[e];
                if (null === c) throw Error("jsPlumb Toolkit - exportData - [" + e + "]  is an unsupported type");
                return c(this, a.parameters)
            }
        },
        {
            key: "getRenderer",
            value: function(a) {
                return this._renderersById.get(a)
            }
        },
        {
            key: "getRenderers",
            value: function() {
                return this._renderersById
            }
        },
        {
            key: "addRenderer",
            value: function(a, e) {
                var c = this;
                e = e || fa();
                this._renderersById.set(e, a);
                a.id = e;
                a.bind("destroy",
                function(h) {
                    c._renderersById.delete(h.id)
                });
                this.fire("renderer:added", {
                    renderer: a,
                    id: e
                })
            }
        },
        {
            key: "getObjectInfo",
            value: function(a) {
                var e = {
                    obj: null,
                    type: null,
                    id: null
                };
                if (null != a) {
                    if ("string" == typeof a) a = this.getNode(a) || this.getGroup(a) || this.getPort(a) || this.getEdge(a);
                    else if ("object" === Uc(a) && void 0 === a.objectType) {
                        var c = this.idFunction(a);
                        a = this.edgeIdFunction(a);
                        a = this.getNode(c) || this.getGroup(c) || this.getEdge(a)
                    }
                    if (null == a) return e;
                    e.obj = a;
                    null != e.obj && (e.id = e.obj.id, e.type = e.obj.objectType)
                }
                return e
            }
        },
        {
            key: "undo",
            value: function() {
                this.undoRedo && this.undoRedo.undo()
            }
        },
        {
            key: "redo",
            value: function() {
                this.undoRedo && this.undoRedo.redo()
            }
        },
        {
            key: "transaction",
            value: function(a, e) {
                this.undoRedo && this.undoRedo.transaction(a, e)
            }
        },
        {
            key: "openTransaction",
            value: function(a) {
                this.undoRedo && this.undoRedo.openTransaction(a)
            }
        },
        {
            key: "rollbackTransaction",
            value: function() {
                this.undoRedo && this.undoRedo.rollbackTransaction()
            }
        },
        {
            key: "commitTransaction",
            value: function() {
                this.undoRedo && this.undoRedo.commitTransaction()
            }
        },
        {
            key: "flushUndoRedo",
            value: function() {
                this.undoRedo && this.undoRedo.clear()
            }
        }]),
        d
    } ();
    var ef = function k(d) {
        Za(this, k);
        this.instance = d;
        T(this, "type", void 0);
        T(this, "tag", void 0);
        T(this, "remove", void 0);
        T(this, "uuid", void 0);
        T(this, "children", []);
        T(this, "elements", []);
        T(this, "bindings", void 0);
        T(this, "context", void 0);
        T(this, "functionBody", void 0);
        T(this, "precompile", void 0);
        T(this, "postcompile", void 0);
        this.uuid = fa();
        d.entries[this.uuid] = this
    },
    gl = function(d) {
        function k(e, c) {
            var h;
            return Za(this, k),
            T(Ca(h = a.call(this, c)), "type", "text"),
            T(Ca(h), "value", void 0),
            T(Ca(h), "bindings", void 0),
            h.value = e.value,
            h.bindings = {},
            h
        }
        yb(k, ef);
        var a = zb(k);
        return db(k, [{
            key: "_getBoundValue",
            value: function() {
                return "_rotors.bind(__knockleData[0], '" + this.bindings.__element.u + "', typeof $key !== 'undefined' ? $key : null, typeof $value !== 'undefined' ? $value : null)"
            }
        },
        {
            key: "compile",
            value: function() {
                return this.instance.getExecutionContent(this._getBoundValue(), this.uuid, !0) + ";_rotors.pet(_eid, '" + this.uuid + "');"
            }
        },
        {
            key: "updateFrom",
            value: function(e, c, h) {
                return e.el.nodeValue = c.el.nodeValue,
                {
                    added: [],
                    removed: [],
                    elements: []
                }
            }
        }]),
        k
    } (),
    hl = function(d) {
        function k(e, c) {
            var h;
            return Za(this, k),
            T(Ca(h = a.call(this, c)), "type", "comment"),
            T(Ca(h), "comment", void 0),
            h.comment = e,
            h
        }
        yb(k, ef);
        var a = zb(k);
        return db(k, [{
            key: "compile",
            value: function() {
                return ""
            }
        },
        {
            key: "updateFrom",
            value: function(e, c, h) {
                return Hd()
            }
        }]),
        k
    } (),
    Kc = function(d) {
        function k(e, c, h, b, g) {
            Za(this, k); (c = a.call(this, c)).templateResolver = h;
            c.stack = b;
            c.parseIdStack = g;
            T(Ca(c), "type", "element");
            T(Ca(c), "namespace", void 0);
            T(Ca(c), "atts", void 0);
            T(Ca(c), "custom", void 0);
            h = e.el.split(":");
            return c.tag = e.el,
            2 === h.length && (c.namespace = h[0]),
            c.atts = e.atts,
            c.bindings = e.bindings,
            c.remove = !1,
            c
        }
        yb(k, ef);
        var a = zb(k);
        return db(k, [{
            key: "compile",
            value: function(e) {
                var c = this.instance.getCustomTag(this.tag);
                if (c) {
                    e = c.getFunctionBody(this.instance, this);
                    c = "_rotors.customTagRendered('" + this.tag + "', _le, __knockleData[0]);";
                    for (var h = 0; h < this.children.length; h++) this.children[h].precompile && (e += this.children[h].precompile(this.instance)),
                    e += this.children[h].compile(),
                    this.children[h].postcompile && (e += this.children[h].postcompile(this.instance));
                    return e + ("_le=_els.pop();" + c + "_rotors.pet(_eid,'" + this.uuid + "');")
                }
                c = "/* element entry " + this.uuid + " */;";
                if (!0 !== this.remove) for (var b in c += this.instance.getExecutionContent(this.tag, this.uuid, !1, this.namespace), this.atts) if (this.atts.hasOwnProperty(b)) {
                    var g;
                    if (null != this.bindings[b]) {
                        if (g = "_rotors.bind(__knockleData[0], '" + this.bindings[b].u + "');", h = b.match(/\(([^)]+)\)/)) var m = ';if(__a!=null){_rotors.addCommand(_eid,e,"' + h[1] + '","' + this.atts[b] + '");}'
                    } else g = "'" + this.atts[b] + "'";
                    c += "__a=" + g + (h ? m: ";if(__a!=null) {_rotors.setAttribute(e,'" + b + "',__a || '');}")
                }
                for (h = 0; h < this.children.length; h++) this.children[h].precompile && (c += this.children[h].precompile()),
                m = this.children[h].compile(),
                c += m,
                this.children[h].functionBody = m,
                this.children[h].postcompile && (c += this.children[h].postcompile());
                return ! 0 === this.remove || e || (c += "_le=_els.pop();", c += "_rotors.pet(_eid, '" + this.uuid + "');"),
                c
            }
        },
        {
            key: "_applyStyles",
            value: function(e, c) {
                c.split(";").forEach(function(h) {
                    var b = h.indexOf(":"),
                    g = h.substring(0, b);
                    e.style[g] = h.substring(b + 1)
                })
            }
        },
        {
            key: "updateFrom",
            value: function(e, c, h) {
                var b, g;
                h = Hd();
                for (b in this.atts) this.atts.hasOwnProperty(b) && "class" !== b && ((g = c.el.getAttribute(b)) ? "style" === b && null != e.el.style ? this._applyStyles(e.el, g) : e.el.setAttribute(b, g) : e.el.removeAttribute(b));
                this.originalCustomTag && (b = this.instance.getCustomTag(this.originalCustomTag)) && h.elements.push([e.el, b]);
                for (g = 0; g < e.children.length; g++) b = this.instance.updateFrom(e.children[g], c.children[g], e),
                Array.prototype.push.apply(h.removed, b.removed),
                Array.prototype.push.apply(h.added, b.added),
                Array.prototype.push.apply(h.elements, b.elements);
                if (e.el._RotorsUpdate) for (c = this.instance.updaters[e.el._RotorsUpdate], b = 0; b < c.length; b++) c[b](e.el);
                return h
            }
        }]),
        k
    } (),
    ff = {},
    oc = {
        construct: function(d, k, a, e, c, h) {
            var b = ff[d];
            if (b) return new b(k, a, e, c, h);
            throw {
                message: "Knockle: unknown element '" + d + "'"
            };
        },
        register: function(d, k) {
            ff[d] = k
        },
        exists: function(d) {
            return null != ff[d]
        }
    },
    il = function c(k, a, e) {
        var h = this;
        Za(this, c);
        this.instance = k;
        this.tagName = a;
        this.options = e;
        T(this, "template", void 0);
        T(this, "getFunctionBody", void 0);
        T(this, "getFunctionEnd", void 0);
        T(this, "rendered", void 0);
        T(this, "updated", void 0);
        this.template = e.template;
        this.getFunctionBody = function(b, g) {
            g = function(m, r) {
                for (var t = [], u = function(w) {
                    var z = A({},
                    m[w]);
                    z.compile = m[w].compile;
                    t.push(z);
                    uj(z.atts, r.atts,
                    function(y, E) {
                        var F = h.instance;
                        z.atts[y] = E;
                        Gd(y, E, z, null, F)
                    })
                },
                v = 0; v < m.length; v++) u(v);
                return t
            } (b.parse(h.template, null, {
                originalCustomTag: g.tag,
                context: g.context,
                customParent: g
            }), g);
            return b.compile(g, !1, !0, !0)
        };
        this.getFunctionEnd = function() {
            return ";_els.pop();"
        };
        this.rendered = e.rendered ||
        function(b, g, m) {};
        this.updated = e.updated ||
        function(b, g, m) {}
    },
    ae = {},
    jl = function(k, a) {
        if (null != ae[k]) throw Error("Tag '" + k + "' already registered");
        ae[k] = a
    },
    kl = function(k) {
        return ae[k]
    },
    ji = function() {
        function k(a, e, c) {
            Za(this, k);
            this.registerGlobalTag = e;
            this.getGlobalTag = c;
            T(this, "templateResolver", void 0);
            T(this, "defaultTemplate", void 0);
            T(this, "entries", void 0);
            T(this, "bindings", void 0);
            T(this, "customTags", {});
            T(this, "cache", new Map);
            T(this, "templateCache", new Map);
            T(this, "openRe", /<([^/ > ] * ?) > $ | <([ ^ /].*[^/]) > $ / );
            T(this, "closeRe", /^<\/([^>]+)>/);
            T(this, "openCloseRe", /<(.*)(\/>$)/);
            T(this, "tokenizerRe", /(<[^\^>]+\/>)|(\x3c!--[\s\S]*?--\x3e)|(<[\/a-zA-Z0-9\-:]+(?:\s*[\(a-zA-Z\-\)]+="[^"]*"|\s*[a-zA-Z\-]+='[^']+'|\s*[\(a-zA-Z\-\)]|\s*\{\{.*\}\})*>)/);
            T(this, "commentRe", /\x3c!--[\s\S]*?--\x3e/);
            T(this, "attributesRe", /([\(a-zA-Z0-9\-_:\)]+="[^"]*")|\s+([\(a-zA-Z0-9\-_:\)]+(?=\s.|$))|(\{\{if [^(?:\}\})]+\}\}.*\{\{\/if\}\})/);
            T(this, "inlineIfRe", /\{\{if ([^\}]+)\}\}(.*)\{\{\/if\}\}/);
            T(this, "singleExpressionRe", /^[\s]*\$\{([^\}]*)\}[\s]*$/);
            T(this, "_fnPreamble", "__knockleData=[__knockleData||{}];var frag=_rotors.cf(),_els=[],e,_le,__a,$value,$key,_eid = _rotors.nec();_els.push(frag);");
            T(this, "_fnSuffix", ";_rotors.pushCommands(_eid,frag);return frag;");
            T(this, "isBrowser", !0);
            T(this, "executions", void 0);
            T(this, "updaters", {});
            T(this, "_templates", void 0);
            T(this, "namespaceHandlers", {});
            T(this, "namespaces", {});
            a = a || {};
            this.getGlobalTag = c ||
            function(h) {
                return ae[h]
            };
            this._templates = a.templates || {};
            this.entries = {};
            this.bindings = {};
            this.executions = {};
            this.defaultTemplate = a.defaultTemplate;
            this.templateResolver = a.templateResolver || this._getDefaultTemplateResolver()
        }
        return db(k, [{
            key: "resolveTemplate",
            value: function(a) {
                return null != this._templates[a] ? this._templates[a] : this.templateResolver(a)
            }
        },
        {
            key: "bind",
            value: function(a, e) {
                e = this.bindings[e];
                return null == e ? "": e.reapply(a)
            }
        },
        {
            key: "addCommand",
            value: function(a, e, c, h) {
                this.executions[a].commands = this.executions[a].commands || {};
                this.executions[a].commands[c] = this.executions[a].commands[c] || [];
                this.executions[a].commands[c].push({
                    element: e,
                    command: c,
                    action: h
                })
            }
        },
        {
            key: "pushCommands",
            value: function(a, e) {
                e.commands = this.executions[a].commands
            }
        },
        {
            key: "setAttribute",
            value: function(a, e, c) {
                e = e.split(":");
                1 === e.length || null == this.namespaces[e[0]] ? a.setAttribute(e[0], c) : a.setAttributeNS(this.namespaces[e[0]], e[1], c)
            }
        },
        {
            key: "clearCache",
            value: function() {
                this.cache.clear();
                this.templateCache.clear()
            }
        },
        {
            key: "nec",
            value: function() {
                var a = fa();
                return this.executions[a] = {
                    current: [{
                        children: []
                    }]
                },
                a
            }
        },
        {
            key: "te",
            value: function(a, e, c, h) {
                a = {
                    el: a,
                    children: [],
                    id: c,
                    index: h
                };
                this.executions[e].current[0].children.push(a);
                this.executions[e][c + (null != h ? "-" + h: "")] = a;
                this.executions[e].current.unshift(a)
            }
        },
        {
            key: "pet",
            value: function(a) {
                this.executions[a].current = this.executions[a].current.splice(1)
            }
        },
        {
            key: "parseAttributes",
            value: function(a) {
                return jg(a, this.attributesRe)
            }
        },
        {
            key: "getExecutionContent",
            value: function(a, e, c, h) {
                return (null != h ? this.namespaceHandlers[h](a) : c ? "e=_rotors.ctn(" + a + ");": "e=_rotors.ce('" + a + "');") + "_rotors.peek(_els).appendChild(e);" + (c ? "": "_els.push(e);") + "e._rotors=_rotors.entries['" + e + "'];e._rotorsEid=_eid;if(typeof _rotorsLoopId !== 'undefined') {e._rotorsLoopId=_rotorsLoopId;e._rotorsLoopContext=_rotorsLoopContext;e._rotorsKey=$key;}_rotors.te(e, _eid, '" + e + "', typeof $key != 'undefined' ? $key  : null);"
            }
        },
        {
            key: "_wrapCache",
            value: function(a, e) {
                var c = this;
                return function(h) {
                    var b = e ? null: c.cache.get(h);
                    return null == b && (b = a(h)),
                    null == b && (b = c.defaultTemplate),
                    null != b && c.cache.set(h, b),
                    b
                }
            }
        },
        {
            key: "constructElement",
            value: function(a, e, c, h, b) {
                return oc.construct(a, e, this, c, h, b)
            }
        },
        {
            key: "isCustomElement",
            value: function(a) {
                return oc.exists(a)
            }
        },
        {
            key: "parse",
            value: function(a, e, c, h) {
                var b = this;
                h = h || [];
                e = this._wrapCache(e ||
                function(y) {
                    return b.resolveTemplate(y)
                },
                null);
                var g = [],
                m = [],
                r = function() {
                    return 0 < g.length ? g[g.length - 1] : null
                },
                t = function(y, E) {
                    0 < g.length && r().children.push(y);
                    E ? 0 === g.length && m.push(y) : g.push(y)
                },
                u = function() {
                    var y = g.pop();
                    if (0 !== g.length || y.remove) {
                        if (y.remove) {
                            var E = r();
                            E && E.children.pop()
                        }
                    } else m.push(y);
                    return y
                },
                v = function(y, E, F, M) {
                    y = yj(y, b);
                    return b.isCustomElement(y.el) ? b.constructElement(y.el, y, F, g, h) : new Kc(y, b, F, g, h)
                },
                w = [{
                    re: this.commentRe,
                    handler: function(y, E, F, M, S) {
                        t(new hl(y, M), !0)
                    }
                },
                {
                    re: this.openRe,
                    handler: function(y, E, F, M, S) {
                        y = v(y, 0, F);
                        t(y, y.remove)
                    }
                },
                {
                    re: this.closeRe,
                    handler: function(y, E, F, M, S) {
                        if ("r-tmpl" !== E[1]) {
                            if (X = E[1], null == (da = r()) || da.tag !== X) throw new TypeError("Unbalanced closing tag '" + E[1] + "'; opening tag was '" + u().tag + "'");
                            var X, da;
                            u()
                        }
                    }
                },
                {
                    re: this.openCloseRe,
                    handler: function(y, E, F, M, S) {
                        y = v(y, 0, F);
                        t(y, !0)
                    }
                },
                {
                    re: /.*/,
                    handler: function(y, E, F, M, S) {
                        E = new gl({
                            value: y
                        },
                        b);
                        t(E, !0);
                        Gd("__element", y, E, null, b)
                    }
                }];
                if (wj(vb(a).split(this.tokenizerRe),
                function(y, E) {
                    y = vb(E);
                    for (var F = 0; F < w.length; F++) {
                        var M = y.match(w[F].re);
                        if (M = null == M ? null: M) {
                            w[F].handler(E, M, e, b, h);
                            break
                        }
                    }
                }), 0 < m.length && c) for (var z in c) m[0][z] = c[z];
                return m
            }
        },
        {
            key: "compile",
            value: function(a, e, c, h) {
                for (var b, g = [], m = 0; m < a.length; m++) {
                    var r = "";
                    a[m].precompile && (r += a[m].precompile(this));
                    r += b = a[m].compile(h);
                    a[m].functionBody = b;
                    a[m].postcompile && (r += a[m].postcompile(this));
                    g.push(r)
                }
                a = g.join("");
                if (c) return a;
                var t = this._compileSingle(a),
                u = this;
                if (e) return t;
                e = function(v) {
                    return t.apply(this, [v, u])
                };
                return e.functionBody = a,
                e
            }
        },
        {
            key: "_compileSingle",
            value: function(a) {
                return new Function("__knockleData,_rotors", this._fnPreamble + a + this._fnSuffix)
            }
        },
        {
            key: "_executeSingle",
            value: function(a, e) {
                return this._compileSingle(a)(e, this)
            }
        },
        {
            key: "updateFrom",
            value: function(a, e, c) {
                return this.entries[a.id].updateFrom(a, e, c)
            }
        },
        {
            key: "getTemplate",
            value: function(a) {
                return this.templateCache.get(a)
            }
        },
        {
            key: "addTemplate",
            value: function(a, e) {
                this._templates[a] = e
            }
        },
        {
            key: "template",
            value: function(a, e, c, h) {
                var b = this,
                g = h ? null: this.templateCache.get(a);
                if (null != g) return g(e);
                h = (c = this._wrapCache(c ||
                function(m) {
                    return b.resolveTemplate(m)
                },
                h))(a);
                return null != h ? (c = this.parse(h, c, null, [a]), c = this.compile(c), this.templateCache.set(a, c), c(e)) : this.cf()
            }
        },
        {
            key: "peek",
            value: function(a) {
                return 0 < a.length ? a[a.length - 1] : null
            }
        },
        {
            key: "data",
            value: function(a, e, c) {
                return nb(a, e, c)
            }
        },
        {
            key: "each",
            value: function(a, e, c, h, b) {
                var g;
                if (Array.isArray(a)) for (g = 0; g < a.length; g++) e(a[g], c, g, h, b);
                else for (g in a) a.hasOwnProperty(g) && e({
                    $key: g,
                    $value: a[g]
                },
                c, g, h, b)
            }
        },
        {
            key: "update",
            value: function(a, e) {
                var c, h = this;
                var b = a._rotorsEid;
                if (null != b && null != a._rotors) {
                    b = (c = a._rotors.instance).executions[b];
                    var g = a._rotorsKey;
                    a = b[a._rotors.uuid + (null != g ? "-" + g: "")];
                    b = c.entries[a.id];
                    b = c._executeSingle(b.customParent ? b.customParent.functionBody: b.functionBody, e).childNodes[0];
                    c = this.updateFrom(a, c.executions[b._rotorsEid][b._rotors.uuid], null);
                    return c.elements.forEach(function(m) {
                        var r = Array.isArray(m) ? m: void 0;
                        if (!r) if (r = null == m ? null: "undefined" != typeof Symbol && m[Symbol.iterator] || m["@@iterator"], null != r) {
                            var t, u = [],
                            v = !0,
                            w = !1;
                            try {
                                for (r = r.call(m); ! (v = (t = r.next()).done) && (u.push(t.value), 2 !== u.length); v = !0);
                            } catch(y) {
                                w = !0;
                                var z = y
                            } finally {
                                try {
                                    v || null == r.
                                    return || r.
                                    return ()
                                } finally {
                                    if (w) throw z;
                                }
                            }
                            r = u
                        } else r = void 0;
                        if (! (m = r || ig(m, 2))) throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                        m[1].updated(m[0], e, h)
                    }),
                    c
                }
            }
        },
        {
            key: "onUpdate",
            value: function(a, e) {
                if (null != a._rotors) {
                    var c = a._rotors.instance;
                    a._RotorsUpdate = a._RotorsUpdate || fa();
                    c.updaters[a._RotorsUpdate] = c.updaters[a._RotorsUpdate] || [];
                    c.updaters[a._RotorsUpdate].push(e)
                }
            }
        },
        {
            key: "copyChildNodes",
            value: function(a, e) {
                for (var c = a.childNodes.length,
                h = 0; h < c; h++) e.appendChild(a.childNodes[0])
            }
        },
        {
            key: "remove",
            value: function(a, e) {
                a._RotorsUpdate && this.updaters[a._RotorsUpdate] && delete this.updaters[a._RotorsUpdate];
                a._rotorsEid && this.executions[a._rotorsEid] && delete this.executions[a._rotorsEid];
                e && a.parentNode && a.parentNode.removeChild(a)
            }
        },
        {
            key: "registerTag",
            value: function(a, e, c) {
                e = new il(this, a, e);
                c ? this.registerGlobalTag(a, e) : this.customTags[a] = e
            }
        },
        {
            key: "getCustomTag",
            value: function(a) {
                return this.customTags[a] || this.getGlobalTag(a)
            }
        },
        {
            key: "customTagRendered",
            value: function(a, e, c) { (a = this.getCustomTag(a)) && a.rendered(e, c, this)
            }
        }]), k
    } (),
    ll = function(k) {
        function a(c, h, b, g, m) {
            var r;
            return Za(this, a),
            T(Ca(r = e.call(this, c, h, b, g, m)), "context", void 0),
            T(Ca(r), "key", void 0),
            T(Ca(r), "type", "each"),
            r.context = c.atts. in ,
            r.key = c.atts.key,
            r.tag = "r-each",
            r
        }
        yb(a, Kc);
        var e = zb(a);
        return db(a, [{
            key: "compile",
            value: function() {
                var c = ";_rotors.te(null, _eid, '" + this.uuid + "');" + (this.context ? ';__knockleData.unshift(_rotors.data(__knockleData[0], "' + this.context + '"));': ""),
                h;
                var b = "function(item, _rotorsLoopId, _rotorsLoopIndex, _rotorsLoopContext, _key) { __knockleData.unshift(item);$value=item;$key=_key ? _rotors.data($value, _key) : _rotorsLoopIndex;";
                for (h = 0; h < this.children.length; h++) {
                    var g = this.children[h].compile();
                    this.children[h].functionBody = g;
                    b += g
                }
                h = (b += "__knockleData.splice(0,1);", b + "}");
                return c + ("_rotors.each(__knockleData[0], " + h + ",'" + this.uuid + "', '" + this.context.replace(/'/g, "\\'") + "'," + (void 0 === this.key ? "null);": "'" + this.key + "');")) + (this.context ? ";__knockleData.splice(0, 1);": "") + (";_rotors.pet(_eid, '" + this.uuid + "');")
            }
        },
        {
            key: "updateFrom",
            value: function(c, h, b) {
                var g;
                b = lg(this.instance, c, h, ["id", "index"], b);
                for (var m = null,
                r = 0; r < h.children.length; r++)(g = kg({
                    index: h.children[r].index,
                    id: h.children[r].id
                },
                c)) && g.el && (null != m && m.parentNode.insertBefore(g.el, m.nextSibling), m = g.el);
                return b
            }
        }]),
        a
    } ();
    oc.register("r-each", ll);
    var ki = function(k) {
        function a(c, h, b, g, m) {
            var r;
            return Za(this, a),
            T(Ca(r = e.call(this, c, h, b, g, m)), "type", "if"),
            T(Ca(r), "test", void 0),
            T(Ca(r), "happyFlowChildren", void 0),
            r.test = c.atts.test,
            r.tag = "r-if",
            r
        }
        yb(a, Kc);
        var e = zb(a);
        return db(a, [{
            key: "compile",
            value: function() {
                var c, h = "",
                b = "",
                g = this.happyFlowChildren || this.children;
                for (c = 0; c < g.length; c++) h += g[c].compile() + ";";
                if (null != this.happyFlowChildren) {
                    b = "else {";
                    for (c = 0; c < this.children.length; c++) b += this.children[c].compile() + ";";
                    b += "}"
                }
                return ";_rotors.te(null, _eid, '" + this.uuid + "');with (__knockleData[0]) { if(" + this.test + ") { " + h + " }" + b + "}_rotors.pet(_eid);"
            }
        },
        {
            key: "updateFrom",
            value: function(c, h, b) {
                return lg(this.instance, c, this.flatMap(h), ["id"], b)
            }
        },
        {
            key: "flatMap",
            value: function(c) {
                var h = [];
                return c.children.forEach(function(b) {
                    if (null == b.el) {
                        var g = h.push,
                        m = g.apply;
                        b = b.children;
                        var r = Array.isArray(b) ? Ge(b) : void 0;
                        r || (r = "undefined" != typeof Symbol && null != b[Symbol.iterator] || null != b["@@iterator"] ? Array.from(b) : void 0);
                        if (! (b = r || ig(b))) throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                        m.call(g, h, b)
                    } else h.push(b)
                }),
                {
                    el: c.el,
                    index: c.index,
                    id: c.id,
                    children: h
                }
            }
        }]),
        a
    } ();
    oc.register("r-if", ki);
    var ml = function(k) {
        function a(c, h, b, g, m) {
            Za(this, a);
            c = e.call(this, c, h, b, g, m);
            g = 0 < g.length ? g[g.length - 1] : null;
            return null != g && g instanceof ki && (g.happyFlowChildren = g.children, g.children = []),
            c.remove = !0,
            c.tag = "r-else",
            c
        }
        yb(a, Kc);
        var e = zb(a);
        return db(a, [{
            key: "compile",
            value: function() {
                return ""
            }
        },
        {
            key: "updateFrom",
            value: function(c, h, b) {
                return Hd()
            }
        }]),
        a
    } ();
    oc.register("r-else", ml);
    var nl = function(k) {
        function a(c, h, b, g, m) {
            var r;
            if (Za(this, a), T(Ca(r = e.call(this, c, h, b, g, m)), "templateId", void 0), T(Ca(r), "lookup", void 0), T(Ca(r), "default", void 0), r.context = c.atts.context, r.type = "template", r.remove = !0, c.atts.lookup) r.lookup = c.atts.lookup,
            r.
        default = c.atts.
        default || "",
            r.compile = function() {
                return ';with(__knockleData[0]){var tlid=eval("' + r.lookup.replace(/[\$\{\}]/g, "") + '");}if (_rotors.templateCache[tlid] == null){var ___t = _rotors.resolveTemplate(tlid) || _rotors.resolveTemplate("' + r.
            default + '");_rotors.templateCache[tlid]=_rotors.compile(_rotors.parse(___t));} eval(_rotors.templateCache[tlid].functionBody);'
            };
            else if (r.templateId = c.atts.id, c = xj(g), -1 !== m.indexOf(r.templateId)) {
                if (!c) throw new TypeError("recursive template call [" + r.templateId + "]");
                r.compile = function() {
                    return ";eval(_rotors.getTemplate('" + r.templateId + "').functionBody);"
                }
            } else {
                c = b(r.templateId);
                m.push(r.templateId);
                b = r.instance.parse(c, b, null, m);
                null == r.instance.templateCache.get(r.templateId) && r.instance.templateCache.set(r.templateId, r.instance.compile(b));
                for (c = 0; c < b.length; c++) b[c].context = r.context;
                r.children = b;
                m.pop()
            }
            return r.precompile = function() {
                return r.context ? ';__knockleData.unshift(_rotors.data(__knockleData[0], "' + r.context + '"));': ""
            },
            r.postcompile = function() {
                return r.context ? ";__knockleData.splice(0, 1);": ""
            },
            r
        }
        yb(a, Kc);
        var e = zb(a);
        return db(a, [{
            key: "updateFrom",
            value: function(c, h, b) {
                return {
                    added: [],
                    removed: [],
                    elements: []
                }
            }
        }]),
        a
    } ();
    oc.register("r-tmpl", nl);
    var ol = function(k) {
        function a(c, h, b, g, m) {
            return Za(this, a),
            e.call(this, c, h, b, g, m)
        }
        yb(a, Kc);
        var e = zb(a);
        return db(a, [{
            key: "compile",
            value: function() {
                try {
                    return ";var __hp=_rotors.parse(__knockleData[0]." + this.children[0].bindings.__element.e[0][1] + "),__hc=_rotors.compile(__hp,true);var __f=__hc(__knockleData[0], _rotors);_rotors.copyChildNodes(__f, _rotors.peek(_els));"
                } catch(c) {
                    return ""
                }
            }
        },
        {
            key: "updateFrom",
            value: function(c, h, b) {
                return Hd()
            }
        }]),
        a
    } ();
    oc.register("r-html", ol);
    var li = function() {
        function k() {
            Za(this, k);
            T(this, "childNodes", void 0);
            this.childNodes = []
        }
        return db(k, [{
            key: "appendChild",
            value: function(a) {
                this.childNodes.push(a)
            }
        },
        {
            key: "toString",
            value: function() {
                for (var a = "",
                e = 0; e < this.childNodes.length; e++) a += this.childNodes[e].toString();
                return a
            }
        }]),
        k
    } (),
    pl = function(k) {
        function a(c) {
            var h;
            return Za(this, a),
            T(Ca(h = e.call(this)), "tag", void 0),
            T(Ca(h), "atts", void 0),
            h.tag = c,
            h.atts = {},
            h
        }
        yb(a, li);
        var e = zb(a);
        return db(a, [{
            key: "getAttribute",
            value: function(c) {
                return this.atts[c]
            }
        },
        {
            key: "setAttributeNS",
            value: function(c, h, b) {
                this.atts[c + ":" + h] = b
            }
        },
        {
            key: "setAttribute",
            value: function(c, h) {
                this.atts[c] = h
            }
        },
        {
            key: "toString",
            value: function() {
                var c = "<" + this.tag,
                h = "",
                b;
                for (b in this.atts) h += " " + b + '="' + this.atts[b] + '"';
                c = c + h + ">";
                for (h = 0; h < this.childNodes.length; h++) c += this.childNodes[h].toString();
                return c + "</" + this.tag + ">"
            }
        },
        {
            key: "insertAdjacentElement",
            value: function(c, h) {
                throw "FakeElement insertAdjacentElement - not implemented. Update failed.";
            }
        }]),
        a
    } (),
    ql = function() {
        function k(a) {
            Za(this, k);
            T(this, "nodeValue", void 0);
            this.nodeValue = a
        }
        return db(k, [{
            key: "toString",
            value: function() {
                return this.nodeValue
            }
        }]),
        k
    } (); (function(k) {
        function a() {
            return Za(this, a),
            e.apply(this, arguments)
        }
        yb(a, ji);
        var e = zb(a);
        return db(a, [{
            key: "_getDefaultTemplateResolver",
            value: function() {
                return null
            }
        },
        {
            key: "ce",
            value: function(c) {
                return new pl(c)
            }
        },
        {
            key: "cf",
            value: function() {
                return new li
            }
        },
        {
            key: "ctn",
            value: function(c) {
                return new ql(c)
            }
        }]),
        a
    })();
    var mi = function(k) {
        function a(c, h, b) {
            var g;
            if (! (this instanceof a)) throw new TypeError("Cannot call a class as a function");
            return (g = e.call(this, c, h, b)).namespaceHandlers.svg = function(m) {
                return "e = document.createElementNS('http://www.w3.org/2000/svg', '" + m.split(":")[1] + "');e.setAttribute('version', '1.1');e.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');"
            },
            g.namespaces.xlink = "http://www.w3.org/1999/xlink",
            g
        }
        Aj(a, ji);
        var e = Cj(a);
        return zj(a, [{
            key: "ce",
            value: function(c) {
                return document.createElement(c)
            }
        },
        {
            key: "cf",
            value: function() {
                return document.createDocumentFragment()
            }
        },
        {
            key: "ctn",
            value: function(c) {
                return document.createTextNode(c)
            }
        },
        {
            key: "_getDefaultTemplateResolver",
            value: function() {
                return Dj
            }
        }]),
        a
    } ();
    var tg = {
        "stroke-linejoin": "stroke-linejoin",
        "stroke-dashoffset": "stroke-dashoffset",
        "stroke-linecap": "stroke-linecap"
    },
    sg = {
        svg: "http://www.w3.org/2000/svg"
    },
    gf = la("element", "click"),
    ni = la("element", "dblclick"),
    hf = la("element", "dbltap"),
    oi = la("element", "mouseout"),
    pi = la("element", "mouseover"),
    qi = la("element", "mousemove"),
    ri = la("element", "mouseup"),
    si = la("element", "mousedown"),
    ti = la("element", "contextmenu"),
    jf = la("element", "tap"),
    ui = la("endpoint", "click"),
    vi = la("endpoint", "dblclick");
    la("endpoint", "dbltap");
    var rl = la("endpoint", "mouseout"),
    sl = la("endpoint", "mouseover"),
    tl = la("endpoint", "mouseup"),
    ul = la("endpoint", "mousedown");
    la("endpoint", "tap");
    var wi = la("connection", "click"),
    xi = la("connection", "dblclick"),
    yi = la("connection", "dbltap"),
    zi = la("connection", "mouseout"),
    Ai = la("connection", "mouseover"),
    Bi = la("connection", "mouseup"),
    Ci = la("connection", "mousedown"),
    Di = la("connection", "contextmenu"),
    Ei = la("connection", "tap"),
    tb = Eb("jtk-connector"),
    pc = Eb("jtk-endpoint"),
    vl = wb("data-jtk-group"),
    wl = wb("data-jtk-group-content"),
    Lb = Eb("jtk-overlay"),
    Jj = 1,
    bd = "ontouchstart" in document.documentElement || null != navigator.maxTouchPoints && 0 < navigator.maxTouchPoints,
    be = "onmousedown" in document.documentElement,
    Jb = {
        mousedown: "touchstart",
        mouseup: "touchend",
        mousemove: "touchmove"
    },
    ce = function(k, a, e, c, h) {
        if (bd && Jb[a]) {
            var b = Nd(c, k, e, Jb[a]);
            Md(k, Jb[a], b, e, h)
        }
        "focus" === a && null == k.getAttribute("tabindex") && k.setAttribute("tabindex", "1");
        Md(k, a, Nd(c, k, e, a), e, h)
    },
    kf = {
        tap: {
            touches: 1,
            taps: 1
        },
        dbltap: {
            touches: 1,
            taps: 2
        },
        contextmenu: {
            touches: 2,
            taps: 1
        }
    },
    xl = function() {
        function k() {
            Sa(this, k)
        }
        Ta(k, null, [{
            key: "generate",
            value: function(a, e) {
                return function(c, h, b, g) {
                    if ("contextmenu" == h && be) ce(c, h, b, g);
                    else {
                        if (null == c.__taTapHandler) {
                            var m = c.__taTapHandler = {
                                tap: [],
                                dbltap: [],
                                down: !1,
                                taps: 0,
                                downSelectors: []
                            },
                            r = function(w) {
                                var z = w.srcElement || w.target;
                                w = Me(w, z, c, null != g);
                                for (var y = !1,
                                E = 0; E < w.end && !y; E++) {
                                    z = w.path[E];
                                    for (var F = 0; F < m.downSelectors.length; F++) if (null == m.downSelectors[F] || $c(z, m.downSelectors[F], c)) {
                                        m.down = !0;
                                        setTimeout(u, a);
                                        setTimeout(v, e);
                                        y = !0;
                                        break
                                    }
                                }
                            },
                            t = function(w) {
                                if (m.down) {
                                    var z = w.srcElement || w.target;
                                    m.taps++;
                                    var y = Ld(w).length,
                                    E;
                                    for (E in kf) if (kf.hasOwnProperty(E)) {
                                        var F = kf[E];
                                        if (F.touches === y && (1 === F.taps || F.taps === m.taps)) for (var M = 0; M < m[E].length; M++) {
                                            var S = Me(w, z, c, null != m[E][M][1]);
                                            for (var X = 0; X < S.end; X++) if (F = S.path[X], null == m[E][M][1] || $c(F, m[E][M][1], c)) {
                                                m[E][M][0].apply(F, [w, F]);
                                                break
                                            }
                                        }
                                    }
                                }
                            },
                            u = function() {
                                m.down = !1
                            },
                            v = function() {
                                m.taps = 0
                            };
                            c.__taTapHandler.downHandler = r;
                            c.__taTapHandler.upHandler = t;
                            ce(c, "mousedown", r);
                            ce(c, "mouseup", t)
                        }
                        c.__taTapHandler.downSelectors.push(g);
                        c.__taTapHandler[h].push([b, g]);
                        b.__taUnstore = function() {
                            null != c.__taTapHandler && (ma(c.__taTapHandler.downSelectors,
                            function(w) {
                                return w === g
                            }), Ij(c.__taTapHandler[h], b), 0 === c.__taTapHandler.downSelectors.length && (ad(c, "mousedown", c.__taTapHandler.downHandler), ad(c, "mouseup", c.__taTapHandler.upHandler), delete c.__taTapHandler))
                        }
                    }
                }
            }
        }]);
        return k
    } (),
    yl = function() {
        function k() {
            Sa(this, k)
        }
        Ta(k, null, [{
            key: "generate",
            value: function() {
                var a = [];
                return function(e, c, h, b) {
                    if (!e.__tamee) {
                        e.__tamee = {
                            over: !1,
                            mouseenter: [],
                            mouseexit: []
                        };
                        var g = function(r) {
                            var t = r.srcElement || r.target;
                            if (null == b && t == e && !e.__tamee.over || $c(t, b, e) && (null == t.__tamee || !t.__tamee.over)) xg("mouseenter", r, e, t),
                            t.__tamee = t.__tamee || {},
                            t.__tamee.over = !0,
                            a.push(t)
                        },
                        m = function(r) {
                            for (var t = r.srcElement || r.target,
                            u = 0; u < a.length; u++) t != a[u] || $c(r.relatedTarget || r.toElement, "*", t) || (t.__tamee.over = !1, a.splice(u, 1), xg("mouseexit", r, e, t))
                        };
                        Md(e, "mouseover", Nd(b, e, g, "mouseover"), g);
                        Md(e, "mouseout", Nd(b, e, m, "mouseout"), m)
                    }
                    h.__taUnstore = function() {
                        delete e.__tamee[c][h.__tauid]
                    };
                    vg(e, c, h);
                    e.__tamee[c][h.__tauid] = h
                }
            }
        }]);
        return k
    } (),
    $b = function() {
        function k(a) {
            Sa(this, k);
            G(this, "clickThreshold", void 0);
            G(this, "dblClickThreshold", void 0);
            G(this, "tapHandler", void 0);
            G(this, "mouseEnterExitHandler", void 0);
            a = a || {};
            this.clickThreshold = a.clickThreshold || 250;
            this.dblClickThreshold = a.dblClickThreshold || 450;
            this.mouseEnterExitHandler = yl.generate();
            this.tapHandler = xl.generate(this.clickThreshold, this.dblClickThreshold)
        }
        Ta(k, [{
            key: "_doBind",
            value: function(a, e, c, h, b) {
                null != c && ("tap" === e || "dbltap" === e || "contextmenu" === e ? this.tapHandler(a, e, c, h, b) : "mouseenter" === e || "mouseexit" == e ? this.mouseEnterExitHandler(a, e, c, h, b) : ce(a, e, c, h, b))
            }
        },
        {
            key: "on",
            value: function(a, e, c, h, b) {
                this._doBind(a, e, null == h ? c: h, null == h ? null: c, b);
                return this
            }
        },
        {
            key: "off",
            value: function(a, e, c) {
                ad(a, e, c);
                return this
            }
        },
        {
            key: "trigger",
            value: function(a, e, c, h, b) {
                var g = be && ("undefined" === typeof MouseEvent || null == c || c.constructor === MouseEvent),
                m = bd && !be && Jb[e] ? Jb[e] : e,
                r = !(bd && !be && Jb[e]),
                t = bb(c),
                u = Ne(c, "screen"),
                v = Ne(c, "client");
                wg(a,
                function(w) {
                    c = c || {
                        screenX: u.x,
                        screenY: u.y,
                        clientX: v.x,
                        clientY: v.y
                    };
                    var z = !r && !g && bd && Jb[e] ? "TouchEvent": "MouseEvents";
                    var y = document.createEvent(z); ({
                        TouchEvent: function(E) {
                            var F = t.x;
                            var M = t.y,
                            S = u.x,
                            X = u.y,
                            da = v.x,
                            W = v.y;
                            F = new Touch({
                                target: w,
                                identifier: fa(),
                                pageX: F,
                                pageY: M,
                                screenX: S,
                                screenY: X,
                                clientX: da || S,
                                clientY: W || X
                            });
                            F = Hj(F); (E.initTouchEvent || E.initEvent)(m, !0, !0, window, null, u.x, u.y, v.x, v.y, !1, !1, !1, !1, F, F, F, 1, 0)
                        },
                        MouseEvents: function(E) {
                            E.initMouseEvent(m, !0, !0, window, null == b ? 1 : b, u.x, u.y, v.x, v.y, !1, !1, !1, !1, 1, w)
                        }
                    })[z](y);
                    h && (y.payload = h);
                    w.dispatchEvent(y)
                });
                return this
            }
        }]);
        return k
    } (),
    lf = function() {
        return ! 0
    },
    zl = function() {
        return ! 1
    },
    mf = "stop start drag drop over out beforeStart".split(" "),
    Al = function() {},
    Lc = function(k, a) {
        if (null != k) {
            k = J(k) || null != k.tagName || null == k.length ? [k] : k;
            for (var e = 0; e < k.length; e++) a.apply(k[e], [k[e]])
        }
    },
    Bl = function() {
        function k(a, e) {
            Sa(this, k);
            this.el = a;
            this.k = e;
            G(this, "_class", void 0);
            G(this, "uuid", fa());
            G(this, "enabled", !0);
            G(this, "scopes", [])
        }
        Ta(k, [{
            key: "setEnabled",
            value: function(a) {
                this.enabled = a
            }
        },
        {
            key: "isEnabled",
            value: function() {
                return this.enabled
            }
        },
        {
            key: "toggleEnabled",
            value: function() {
                this.enabled = !this.enabled
            }
        },
        {
            key: "addScope",
            value: function(a) {
                var e = {};
                Lc(this.scopes,
                function(h) {
                    e[h] = !0
                });
                Lc(a ? a.split(/\s+/) : [],
                function(h) {
                    e[h] = !0
                });
                this.scopes.length = 0;
                for (var c in e) this.scopes.push(c)
            }
        },
        {
            key: "removeScope",
            value: function(a) {
                var e = {};
                Lc(this.scopes,
                function(h) {
                    e[h] = !0
                });
                Lc(a ? a.split(/\s+/) : [],
                function(h) {
                    delete e[h]
                });
                this.scopes.length = 0;
                for (var c in e) this.scopes.push(c)
            }
        },
        {
            key: "toggleScope",
            value: function(a) {
                var e = {};
                Lc(this.scopes,
                function(h) {
                    e[h] = !0
                });
                Lc(a ? a.split(/\s+/) : [],
                function(h) {
                    e[h] ? delete e[h] : e[h] = !0
                });
                this.scopes.length = 0;
                for (var c in e) this.scopes.push(c)
            }
        }]);
        return k
    } (),
    rd; (function(k) {
        k.notNegative = "notNegative";
        k.parent = "parent";
        k.parentEnclosed = "parentEnclosed"
    })(rd || (rd = {}));
    var Cl = function(k) {
        function a(c, h, b) {
            Sa(this, a);
            var g = e.call(this, c, b);
            G(I(g), "_class", void 0);
            G(I(g), "rightButtonCanDrag", void 0);
            G(I(g), "consumeStartEvent", void 0);
            G(I(g), "clone", void 0);
            G(I(g), "scroll", void 0);
            G(I(g), "trackScroll", void 0);
            G(I(g), "_downAt", void 0);
            G(I(g), "_posAtDown", void 0);
            G(I(g), "_pagePosAtDown", void 0);
            G(I(g), "_pageDelta", {
                x: 0,
                y: 0
            });
            G(I(g), "_moving", void 0);
            G(I(g), "_lastPosition", void 0);
            G(I(g), "_lastScrollValues", {
                x: 0,
                y: 0
            });
            G(I(g), "_initialScroll", {
                x: 0,
                y: 0
            });
            G(I(g), "_size", void 0);
            G(I(g), "_currentParentPosition", void 0);
            G(I(g), "_ghostParentPosition", void 0);
            G(I(g), "_dragEl", void 0);
            G(I(g), "_multipleDrop", void 0);
            G(I(g), "_ghostProxyOffsets", void 0);
            G(I(g), "_ghostDx", void 0);
            G(I(g), "_ghostDy", void 0);
            G(I(g), "_isConstrained", !1);
            G(I(g), "_ghostProxyParent", void 0);
            G(I(g), "_useGhostProxy", void 0);
            G(I(g), "_ghostProxyFunction", void 0);
            G(I(g), "_activeSelectorParams", void 0);
            G(I(g), "_availableSelectors", []);
            G(I(g), "_canDrag", void 0);
            G(I(g), "_consumeFilteredEvents", void 0);
            G(I(g), "_parent", void 0);
            G(I(g), "_ignoreZoom", void 0);
            G(I(g), "_filters", {});
            G(I(g), "_constrainRect", void 0);
            G(I(g), "_elementToDrag", void 0);
            G(I(g), "downListener", void 0);
            G(I(g), "moveListener", void 0);
            G(I(g), "upListener", void 0);
            G(I(g), "listeners", {
                start: [],
                drag: [],
                stop: [],
                over: [],
                out: [],
                beforeStart: [],
                revert: []
            });
            g._class = g.k.css.draggable;
            sa(g.el, g._class);
            g.downListener = g._downListener.bind(I(g));
            g.upListener = g._upListener.bind(I(g));
            g.moveListener = g._moveListener.bind(I(g));
            g.rightButtonCanDrag = !0 === h.rightButtonCanDrag;
            g.consumeStartEvent = !1 !== h.consumeStartEvent;
            g._dragEl = g.el;
            g.clone = !0 === h.clone;
            g.scroll = !0 === h.scroll;
            g.trackScroll = !1 !== h.trackScroll;
            g._multipleDrop = !1 !== h.multipleDrop;
            g._canDrag = h.canDrag || lf;
            g._consumeFilteredEvents = h.consumeFilteredEvents;
            g._parent = h.parent;
            g._ignoreZoom = !0 === h.ignoreZoom;
            g._ghostProxyParent = h.ghostProxyParent;
            g.trackScroll && document.addEventListener("scroll",
            function(m) {
                if (g._moving) {
                    var r = {
                        x: document.documentElement.scrollLeft,
                        y: document.documentElement.scrollTop
                    },
                    t = {
                        x: r.x - g._lastScrollValues.x + g._lastPosition.x,
                        y: r.y - g._lastScrollValues.y + g._lastPosition.y
                    },
                    u = t.x - g._downAt.x,
                    v = t.y - g._downAt.y,
                    w = g._ignoreZoom ? 1 : g.k.getZoom();
                    g._dragEl && g._dragEl.parentNode && (u += g._dragEl.parentNode.scrollLeft - g._initialScroll.x, v += g._dragEl.parentNode.scrollTop - g._initialScroll.y);
                    g.moveBy(u / w, v / w, m);
                    g._lastPosition = t;
                    g._lastScrollValues = r
                }
            });
            g._useGhostProxy = !0 === h.ghostProxy ? lf: h.ghostProxy && "function" === typeof h.ghostProxy ? h.ghostProxy: function(m, r) {
                return g._activeSelectorParams && g._activeSelectorParams.useGhostProxy ? g._activeSelectorParams.useGhostProxy(m, r) : !1
            };
            g._ghostProxyFunction = h.makeGhostProxy ? h.makeGhostProxy: function(m) {
                return g._activeSelectorParams && g._activeSelectorParams.makeGhostProxy ? g._activeSelectorParams.makeGhostProxy(m) : m.cloneNode(!0)
            };
            h.selector && (c = g.el.getAttribute("katavorio-draggable"), null == c && (c = "" + (new Date).getTime(), g.el.setAttribute("katavorio-draggable", c)), g._availableSelectors.push(h));
            g.k.eventManager.on(g.el, "mousedown", g.downListener);
            g.k.eventManager.on(document, "mousemove", g.moveListener);
            g.k.eventManager.on(document, "mouseup", g.upListener);
            return g
        }
        Id(a, k);
        var e = Jd(a);
        Ta(a, [{
            key: "on",
            value: function(c, h) {
                this.listeners[c] && this.listeners[c].push(h)
            }
        },
        {
            key: "off",
            value: function(c, h) {
                if (this.listeners[c]) {
                    for (var b = [], g = 0; g < this.listeners[c].length; g++) this.listeners[c][g] !== h && b.push(this.listeners[c][g]);
                    this.listeners[c] = b
                }
            }
        },
        {
            key: "_upListener",
            value: function(c) {
                this._downAt && (this._downAt = null, ta(document.body, "katavorio-drag-no-select"), this.unmark(c), this.stop(c), this._moving = !1, this.clone ? (this._dragEl && this._dragEl.parentNode && this._dragEl.parentNode.removeChild(this._dragEl), this._dragEl = null) : this._activeSelectorParams && this._activeSelectorParams.revertFunction && !0 === this._activeSelectorParams.revertFunction(this._dragEl, cd(this._dragEl)) && (zg(this._dragEl, this._posAtDown), this._dispatch("revert", this._dragEl)))
            }
        },
        {
            key: "_downListener",
            value: function(c) {
                if (!c.defaultPrevented && (this.rightButtonCanDrag || 3 !== c.which && 2 !== c.button) && this.isEnabled() && this._canDrag()) {
                    var h;
                    if (h = this._testFilter(c)) h = this.el,
                    h = !Bb(c.srcElement || c.target, this.k.getInputFilterSelector(), h);
                    if (h) {
                        this._elementToDrag = this._activeSelectorParams = null;
                        0 === this._availableSelectors.length && console.log("JSPLUMB: no available drag selectors");
                        a: {
                            h = this._availableSelectors;
                            var b = this.el,
                            g = c.target || c.srcElement,
                            m = b.getAttribute("katavorio-draggable"),
                            r = null != m ? "[katavorio-draggable='" + m + "'] ": "";
                            for (m = 0; m < h.length; m++) {
                                b: {
                                    var t = b;
                                    var u = g,
                                    v = r + h[m].selector;
                                    if (Bb(u, v, t)) t = u;
                                    else {
                                        for (u = u.parentNode; null != u && u !== t;) {
                                            if (Bb(u, v, t)) {
                                                t = u;
                                                break b
                                            }
                                            u = u.parentNode
                                        }
                                        t = void 0
                                    }
                                }
                                if (null != t) {
                                    if (h[m].filter && (b = Bb(g, h[m].filter, t), !0 === h[m].filterExclude && !b || b)) {
                                        h = null;
                                        break a
                                    }
                                    h = [h[m], t];
                                    break a
                                }
                            }
                            h = null
                        }
                        null != h && (this._activeSelectorParams = h[0], this._elementToDrag = h[1]);
                        null != this._activeSelectorParams && null != this._elementToDrag && (h = this._activeSelectorParams.dragInit ? this._activeSelectorParams.dragInit(this._elementToDrag) : null, null != h && (this._elementToDrag = h), this.clone ? (this._dragEl = this._elementToDrag.cloneNode(!0), sa(this._dragEl, "katavorio-clone-drag"), this._dragEl.setAttribute("id", null), this._dragEl.style.position = "absolute", null != this._parent ? (h = cd(this.el), this._dragEl.style.left = h.x + "px", this._dragEl.style.top = h.y + "px", this._parent.appendChild(this._dragEl)) : (h = sc(this._elementToDrag), this._dragEl.style.left = h.x + "px", this._dragEl.style.top = h.y + "px", document.body.appendChild(this._dragEl))) : this._dragEl = this._elementToDrag, this.consumeStartEvent && Ha(c), this._downAt = bb(c), this._dragEl && this._dragEl.parentNode && (this._initialScroll = {
                            x: this._dragEl.parentNode.scrollLeft,
                            y: this._dragEl.parentNode.scrollTop
                        }), this._posAtDown = cd(this._dragEl), this._pagePosAtDown = sc(this._dragEl), this._pageDelta = {
                            x: this._pagePosAtDown.x - this._posAtDown.x,
                            y: this._pagePosAtDown.y - this._posAtDown.y
                        },
                        this._size = yg(this._dragEl), sa(document.body, "katavorio-drag-no-select"), this._dispatch("beforeStart", {
                            el: this.el,
                            pos: this._posAtDown,
                            e: c,
                            drag: this,
                            size: this._size
                        }))
                    } else this._consumeFilteredEvents && Ha(c)
                }
            }
        },
        {
            key: "_moveListener",
            value: function(c) {
                if (this._downAt) {
                    if (!this._moving) {
                        var h = this._dispatch("start", {
                            el: this.el,
                            pos: this._posAtDown,
                            e: c,
                            drag: this,
                            size: this._size
                        });
                        if (!1 !== h) {
                            if (!this._downAt) return;
                            this.mark(h);
                            this._moving = !0
                        } else this.abort()
                    }
                    if (this._downAt) {
                        h = bb(c);
                        var b = h.x - this._downAt.x,
                        g = h.y - this._downAt.y,
                        m = this._ignoreZoom ? 1 : this.k.getZoom();
                        this._lastPosition = {
                            x: h.x,
                            y: h.y
                        };
                        this._lastScrollValues = {
                            x: document.documentElement.scrollLeft,
                            y: document.documentElement.scrollTop
                        };
                        this._dragEl && this._dragEl.parentNode && (b += this._dragEl.parentNode.scrollLeft - this._initialScroll.x, g += this._dragEl.parentNode.scrollTop - this._initialScroll.y);
                        this.moveBy(b / m, g / m, c)
                    }
                }
            }
        },
        {
            key: "mark",
            value: function(c) {
                this._posAtDown = cd(this._dragEl);
                this._pagePosAtDown = sc(this._dragEl);
                this._pageDelta = {
                    x: this._pagePosAtDown.x - this._posAtDown.x,
                    y: this._pagePosAtDown.y - this._posAtDown.y
                };
                this._size = yg(this._dragEl);
                sa(this._dragEl, this.k.css.drag);
                c = this._dragEl;
                this._constrainRect = {
                    w: c.parentNode.offsetWidth + c.parentNode.scrollLeft,
                    h: c.parentNode.offsetHeight + c.parentNode.scrollTop
                };
                this._ghostDy = this._ghostDx = 0
            }
        },
        {
            key: "unmark",
            value: function(c) {
                this._isConstrained && this._useGhostProxy(this._elementToDrag, this._dragEl) ? (this._ghostProxyOffsets = {
                    x: this._dragEl.offsetLeft - this._ghostDx,
                    y: this._dragEl.offsetTop - this._ghostDy
                },
                this._dragEl.parentNode.removeChild(this._dragEl), this._dragEl = this._elementToDrag) : this._ghostProxyOffsets = null;
                ta(this._dragEl, this.k.css.drag);
                this._isConstrained = !1
            }
        },
        {
            key: "moveBy",
            value: function(c, h, b) {
                c = this.toGrid({
                    x: this._posAtDown.x + c,
                    y: this._posAtDown.y + h
                });
                h = this._doConstrain(c, this._dragEl, this._constrainRect, this._size);
                this._useGhostProxy(this.el, this._dragEl) && (c.x !== h.x || c.y !== h.y ? (this._isConstrained || (h = this._ghostProxyFunction(this._elementToDrag), sa(h, "katavorio-ghost-proxy"), this._ghostProxyParent ? (this._ghostProxyParent.appendChild(h), this._currentParentPosition = sc(this._elementToDrag.parentNode), this._ghostParentPosition = sc(this._ghostProxyParent), this._ghostDx = this._currentParentPosition.x - this._ghostParentPosition.x, this._ghostDy = this._currentParentPosition.y - this._ghostParentPosition.y) : this._elementToDrag.parentNode.appendChild(h), this._dragEl = h, this._isConstrained = !0), h = c) : this._isConstrained && (this._dragEl.parentNode.removeChild(this._dragEl), this._dragEl = this._elementToDrag, this._isConstrained = !1, this._ghostParentPosition = this._currentParentPosition = null, this._ghostDy = this._ghostDx = 0));
                zg(this._dragEl, {
                    x: h.x + this._ghostDx,
                    y: h.y + this._ghostDy
                });
                this._dispatch("drag", {
                    el: this.el,
                    pos: h,
                    e: b,
                    drag: this,
                    size: this._size,
                    originalPos: this._posAtDown
                })
            }
        },
        {
            key: "abort",
            value: function() {
                null != this._downAt && this._upListener()
            }
        },
        {
            key: "getDragElement",
            value: function(c) {
                return c ? this._elementToDrag || this.el: this._dragEl || this.el
            }
        },
        {
            key: "stop",
            value: function(c, h) {
                if (h || this._moving) {
                    h = [];
                    var b = cd(this._dragEl);
                    h.push([this._dragEl, b, this, this._size]);
                    this._dispatch("stop", {
                        el: this._dragEl,
                        pos: this._ghostProxyOffsets || b,
                        finalPos: b,
                        e: c,
                        drag: this,
                        selection: h,
                        size: this._size,
                        originalPos: {
                            x: this._posAtDown.x,
                            y: this._posAtDown.y
                        }
                    })
                } else this._moving || (this._activeSelectorParams.dragAbort ? this._activeSelectorParams.dragAbort(this._elementToDrag) : null)
            }
        },
        {
            key: "_dispatch",
            value: function(c, h) {
                var b = null;
                if (this._activeSelectorParams && this._activeSelectorParams[c]) b = this._activeSelectorParams[c](h);
                else if (this.listeners[c]) for (var g = 0; g < this.listeners[c].length; g++) try {
                    var m = this.listeners[c][g](h);
                    null != m && (b = m)
                } catch(r) {}
                return b
            }
        },
        {
            key: "resolveGrid",
            value: function() {
                var c = {
                    grid: null,
                    thresholdX: 5,
                    thresholdY: 5
                };
                null != this._activeSelectorParams && null != this._activeSelectorParams.grid && (c.grid = this._activeSelectorParams.grid, null != this._activeSelectorParams.snapThreshold && (c.thresholdX = this._activeSelectorParams.snapThreshold, c.thresholdY = this._activeSelectorParams.snapThreshold));
                return c
            }
        },
        {
            key: "toGrid",
            value: function(c) {
                var h = this.resolveGrid(),
                b = h.grid,
                g = h.thresholdX;
                h = h.thresholdY;
                return null == b ? c: Ff(c, b, b ? b.w / 2 : g, b ? b.h / 2 : h)
            }
        },
        {
            key: "setUseGhostProxy",
            value: function(c) {
                this._useGhostProxy = c ? lf: zl
            }
        },
        {
            key: "_doConstrain",
            value: function(c, h, b, g) {
                return null != this._activeSelectorParams && this._activeSelectorParams.constrainFunction && "function" === typeof this._activeSelectorParams.constrainFunction ? this._activeSelectorParams.constrainFunction(c, h, b, g) : c
            }
        },
        {
            key: "_testFilter",
            value: function(c) {
                for (var h in this._filters) {
                    var b = this._filters[h],
                    g = b[0](c);
                    b[1] && (g = !g);
                    if (!g) return ! 1
                }
                return ! 0
            }
        },
        {
            key: "addFilter",
            value: function(c, h) {
                var b = this;
                if (c) {
                    var g = Lj(c);
                    this._filters[g] = [function(m) {
                        var r = m.srcElement || m.target,
                        t;
                        J(c) ? t = Bb(r, c, b.el) : "function" === typeof c && (t = c(m, b.el));
                        return t
                    },
                    !1 !== h]
                }
            }
        },
        {
            key: "removeFilter",
            value: function(c) {
                delete this._filters["function" === typeof c ? c._katavorioId: c]
            }
        },
        {
            key: "clearAllFilters",
            value: function() {
                this._filters = {}
            }
        },
        {
            key: "addSelector",
            value: function(c, h) {
                c.selector && (h ? this._availableSelectors.unshift(c) : this._availableSelectors.push(c))
            }
        },
        {
            key: "destroy",
            value: function() {
                this.k.eventManager.off(this.el, "mousedown", this.downListener);
                this.k.eventManager.off(document, "mousemove", this.moveListener);
                this.k.eventManager.off(document, "mouseup", this.upListener);
                this.moveListener = this.upListener = this.downListener = null
            }
        }]);
        return a
    } (Bl),
    nf = function() {
        function k(a) {
            Sa(this, k);
            G(this, "eventManager", void 0);
            G(this, "zoom", 1);
            G(this, "css", {});
            G(this, "inputFilterSelector", void 0);
            a = a || {};
            this.inputFilterSelector = a.inputFilterSelector || "input,textarea,select,button,option";
            this.eventManager = new $b;
            this.zoom = a.zoom || 1;
            A(this.css, a.css || {})
        }
        Ta(k, [{
            key: "getZoom",
            value: function() {
                return this.zoom
            }
        },
        {
            key: "setZoom",
            value: function(a) {
                this.zoom = a
            }
        },
        {
            key: "_prepareParams",
            value: function(a) {
                a = a || {};
                var e = {
                    events: {}
                },
                c;
                for (c in a) e[c] = a[c];
                for (c = 0; c < mf.length; c++) e.events[mf[c]] = a[mf[c]] || Al;
                return e
            }
        },
        {
            key: "getInputFilterSelector",
            value: function() {
                return this.inputFilterSelector
            }
        },
        {
            key: "setInputFilterSelector",
            value: function(a) {
                this.inputFilterSelector = a;
                return this
            }
        },
        {
            key: "draggable",
            value: function(a, e) {
                return null == a._katavorioDrag ? (e = this._prepareParams(e), e = new Cl(a, e, this), sa(a, "katavorio-delegated-draggable"), a._katavorioDrag = e) : a._katavorioDrag
            }
        },
        {
            key: "destroyDraggable",
            value: function(a) {
                a._katavorioDrag && (a._katavorioDrag.destroy(), delete a._katavorioDrag)
            }
        }]);
        return k
    } (),
    Dl = function() {
        function k(a) {
            Sa(this, k);
            this.instance = a;
            G(this, "_dragSelection", []);
            G(this, "_dragSizes", new Map);
            G(this, "_dragElements", new Map);
            G(this, "_dragElementStartPositions", new Map);
            G(this, "_dragElementPositions", new Map);
            G(this, "__activeSet", void 0)
        }
        Ta(k, [{
            key: "_activeSet",
            get: function() {
                return null == this.__activeSet ? this._dragSelection: this.__activeSet
            }
        },
        {
            key: "length",
            get: function() {
                return this._dragSelection.length
            }
        },
        {
            key: "filterActiveSet",
            value: function(a) {
                var e = this;
                this.__activeSet = [];
                P(this._dragSelection,
                function(c) {
                    a(c) && e.__activeSet.push(c)
                })
            }
        },
        {
            key: "clear",
            value: function() {
                var a = this;
                this.reset();
                P(this._dragSelection,
                function(e) {
                    return a.instance.removeClass(e.jel, "jtk-drag-selected")
                });
                this._dragSelection.length = 0
            }
        },
        {
            key: "reset",
            value: function() {
                this._dragElementStartPositions.clear();
                this._dragElementPositions.clear();
                this._dragSizes.clear();
                this._dragElements.clear();
                this.__activeSet = null
            }
        },
        {
            key: "initialisePositions",
            value: function() {
                var a = this;
                P(this._activeSet,
                function(e) {
                    var c = {
                        x: parseInt("" + e.jel.offsetLeft, 10),
                        y: parseInt("" + e.jel.offsetTop, 10)
                    };
                    a._dragElementStartPositions.set(e.id, c);
                    a._dragElementPositions.set(e.id, c);
                    a._dragSizes.set(e.id, a.instance.getSize(e.jel))
                })
            }
        },
        {
            key: "updatePositions",
            value: function(a, e, c) {
                var h = this,
                b = a.x - e.x,
                g = a.y - e.y;
                P(this._activeSet,
                function(m) {
                    var r = h._dragElementStartPositions.get(m.id);
                    if (r) {
                        var t = r.x + b;
                        r = r.y + g;
                        var u = h._dragSizes.get(m.id),
                        v = {
                            x: t,
                            y: r,
                            w: u.w,
                            h: u.h
                        };
                        if (m.jel._jsPlumbParentGroup && m.jel._jsPlumbParentGroup.constrain) {
                            var w = m.jel.parentNode.offsetWidth + m.jel.parentNode.scrollLeft,
                            z = m.jel.parentNode.offsetHeight + m.jel.parentNode.scrollTop;
                            v.x = Math.max(v.x, 0);
                            v.y = Math.max(v.y, 0);
                            v.x = Math.min(v.x, w - u.w);
                            v.y = Math.min(v.y, z - u.h)
                        }
                        h._dragElementPositions.set(m.id, {
                            x: t,
                            y: r
                        });
                        m.jel.style.left = v.x + "px";
                        m.jel.style.top = v.y + "px";
                        c(m.jel, m.id, u, v)
                    }
                })
            }
        },
        {
            key: "each",
            value: function(a) {
                var e = this;
                P(this._activeSet,
                function(c) {
                    var h = e._dragSizes.get(c.id),
                    b = e._dragElementPositions.get(c.id),
                    g = e._dragElementStartPositions.get(c.id);
                    a(c.jel, c.id, b, h, g)
                })
            }
        },
        {
            key: "add",
            value: function(a, e) {
                e = e || this.instance.getId(a); - 1 === ub(this._dragSelection,
                function(c) {
                    return c.id === e
                }) && (this.instance.addClass(a, "jtk-drag-selected"), this._dragSelection.push({
                    id: e,
                    jel: a
                }))
            }
        },
        {
            key: "remove",
            value: function(a) {
                var e = this;
                this._dragSelection = this._dragSelection.filter(function(c) {
                    var h = c.jel !== a;
                    h || e.instance.removeClass(c.jel, "jtk-drag-selected");
                    return h
                })
            }
        },
        {
            key: "toggle",
            value: function(a) { - 1 !== ub(this._dragSelection,
                function(e) {
                    return e.jel === a
                }) ? this.remove(a) : this.add(a)
            }
        }]);
        return k
    } (),
    El = function() {
        function k(a, e, c) {
            var h = this;
            Sa(this, k);
            this.instance = a;
            this.dragSelection = e;
            G(this, "collicat", void 0);
            G(this, "drag", void 0);
            G(this, "_draggables", {});
            G(this, "_dlist", []);
            G(this, "_elementsWithEndpoints", {});
            G(this, "_draggablesForElements", {});
            G(this, "handlers", []);
            G(this, "_trackScroll", void 0);
            G(this, "_filtersToAdd", []);
            this.collicat = new nf({
                zoom: this.instance.currentZoom,
                css: {
                    noSelect: this.instance.dragSelectClass,
                    delegatedDraggable: "jtk-delegated-draggable",
                    draggable: "jtk-draggable",
                    drag: "jtk-drag",
                    selected: "jtk-drag-selected",
                    active: "jtk-drag-active",
                    hover: "jtk-drag-hover",
                    ghostProxy: "jtk-ghost-proxy"
                }
            });
            this.instance.bind("zoom",
            function(b) {
                h.collicat.setZoom(b)
            });
            c = c || {};
            this._trackScroll = !1 !== c.trackScroll
        }
        Ta(k, [{
            key: "addHandler",
            value: function(a, e) {
                var c = this;
                e = A({
                    selector: a.selector
                },
                e || {});
                e.start = ud(e.start,
                function(g) {
                    return a.onStart(g)
                });
                e.drag = ud(e.drag,
                function(g) {
                    return a.onDrag(g)
                });
                e.stop = ud(e.stop,
                function(g) {
                    return a.onStop(g)
                });
                var h = (a.onBeforeStart ||
                function(g) {}).bind(a);
                e.beforeStart = ud(e.beforeStart,
                function(g) {
                    return h(g)
                });
                e.dragInit = function(g) {
                    return a.onDragInit(g)
                };
                e.dragAbort = function(g) {
                    return a.onDragAbort(g)
                };
                a.useGhostProxy && (e.useGhostProxy = a.useGhostProxy, e.makeGhostProxy = a.makeGhostProxy);
                if (null == e.constrainFunction && null != e.containment) switch (e.containment) {
                case rd.notNegative:
                    e.constrainFunction = function(g, m, r, t) {
                        return {
                            x: Math.max(0, Math.min(g.x)),
                            y: Math.max(0, Math.min(g.y))
                        }
                    };
                    break;
                case rd.parent:
                    var b = e.containmentPadding || 5;
                    e.constrainFunction = function(g, m, r, t) {
                        return {
                            x: 0 > g.x ? 0 : g.x > r.w - b ? r.w - b: g.x,
                            y: 0 > g.y ? 0 : g.y > r.h - b ? r.h - b: g.y
                        }
                    };
                    break;
                case rd.parentEnclosed:
                    e.constrainFunction = function(g, m, r, t) {
                        return {
                            x: 0 > g.x ? 0 : g.x + t.w > r.w ? r.w - t.w: g.x,
                            y: 0 > g.y ? 0 : g.y + t.h > r.h ? r.h - t.h: g.y
                        }
                    }
                }
                null == this.drag ? (e.trackScroll = this._trackScroll, this.drag = this.collicat.draggable(this.instance.getContainer(), e), P(this._filtersToAdd,
                function(g) {
                    return c.drag.addFilter(g[0], g[1])
                }), this.drag.on("revert",
                function(g) {
                    c.instance.revalidate(g)
                })) : this.drag.addSelector(e);
                this.handlers.push({
                    handler: a,
                    options: e
                });
                a.init(this.drag)
            }
        },
        {
            key: "addFilter",
            value: function(a, e) {
                null == this.drag ? this._filtersToAdd.push([a, !0 === e]) : this.drag.addFilter(a, e)
            }
        },
        {
            key: "removeFilter",
            value: function(a) {
                null != this.drag && this.drag.removeFilter(a)
            }
        },
        {
            key: "setFilters",
            value: function(a) {
                var e = this;
                P(a,
                function(c) {
                    e.drag.addFilter(c[0], c[1])
                })
            }
        },
        {
            key: "reset",
            value: function() {
                var a = [];
                P(this.handlers,
                function(h) {
                    h.handler.reset()
                });
                if (null != this.drag) {
                    var e = this.drag._filters,
                    c;
                    for (c in e) a.push([c, e[c][1]]);
                    this.collicat.destroyDraggable(this.instance.getContainer())
                }
                delete this.drag;
                return a
            }
        },
        {
            key: "setOption",
            value: function(a, e) {
                var c = ne(this.handlers,
                function(h) {
                    return h.handler === a
                });
                null != c && A(c.options, e || {})
            }
        }]);
        return k
    } (),
    of = function() {
        function k(a, e) {
            Sa(this, k);
            this.instance = a;
            this._dragSelection = e;
            G(this, "selector", "> " + Ba + ":not(" + Eb("jtk-overlay") + ")");
            G(this, "_dragOffset", null);
            G(this, "_groupLocations", []);
            G(this, "_intersectingGroups", []);
            G(this, "_currentDragParentGroup", null);
            G(this, "_dragGroupByElementIdMap", {});
            G(this, "_dragGroupMap", {});
            G(this, "_currentDragGroup", null);
            G(this, "_currentDragGroupOffsets", new Map);
            G(this, "_currentDragGroupSizes", new Map);
            G(this, "_dragPayload", null);
            G(this, "drag", void 0);
            G(this, "originalPosition", void 0)
        }
        Ta(k, [{
            key: "onDragInit",
            value: function(a) {
                return null
            }
        },
        {
            key: "onDragAbort",
            value: function(a) {
                return null
            }
        },
        {
            key: "getDropGroup",
            value: function() {
                var a = null;
                if (0 < this._intersectingGroups.length) {
                    var e = this._intersectingGroups[0].groupLoc.group,
                    c = this._intersectingGroups[0].intersectingElement,
                    h = c._jsPlumbParentGroup;
                    h !== e && (null != h && h.overrideDrop(c, e) || (a = this._intersectingGroups[0]))
                }
                return a
            }
        },
        {
            key: "onStop",
            value: function(a) {
                var e = this,
                c = a.drag.getDragElement(),
                h = this.getDropGroup(),
                b = [];
                b.push({
                    el: c,
                    id: this.instance.getId(c),
                    pos: a.finalPos,
                    originalGroup: c._jsPlumbParentGroup,
                    redrawResult: null,
                    originalPos: a.originalPos,
                    reverted: !1,
                    dropGroup: null != h ? h.groupLoc.group: null
                });
                this._dragSelection.each(function(u, v, w, z, y) {
                    if (u !== a.el) {
                        w = {
                            x: w.x,
                            y: w.y
                        };
                        var E = w.x,
                        F = w.y;
                        if (u._jsPlumbParentGroup && u._jsPlumbParentGroup.constrain) {
                            var M = u.parentNode.offsetWidth + u.parentNode.scrollLeft,
                            S = u.parentNode.offsetHeight + u.parentNode.scrollTop;
                            E = Math.max(E, 0);
                            F = Math.max(F, 0);
                            E = Math.min(E, M - z.w);
                            F = Math.min(F, S - z.h);
                            w.x = E;
                            w.y = F
                        }
                        b.push({
                            el: u,
                            id: v,
                            pos: w,
                            originalPos: y,
                            originalGroup: u._jsPlumbParentGroup,
                            redrawResult: null,
                            reverted: !1,
                            dropGroup: null != h ? h.groupLoc.group: null
                        })
                    }
                });
                P(b,
                function(u) {
                    var v = null != u.originalGroup,
                    w = v && Ag(e.instance, u.el, u.pos),
                    z = {
                        x: 0,
                        y: 0
                    };
                    v && !w ? null == h && (v = e._pruneOrOrphan(u, !0, !0), null != v.pos ? u.pos = v.pos.pos: !v.pruned && u.originalGroup.revert && (u.pos = u.originalPos, u.reverted = !0)) : v && w && (z = e.instance.viewport.getPosition(u.originalGroup.elId));
                    null == h || w ? u.dropGroup = null: e.instance.groupManager.addToGroup(h.groupLoc.group, !1, u.el);
                    u.reverted && e.instance.setPosition(u.el, u.pos);
                    u.redrawResult = e.instance.setElementPosition(u.el, u.pos.x + z.x, u.pos.y + z.y);
                    e.instance.removeClass(u.el, "jtk-dragged");
                    e.instance.select({
                        source: u.el
                    }).removeClass(e.instance.elementDraggingClass + " " + e.instance.sourceElementDraggingClass, !0);
                    e.instance.select({
                        target: u.el
                    }).removeClass(e.instance.elementDraggingClass + " " + e.instance.targetElementDraggingClass, !0)
                });
                if (null != b[0].originalGroup) {
                    var g = c._jsPlumbParentGroup;
                    if (g !== b[0].originalGroup) {
                        var m = a.drag.getDragElement(!0);
                        if (b[0].originalGroup.ghost) {
                            g = this.instance.getOffset(this.instance.getGroupContentArea(g));
                            var r = this.instance.getOffset(this.instance.getGroupContentArea(b[0].originalGroup)),
                            t = r.y + a.pos.y - g.y;
                            m.style.left = r.x + a.pos.x - g.x + "px";
                            m.style.top = t + "px";
                            this.instance.revalidate(m)
                        }
                    }
                }
                this.instance.fire("drag:stop", {
                    elements: b,
                    e: a.e,
                    el: c,
                    payload: this._dragPayload
                });
                this._cleanup()
            }
        },
        {
            key: "_cleanup",
            value: function() {
                var a = this;
                P(this._groupLocations,
                function(e) {
                    a.instance.removeClass(e.el, "jtk-drag-active");
                    a.instance.removeClass(e.el, "jtk-drag-hover")
                });
                this._currentDragParentGroup = null;
                this._groupLocations.length = 0;
                this.instance.hoverSuspended = !1;
                this._dragOffset = null;
                this._dragSelection.reset();
                this._dragPayload = null;
                this._currentDragGroupOffsets.clear();
                this._currentDragGroupSizes.clear();
                this._currentDragGroup = null
            }
        },
        {
            key: "reset",
            value: function() {}
        },
        {
            key: "init",
            value: function(a) {
                this.drag = a
            }
        },
        {
            key: "onDrag",
            value: function(a) {
                var e = this,
                c = a.drag.getDragElement(),
                h = a.pos,
                b = this.instance.getSize(c),
                g = h.x,
                m = h.y;
                this._intersectingGroups.length = 0;
                null != this._dragOffset && (g += this._dragOffset.x, m += this._dragOffset.y);
                var r = function(u, v, w) {
                    if (w) {
                        var z = new Set;
                        P(e._groupLocations,
                        function(y) { ! z.has(y.group.id) && cc(v, y.r) ? (y.group !== e._currentDragParentGroup && e.instance.addClass(y.el, "jtk-drag-hover"), e._intersectingGroups.push({
                                groupLoc: y,
                                intersectingElement: a.drag.getDragElement(!0),
                                d: 0
                            }), P(e.instance.groupManager.getAncestors(y.group),
                            function(E) {
                                return z.add(E.id)
                            })) : e.instance.removeClass(y.el, "jtk-drag-hover")
                        })
                    }
                    e.instance.setElementPosition(u, v.x, v.y);
                    e.instance.fire("drag:move", {
                        el: u,
                        e: a.e,
                        pos: {
                            x: v.x,
                            y: v.y
                        },
                        originalPosition: e.originalPosition,
                        payload: e._dragPayload
                    })
                },
                t = {
                    x: g,
                    y: m,
                    w: b.w,
                    h: b.h
                };
                r(c, t, !0);
                this._dragSelection.updatePositions(h, this.originalPosition,
                function(u, v, w, z) {
                    r(u, z, !1)
                });
                this._currentDragGroupOffsets.forEach(function(u, v) {
                    v = e._currentDragGroupSizes.get(v);
                    v = {
                        x: t.x + u[0].x,
                        y: t.y + u[0].y,
                        w: v.w,
                        h: v.h
                    };
                    u[1].style.left = v.x + "px";
                    u[1].style.top = v.y + "px";
                    r(u[1], v, !1)
                })
            }
        },
        {
            key: "onStart",
            value: function(a) {
                var e = this,
                c = a.drag.getDragElement(),
                h = this.instance.getOffset(c);
                this.originalPosition = {
                    x: a.pos.x,
                    y: a.pos.y
                };
                c._jsPlumbParentGroup && (this._dragOffset = this.instance.getOffset(c.offsetParent), this._currentDragParentGroup = c._jsPlumbParentGroup);
                var b = !0,
                g = c.getAttribute("data-jtk-not-draggable");
                if (!1 === this.instance.elementsDraggable || null != g && "false" !== g) b = !1;
                if (b) {
                    this._groupLocations.length = 0;
                    this._intersectingGroups.length = 0;
                    this.instance.hoverSuspended = !0;
                    var m = a.drag.getDragElement(!0);
                    g = m.querySelectorAll(Ba);
                    m = Oj(m);
                    var r = [];
                    Array.prototype.push.apply(r, g);
                    Array.prototype.push.apply(r, m);
                    this._dragSelection.filterActiveSet(function(u) {
                        return - 1 === r.indexOf(u.jel)
                    });
                    this._dragSelection.initialisePositions();
                    var t = function(u) {
                        if (!u._isJsPlumbGroup || e.instance.allowNestedGroups) {
                            var v = !u._jsPlumbParentGroup,
                            w = v || !0 !== u._jsPlumbParentGroup.dropOverride,
                            z = !v && (u._jsPlumbParentGroup.ghost || !0 !== u._jsPlumbParentGroup.constrain);
                            if (v || w && z) P(e.instance.groupManager.getGroups(),
                            function(y) {
                                var E = u._jsPlumbGroup;
                                if (!1 !== y.droppable && !1 !== y.enabled && u._jsPlumbGroup !== y && !e.instance.groupManager.isDescendant(y, E)) {
                                    E = y.el;
                                    var F = e.instance.getSize(E),
                                    M = e.instance.getOffset(E);
                                    e._groupLocations.push({
                                        el: E,
                                        r: {
                                            x: M.x,
                                            y: M.y,
                                            w: F.w,
                                            h: F.h
                                        },
                                        group: y
                                    });
                                    y !== e._currentDragParentGroup && e.instance.addClass(E, "jtk-drag-active")
                                }
                            }),
                            e._groupLocations.sort(function(y, E) {
                                return e.instance.groupManager.isDescendant(y.group, E.group) ? -1 : e.instance.groupManager.isAncestor(E.group, y.group) ? 1 : 0
                            })
                        }
                        e.instance.select({
                            source: u
                        }).addClass(e.instance.elementDraggingClass + " " + e.instance.sourceElementDraggingClass, !0);
                        e.instance.select({
                            target: u
                        }).addClass(e.instance.elementDraggingClass + " " + e.instance.targetElementDraggingClass, !0);
                        return e.instance.fire("drag:start", {
                            el: u,
                            e: a.e,
                            originalPosition: e.originalPosition,
                            pos: e.originalPosition
                        })
                    };
                    g = this.instance.getId(c); (this._currentDragGroup = this._dragGroupByElementIdMap[g]) && !Nj(this._currentDragGroup, c) && (this._currentDragGroup = null);
                    c = t(c);
                    if (!1 === c) return this._cleanup(),
                    !1;
                    this._dragPayload = c;
                    null != this._currentDragGroup && (this._currentDragGroupOffsets.clear(), this._currentDragGroupSizes.clear(), this._currentDragGroup.members.forEach(function(u) {
                        var v = e.instance.getOffset(u.el);
                        e._currentDragGroupOffsets.set(u.elId, [{
                            x: v.x - h.x,
                            y: v.y - h.y
                        },
                        u.el]);
                        e._currentDragGroupSizes.set(u.elId, e.instance.getSize(u.el));
                        t(u.el)
                    }))
                }
                return b
            }
        },
        {
            key: "addToDragGroup",
            value: function(a) {
                var e = this,
                c = Mj(this.instance, a),
                h = this._dragGroupMap[c.id];
                null == h && (h = {
                    id: c.id,
                    members: new Set
                },
                this._dragGroupMap[c.id] = h);
                for (var b = arguments.length,
                g = Array(1 < b ? b - 1 : 0), m = 1; m < b; m++) g[m - 1] = arguments[m];
                this.removeFromDragGroup.apply(this, g);
                P(g,
                function(r) {
                    var t = e.instance.getId(r);
                    h.members.add({
                        elId: t,
                        el: r,
                        active: c.active
                    });
                    e._dragGroupByElementIdMap[t] = h
                })
            }
        },
        {
            key: "removeFromDragGroup",
            value: function() {
                for (var a = this,
                e = arguments.length,
                c = Array(e), h = 0; h < e; h++) c[h] = arguments[h];
                P(c,
                function(b) {
                    var g = a.instance.getId(b),
                    m = a._dragGroupByElementIdMap[g];
                    if (null != m) {
                        var r = new Set;
                        m.members.forEach(function(t) {
                            t.el !== b && r.add(t)
                        });
                        m.members = r;
                        delete a._dragGroupByElementIdMap[g]
                    }
                })
            }
        },
        {
            key: "setDragGroupState",
            value: function(a) {
                for (var e = this,
                c = arguments.length,
                h = Array(1 < c ? c - 1 : 0), b = 1; b < c; b++) h[b - 1] = arguments[b];
                c = h.map(function(g) {
                    return e.instance.getId(g)
                });
                P(c,
                function(g) {
                    var m = e._dragGroupByElementIdMap[g];
                    null != m && (m = xf(m.members,
                    function(r) {
                        return r.elId === g
                    }), null != m && (m.active = a))
                })
            }
        },
        {
            key: "_pruneOrOrphan",
            value: function(a, e, c) {
                var h = a.el,
                b = {
                    pruned: !1,
                    pos: null
                };
                if (c || !Ag(this.instance, h, a.pos)) c = h._jsPlumbParentGroup,
                c.prune ? (h._isJsPlumbGroup ? this.instance.removeGroup(h._jsPlumbGroup) : c.remove(a.el, !0), b.pruned = !0) : c.orphan && (b.pos = this.instance.groupManager.orphan(a.el, e), h._isJsPlumbGroup ? c.removeGroup(h._jsPlumbGroup) : c.remove(a.el));
                return b
            }
        }]);
        return k
    } (),
    Fl = Eb("jtk-drag-active", "jtk-drag-hover"),
    Fi = function() {
        function k(a) {
            Sa(this, k);
            this.instance = a;
            G(this, "jpc", void 0);
            G(this, "existingJpc", void 0);
            G(this, "_originalAnchor", void 0);
            G(this, "ep", void 0);
            G(this, "endpointRepresentation", void 0);
            G(this, "canvasElement", void 0);
            G(this, "_activeDefinition", void 0);
            G(this, "placeholderInfo", {
                id: null,
                element: null
            });
            G(this, "floatingIndex", void 0);
            G(this, "floatingId", void 0);
            G(this, "floatingElement", void 0);
            G(this, "floatingEndpoint", void 0);
            G(this, "floatingAnchor", void 0);
            G(this, "_stopped", void 0);
            G(this, "inPlaceCopy", void 0);
            G(this, "endpointDropTargets", []);
            G(this, "currentDropTarget", null);
            G(this, "payload", void 0);
            G(this, "floatingConnections", {});
            G(this, "_forceReattach", void 0);
            G(this, "_forceDetach", void 0);
            G(this, "mousedownHandler", void 0);
            G(this, "mouseupHandler", void 0);
            G(this, "selector", Eb("jtk-endpoint"));
            var e = a.getContainer();
            this.mousedownHandler = this._mousedownHandler.bind(this);
            this.mouseupHandler = this._mouseupHandler.bind(this);
            a.on(e, "mousedown", Ba, this.mousedownHandler);
            a.on(e, "mouseup", [Ba, Eb("jtk-endpoint")].join(), this.mouseupHandler)
        }
        Ta(k, [{
            key: "_resolveDragParent",
            value: function(a, e) {
                var c = this.instance.getContainer(),
                h = sb(e, Ba, c, !0);
                return null != a.parentSelector ? (a = sb(e, a.parentSelector, c, !0), null != a && (h = sb(a.parentNode, Ba, c, !1)), a || h) : h
            }
        },
        {
            key: "_mousedownHandler",
            value: function(a) {
                if (3 !== a.which && 2 !== a.button) {
                    var e = a.target || a.srcElement;
                    var c = this._getSourceDefinition(a);
                    if (null != c) {
                        var h = this._resolveDragParent(c.def, e);
                        if (null == h || "false" === h.getAttribute("data-jtk-enabled")) return
                    }
                    if (c) {
                        var b = a.currentTarget;
                        if ("false" !== e.getAttribute("data-jtk-enabled")) {
                            Ha(a);
                            this._activeDefinition = c;
                            var g = c.def;
                            var m = this.instance.select({
                                source: h
                            }).length;
                            if (0 <= c.maxConnections && m >= c.maxConnections) {
                                Ha(a);
                                if (g.onMaxConnections) g.onMaxConnections({
                                    element: h,
                                    maxConnections: c.maxConnections
                                },
                                a);
                                a.stopImmediatePropagation && a.stopImmediatePropagation();
                                return ! 1
                            }
                            var r = h;
                            var t = this.instance.currentZoom,
                            u = "undefined" !== Yc(r.getBoundingClientRect) ? r.getBoundingClientRect() : {
                                left: 0,
                                top: 0,
                                width: 0,
                                height: 0
                            };
                            m = document.body;
                            var v = document.documentElement,
                            w = u.top + (window.pageYOffset || v.scrollTop || m.scrollTop) - (v.clientTop || m.clientTop || 0) + 0 * t;
                            m = u.left + (window.pageXOffset || v.scrollLeft || m.scrollLeft) - (v.clientLeft || m.clientLeft || 0) + 0 * t;
                            v = bb(a);
                            m = (v.x - m) / (u.width || r.offsetWidth * t);
                            r = (v.y - w) / (u.height || r.offsetHeight * t);
                            t = {
                                element: h
                            };
                            A(t, g);
                            t.isTemporarySource = !0;
                            g.scope ? t.scope = g.scope: (u = e.getAttribute("data-jtk-scope"), null != u && (t.scope = u));
                            h = g.parameterExtractor ? g.parameterExtractor(h, e) : {};
                            t = R(t, h);
                            this._originalAnchor = t.anchor || (this.instance.areDefaultAnchorsSet() ? this.instance.defaults.anchors[0] : this.instance.defaults.anchor);
                            t.anchor = [m, r, 0, 0];
                            t.deleteOnEmpty = !0;
                            this.ep = this.instance._internal_newEndpoint(t);
                            h = {};
                            if (g.extract) {
                                for (var z in g.extract)(m = e.getAttribute(z)) && (h[g.extract[z]] = m);
                                this.ep.mergeParameters(h)
                            }
                            g.uniqueEndpoint && (c.endpoint ? this.ep.finalEndpoint = c.endpoint: (c.endpoint = this.ep, this.ep.deleteOnEmpty = !1));
                            b._jsPlumbOrphanedEndpoints = b._jsPlumbOrphanedEndpoints || [];
                            b._jsPlumbOrphanedEndpoints.push(this.ep);
                            this.instance.trigger(this.ep.endpoint.canvas, "mousedown", a, h)
                        }
                    }
                }
            }
        },
        {
            key: "_mouseupHandler",
            value: function(a) {
                a = a.currentTarget || a.srcElement;
                if (a._jsPlumbOrphanedEndpoints) {
                    var e = a._jsPlumbOrphanedEndpoints,
                    c = this.instance._maybePruneEndpoint.bind(this.instance);
                    e = null == e.length || "string" === typeof e ? [e] : e;
                    for (var h = 0; h < e.length; h++) c(e[h]);
                    a._jsPlumbOrphanedEndpoints.length = 0
                }
                this._activeDefinition = null
            }
        },
        {
            key: "onDragInit",
            value: function(a) {
                var e = this.instance.getOffset(a),
                c = this.instance.getSize(a);
                this._makeDraggablePlaceholder(e, c);
                this.placeholderInfo.element.jtk = a.jtk;
                return this.placeholderInfo.element
            }
        },
        {
            key: "onDragAbort",
            value: function(a) {
                this._cleanupDraggablePlaceholder()
            }
        },
        {
            key: "_makeDraggablePlaceholder",
            value: function(a, e) {
                this.placeholderInfo = this.placeholderInfo || {};
                var c = Zc(null, "div", {
                    position: "absolute"
                },
                void 0, void 0);
                this.instance._appendElement(c, this.instance.getContainer());
                var h = this.instance.getId(c);
                this.instance.setPosition(c, a);
                c.style.width = e.w + "px";
                c.style.height = e.h + "px";
                this.instance.manage(c);
                this.placeholderInfo.id = h;
                return this.placeholderInfo.element = c
            }
        },
        {
            key: "_cleanupDraggablePlaceholder",
            value: function() {
                this.placeholderInfo.element && (this.instance.unmanage(this.placeholderInfo.element, !0), delete this.placeholderInfo.element, delete this.placeholderInfo.id)
            }
        },
        {
            key: "reset",
            value: function() {
                var a = this.instance.getContainer();
                this.instance.off(a, "mouseup", this.mouseupHandler);
                this.instance.off(a, "mousedown", this.mousedownHandler)
            }
        },
        {
            key: "init",
            value: function(a) {}
        },
        {
            key: "startNewConnectionDrag",
            value: function(a, e) {
                this.jpc = this.instance._newConnection({
                    sourceEndpoint: this.ep,
                    targetEndpoint: this.floatingEndpoint,
                    source: this.ep.element,
                    target: this.placeholderInfo.element,
                    paintStyle: this.ep.connectorStyle,
                    hoverPaintStyle: this.ep.connectorHoverStyle,
                    connector: this.ep.connector,
                    overlays: this.ep.connectorOverlays,
                    type: this.ep.edgeType,
                    cssClass: this.ep.connectorClass,
                    hoverClass: this.ep.connectorHoverClass,
                    scope: a,
                    data: e
                });
                this.jpc.pending = !0;
                this.jpc.addClass(this.instance.draggingClass);
                this.floatingEndpoint.addClass(this.instance.draggingClass);
                this.instance.fire("connection:drag", this.jpc)
            }
        },
        {
            key: "startExistingConnectionDrag",
            value: function() {
                this.existingJpc = !0;
                this.instance.setHover(this.jpc, !1);
                var a = this.jpc.endpoints[0].id === this.ep.id ? 0 : 1;
                this.ep.detachFromConnection(this.jpc, null, !0);
                this.floatingEndpoint.addConnection(this.jpc);
                this.floatingEndpoint.addClass(this.instance.draggingClass);
                this.instance.fire("connection:drag", this.jpc);
                this.instance.sourceOrTargetChanged(this.jpc.endpoints[a].elementId, this.placeholderInfo.id, this.jpc, this.placeholderInfo.element, a);
                this.jpc.suspendedEndpoint = this.jpc.endpoints[a];
                this.jpc.suspendedElement = this.jpc.endpoints[a].element;
                this.jpc.suspendedElementId = this.jpc.endpoints[a].elementId;
                this.jpc.suspendedElementType = 0 === a ? "source": "target";
                this.instance.setHover(this.jpc.suspendedEndpoint, !1);
                this.floatingEndpoint.referenceEndpoint = this.jpc.suspendedEndpoint;
                this.floatingEndpoint.mergeParameters(this.jpc.suspendedEndpoint.parameters);
                this.jpc.endpoints[a] = this.floatingEndpoint;
                this.jpc.addClass(this.instance.draggingClass);
                this.floatingId = this.placeholderInfo.id;
                this.floatingIndex = a
            }
        },
        {
            key: "_shouldStartDrag",
            value: function() {
                var a = !0;
                this.ep.enabled || (a = !1);
                null != this.jpc || this.ep.isSource || this.ep.isTemporarySource || (a = !1); ! this.ep.isSource || !this.ep.isFull() || null != this.jpc && this.ep.dragAllowedWhenFull || (a = !1);
                null == this.jpc || this.jpc.isDetachable(this.ep) || (this.ep.isFull() ? a = !1 : this.jpc = null);
                var e = {},
                c = this.instance.checkCondition(null == this.jpc ? "beforeDrag": "beforeStartDetach", {
                    endpoint: this.ep,
                    source: this.ep.element,
                    sourceId: this.ep.elementId,
                    connection: this.jpc
                }); ! 1 === c ? a = !1 : "object" === Yc(c) ? (e = c, A(e, this.payload || {})) : e = this.payload || {};
                return [a, e]
            }
        },
        {
            key: "_createFloatingEndpoint",
            value: function(a) {
                a = this.ep.endpoint;
                null != this.ep.edgeType && (a = this.instance._deriveEndpointAndAnchorSpec(this.ep.edgeType).endpoints[1]);
                var e = this.ep.getPaintStyle(),
                c = a,
                h = this.placeholderInfo.element;
                a = this.instance;
                var b = this.ep.scope,
                g = new yk(a, h);
                e = {
                    paintStyle: e,
                    preparedAnchor: g,
                    element: h,
                    scope: b
                };
                null != c && (zf(c, Ac) ? e.existingEndpoint = c: e.endpoint = c);
                e = a._internal_newEndpoint(e);
                a.paintEndpoint(e, {});
                this.floatingEndpoint = e;
                this.floatingAnchor = this.floatingEndpoint._anchor;
                this.floatingEndpoint.deleteOnEmpty = !0;
                this.floatingElement = this.floatingEndpoint.endpoint.canvas;
                this.floatingId = this.instance.getId(this.floatingElement)
            }
        },
        {
            key: "_populateTargets",
            value: function(a) {
                var e = this,
                c = this.jpc && this.jpc.endpoints[0] === this.ep,
                h,
                b = this.instance.getContainer().querySelectorAll([".jtk-endpoint[data-jtk-scope-", this.ep.scope, "]"].join(""));
                P(b,
                function(m) {
                    if ((null != e.jpc || m !== a) && m !== e.floatingElement && (c && m.jtk.endpoint.isSource || !c && m.jtk.endpoint.isTarget)) {
                        var r = e.instance.getOffset(m),
                        t = e.instance.getSize(m);
                        h = {
                            x: r.x,
                            y: r.y,
                            w: t.w,
                            h: t.h
                        };
                        e.endpointDropTargets.push({
                            el: m,
                            targetEl: m,
                            r: h,
                            endpoint: m.jtk.endpoint,
                            def: null
                        });
                        e.instance.addClass(m, "jtk-drag-active")
                    }
                });
                if (c) {
                    var g = ne(this.instance.sourceSelectors,
                    function(m) {
                        return m.isEnabled() && (null == m.def.def.scope || m.def.def.scope === e.ep.scope)
                    });
                    null != g && (b = this.instance.getContainer().querySelectorAll("any" === g.redrop ? Ba: g.selector), P(b,
                    function(m) {
                        if ("false" !== m.getAttribute("data-jtk-enabled")) {
                            var r = m.getAttribute("data-jtk-scope");
                            if (null == r || r === e.ep.scope) {
                                r = {
                                    r: null,
                                    el: m
                                };
                                r.targetEl = sb(m, Ba, e.instance.getContainer(), !0);
                                m = e.instance.getOffset(r.el);
                                var t = e.instance.getSize(r.el);
                                r.r = {
                                    x: m.x,
                                    y: m.y,
                                    w: t.w,
                                    h: t.h
                                };
                                null != g.def.def.rank && (r.rank = g.def.def.rank);
                                r.def = g;
                                e.endpointDropTargets.push(r);
                                e.instance.addClass(r.targetEl, "jtk-drag-active")
                            }
                        }
                    }))
                } else Zi(this.instance.targetSelectors,
                function(m) {
                    return m.isEnabled()
                }).forEach(function(m) {
                    var r = e.instance.getContainer().querySelectorAll(m.selector);
                    P(r,
                    function(t) {
                        if ("false" !== t.getAttribute("data-jtk-enabled")) {
                            var u = t.getAttribute("data-jtk-scope");
                            if (null == u || u === e.ep.scope) if (u = {
                                r: null,
                                el: t
                            },
                            null != m.def.def.parentSelector && (u.targetEl = sb(t, m.def.def.parentSelector, e.instance.getContainer(), !0)), null == u.targetEl && (u.targetEl = sb(t, Ba, e.instance.getContainer(), !0)), !(!1 === m.def.def.allowLoopback || e._activeDefinition && !1 === e._activeDefinition.def.allowLoopback) || u.targetEl !== e.ep.element) {
                                var v = e.instance.getOffset(t);
                                t = e.instance.getSize(t);
                                u.r = {
                                    x: v.x,
                                    y: v.y,
                                    w: t.w,
                                    h: t.h
                                };
                                u.def = m.def;
                                null != m.def.def.rank && (u.rank = m.def.def.rank);
                                e.endpointDropTargets.push(u);
                                e.instance.addClass(u.targetEl, "jtk-drag-active")
                            }
                        }
                    })
                });
                this.endpointDropTargets.sort(function(m, r) {
                    if (m.targetEl._isJsPlumbGroup && !r.targetEl._isJsPlumbGroup) return 1;
                    if (!m.targetEl._isJsPlumbGroup && r.targetEl._isJsPlumbGroup) return - 1;
                    if (m.targetEl._isJsPlumbGroup && r.targetEl._isJsPlumbGroup) {
                        if (e.instance.groupManager.isAncestor(m.targetEl._jsPlumbGroup, r.targetEl._jsPlumbGroup)) return - 1;
                        if (e.instance.groupManager.isAncestor(r.targetEl._jsPlumbGroup, m.targetEl._jsPlumbGroup)) return 1
                    } else if (null != m.rank && null != r.rank) {
                        if (m.rank > r.rank) return - 1;
                        if (m.rank < r.rank) return 1
                    } else return 0
                })
            }
        },
        {
            key: "onStart",
            value: function(a) {
                this.endpointDropTargets.length = 0;
                this.currentDropTarget = null;
                this._stopped = !1;
                this.ep = a.drag.getDragElement().jtk.endpoint;
                if (!this.ep) return ! 1;
                this.endpointRepresentation = this.ep.endpoint;
                this.canvasElement = this.endpointRepresentation.canvas;
                this.jpc = this.ep.connectorSelector();
                a = this._shouldStartDrag();
                var e = Array.isArray(a) ? a: void 0;
                if (!e) if (e = null == a ? null: "undefined" !== typeof Symbol && a[Symbol.iterator] || a["@@iterator"], null != e) {
                    var c = [],
                    h = !0,
                    b = !1,
                    g;
                    try {
                        for (e = e.call(a); ! (h = (g = e.next()).done) && (c.push(g.value), 2 !== c.length); h = !0);
                    } catch(r) {
                        b = !0;
                        var m = r
                    } finally {
                        try {
                            if (!h && null != e["return"]) e["return"]()
                        } finally {
                            if (b) throw m;
                        }
                    }
                    e = c
                } else e = void 0;
                if (! (g = e)) a: {
                    if (a) {
                        if ("string" === typeof a) {
                            g = pg(a, 2);
                            break a
                        }
                        g = Object.prototype.toString.call(a).slice(8, -1);
                        "Object" === g && a.constructor && (g = a.constructor.name);
                        if ("Map" === g || "Set" === g) {
                            g = Array.from(a);
                            break a
                        }
                        if ("Arguments" === g || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(g)) {
                            g = pg(a, 2);
                            break a
                        }
                    }
                    g = void 0
                }
                if (! (a = g)) throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                g = a[1];
                if (!1 === a[0]) return this._stopped = !0,
                !1;
                this.instance.setHover(this.ep, !1);
                this.instance.isConnectionBeingDragged = !0;
                this.jpc && !this.ep.isFull() && this.ep.isSource && (this.jpc = null);
                this._createFloatingEndpoint(this.canvasElement);
                this._populateTargets(this.canvasElement);
                null == this.jpc ? this.startNewConnectionDrag(this.ep.scope, g) : this.startExistingConnectionDrag();
                this._registerFloatingConnection(this.placeholderInfo, this.jpc, this.floatingEndpoint);
                this.instance.currentlyDragging = !0
            }
        },
        {
            key: "onBeforeStart",
            value: function(a) {
                this.payload = a.e.payload || {}
            }
        },
        {
            key: "onDrag",
            value: function(a) {
                if (this._stopped) return ! 0;
                if (this.placeholderInfo.element) {
                    var e = this.instance.getSize(this.floatingElement);
                    this.instance.setElementPosition(this.placeholderInfo.element, a.pos.x, a.pos.y);
                    a = {
                        x: a.pos.x,
                        y: a.pos.y,
                        w: e.w,
                        h: e.h
                    };
                    for (e = 0; e < this.endpointDropTargets.length; e++) if (cc(a, this.endpointDropTargets[e].r)) {
                        var c = this.endpointDropTargets[e];
                        break
                    }
                    c !== this.currentDropTarget && null != this.currentDropTarget && (this._getFloatingAnchorIndex(), this.instance.removeClass(this.currentDropTarget.el, "jtk-drag-hover"), this.currentDropTarget.endpoint && (this.currentDropTarget.endpoint.endpoint.removeClass(this.instance.endpointDropAllowedClass), this.currentDropTarget.endpoint.endpoint.removeClass(this.instance.endpointDropForbiddenClass)), this.floatingAnchor.out());
                    null != c && (this.instance.addClass(c.el, "jtk-drag-hover"), a = this._getFloatingAnchorIndex(), null != c.endpoint && ((e = c.endpoint.isSource && 0 === a || c.endpoint.isTarget && 0 !== a || this.jpc.suspendedEndpoint && c.endpoint.referenceEndpoint && c.endpoint.referenceEndpoint.id === this.jpc.suspendedEndpoint.id) ? (this.instance.checkCondition("checkDropAllowed", {
                        sourceEndpoint: this.jpc.endpoints[a],
                        targetEndpoint: c.endpoint.endpoint,
                        connection: this.jpc
                    }) ? (c.endpoint.endpoint.addClass(this.instance.endpointDropAllowedClass), c.endpoint.endpoint.removeClass(this.instance.endpointDropForbiddenClass)) : (c.endpoint.endpoint.removeClass(this.instance.endpointDropAllowedClass), c.endpoint.endpoint.addClass(this.instance.endpointDropForbiddenClass)), this.floatingAnchor.over(c.endpoint)) : c = null));
                    this.currentDropTarget = c
                }
            }
        },
        {
            key: "_maybeCleanup",
            value: function(a) {
                a._mtNew && 0 === a.connections.length ? this.instance.deleteEndpoint(a) : delete a._mtNew
            }
        },
        {
            key: "_reattachOrDiscard",
            value: function(a) {
                var e = null != this.jpc.suspendedEndpoint,
                c = this._getFloatingAnchorIndex();
                if (e && this._shouldReattach(a)) return 0 === c ? (this.jpc.source = this.jpc.suspendedElement, this.jpc.sourceId = this.jpc.suspendedElementId) : (this.jpc.target = this.jpc.suspendedElement, this.jpc.targetId = this.jpc.suspendedElementId),
                this._doForceReattach(c),
                !0;
                this._discard(c, a);
                return ! 1
            }
        },
        {
            key: "onStop",
            value: function(a) {
                var e = this,
                c = a.e;
                this.instance.isConnectionBeingDragged = !1;
                this.instance.currentlyDragging = !1;
                var h = ue("jtk-drag-hover", "jtk-drag-active"),
                b = this.instance.getContainer().querySelectorAll(Fl);
                P(b,
                function(t) {
                    e.instance.removeClass(t, h)
                });
                if (this.jpc && null != this.jpc.endpoints) {
                    b = null != this.jpc.suspendedEndpoint;
                    var g = this._getFloatingAnchorIndex(),
                    m = this.jpc.suspendedEndpoint;
                    if (null != this.currentDropTarget) {
                        var r = this._getDropEndpoint(a, this.jpc);
                        null == r ? !this._reattachOrDiscard(a.e) : m && m.id === r.id ? this._doForceReattach(g) : r.enabled ? r.isFull() ? (r.fire("maxConnections", {
                            endpoint: this,
                            connection: this.jpc,
                            maxConnections: this.instance.defaults.maxConnections
                        },
                        c), this._reattachOrDiscard(a.e)) : (0 === g ? (this.jpc.source = r.element, this.jpc.sourceId = r.elementId) : (this.jpc.target = r.element, this.jpc.targetId = r.elementId), m = !0, b && this.jpc.suspendedEndpoint.id !== r.id && (this.jpc.isDetachAllowed(this.jpc) && this.jpc.endpoints[g].isDetachAllowed(this.jpc) && this.jpc.suspendedEndpoint.isDetachAllowed(this.jpc) && this.instance.checkCondition("beforeDetach", this.jpc) || (m = !1)), (m = m && r.isDropAllowed(this.jpc.sourceId, this.jpc.targetId, this.jpc.scope, this.jpc, r)) ? this._drop(r, g, c, m) : this._reattachOrDiscard(a.e)) : this._reattachOrDiscard(a.e)
                    } else this._reattachOrDiscard(a.e);
                    this.instance.refreshEndpoint(this.ep);
                    this.ep.removeClass(this.instance.draggingClass);
                    this._cleanupDraggablePlaceholder();
                    this.jpc.removeClass(this.instance.draggingClass);
                    delete this.jpc.suspendedEndpoint;
                    delete this.jpc.suspendedElement;
                    delete this.jpc.suspendedElementType;
                    delete this.jpc.suspendedElementId;
                    delete this.jpc.suspendedIndex;
                    delete this.floatingId;
                    delete this.floatingIndex;
                    delete this.floatingElement;
                    delete this.floatingEndpoint;
                    delete this.floatingAnchor;
                    delete this.jpc.pending;
                    null != r && this._maybeCleanup(r)
                }
            }
        },
        {
            key: "_getSourceDefinition",
            value: function(a) {
                for (var e, c = 0; c < this.instance.sourceSelectors.length; c++) if (e = this.instance.sourceSelectors[c], e.isEnabled()) {
                    var h = this.instance.getContainer(),
                    b = e.exclude,
                    g = a.target || a.srcElement,
                    m = !1;
                    h = this.instance.getSelector(h, e.selector);
                    for (var r = 0; r < h.length; r++) if (h[r] === g) {
                        m = !0;
                        break
                    }
                    if (!1 !== (b ? !m: m)) return e.def
                }
            }
        },
        {
            key: "_getDropEndpoint",
            value: function(a, e) {
                if (null == this.currentDropTarget.endpoint) {
                    var c = this.currentDropTarget.def;
                    var h = a.e.target || a.e.srcElement;
                    if (null == c) return null;
                    e = this.instance._deriveEndpointAndAnchorSpec(e.getType().join(" "), !0);
                    a = e.endpoints ? A(a, {
                        endpoint: c.def.endpoint || e.endpoints[1]
                    }) : a; (e = this.instance.validAnchorsSpec(e.anchors) ? e.anchors: this.instance.areDefaultAnchorsSet() ? this.instance.defaults.anchors: null) && (a = A(a, {
                        anchor: c.def.anchor || e[1]
                    }));
                    null != c.def.portId && (a.portId = c.def.portId);
                    h = c.def.parameterExtractor ? c.def.parameterExtractor(this.currentDropTarget.el, h) : {};
                    a = R(a, h);
                    a.element = this.currentDropTarget.targetEl;
                    h = this.instance._internal_newEndpoint(a);
                    h._mtNew = !0;
                    h.deleteOnEmpty = !0;
                    c.def.parameters && h.mergeParameters(c.def.parameters);
                    if (c.def.extract) {
                        a = {};
                        for (var b in c.def.extract)(e = this.currentDropTarget.el.getAttribute(b)) && (a[c.def.extract[b]] = e);
                        h.mergeParameters(a)
                    }
                } else h = this.currentDropTarget.endpoint;
                h && (h.removeClass(this.instance.endpointDropAllowedClass), h.removeClass(this.instance.endpointDropForbiddenClass));
                return h
            }
        },
        {
            key: "_doForceReattach",
            value: function(a) {
                this.floatingEndpoint.detachFromConnection(this.jpc, null, !0);
                this.jpc.endpoints[a] = this.jpc.suspendedEndpoint;
                this.instance.setHover(this.jpc, !1);
                this.jpc._forceDetach = !0;
                this.jpc.suspendedEndpoint.addConnection(this.jpc);
                this.instance.sourceOrTargetChanged(this.floatingId, this.jpc.suspendedEndpoint.elementId, this.jpc, this.jpc.suspendedEndpoint.element, a);
                this.instance.deleteEndpoint(this.floatingEndpoint);
                this.instance.repaint(this.jpc.source);
                delete this.jpc._forceDetach
            }
        },
        {
            key: "_shouldReattach",
            value: function(a) {
                return this.jpc.isReattach() || this.jpc._forceReattach || !wf(!0, !1, [[this.jpc.endpoints[0], "isDetachAllowed", [this.jpc]], [this.jpc.endpoints[1], "isDetachAllowed", [this.jpc]], [this.jpc, "isDetachAllowed", [this.jpc]], [this.instance, "checkCondition", ["beforeDetach", this.jpc]]])
            }
        },
        {
            key: "_discard",
            value: function(a, e) {
                this.jpc.pending ? this.instance.fire("connection:abort", this.jpc, e) : (0 === a ? (this.jpc.source = this.jpc.suspendedEndpoint.element, this.jpc.sourceId = this.jpc.suspendedEndpoint.elementId) : (this.jpc.target = this.jpc.suspendedEndpoint.element, this.jpc.targetId = this.jpc.suspendedEndpoint.elementId), this.jpc.endpoints[a] = this.jpc.suspendedEndpoint);
                this.floatingEndpoint && this.floatingEndpoint.detachFromConnection(this.jpc);
                this.instance.deleteConnection(this.jpc, {
                    originalEvent: e,
                    force: !0
                })
            }
        },
        {
            key: "_drop",
            value: function(a, e, c, h) {
                this.jpc.endpoints[e].detachFromConnection(this.jpc);
                this.jpc.suspendedEndpoint && this.jpc.suspendedEndpoint.detachFromConnection(this.jpc);
                this.jpc.endpoints[e] = a;
                a.addConnection(this.jpc);
                if (this.jpc.suspendedEndpoint) {
                    var b = this.jpc.suspendedEndpoint.elementId;
                    this.instance.fireMoveEvent({
                        index: e,
                        originalSourceId: 0 === e ? b: this.jpc.sourceId,
                        newSourceId: 0 === e ? a.elementId: this.jpc.sourceId,
                        originalTargetId: 1 === e ? b: this.jpc.targetId,
                        newTargetId: 1 === e ? a.elementId: this.jpc.targetId,
                        originalEndpoint: this.jpc.suspendedEndpoint,
                        connection: this.jpc,
                        newEndpoint: a
                    },
                    c)
                }
                1 === e ? this.instance.sourceOrTargetChanged(this.floatingId, this.jpc.targetId, this.jpc, this.jpc.target, 1) : this.instance.sourceOrTargetChanged(this.floatingId, this.jpc.sourceId, this.jpc, this.jpc.source, 0);
                this.jpc.endpoints[0].finalEndpoint && (this.jpc.endpoints[0].detachFromConnection(this.jpc), this.jpc.endpoints[0] = this.jpc.endpoints[0].finalEndpoint, this.jpc.endpoints[0].addConnection(this.jpc));
                V(h) && this.jpc.mergeData(h);
                this._originalAnchor && (this.jpc.endpoints[0].setAnchor(this._originalAnchor), this._originalAnchor = null);
                this.instance._finaliseConnection(this.jpc, null, c);
                this.instance.setHover(this.jpc, !1);
                this.instance.revalidate(this.jpc.endpoints[0].element)
            }
        },
        {
            key: "_registerFloatingConnection",
            value: function(a, e, c) {
                this.floatingConnections[a.id] = e;
                oe(this.instance.endpointsByElement, a.id, c)
            }
        },
        {
            key: "_getFloatingAnchorIndex",
            value: function() {
                return null == this.floatingIndex ? 1 : this.floatingIndex
            }
        }]);
        return k
    } (),
    Gi = function(k) {
        function a(c, h) {
            Sa(this, a);
            var b = e.call(this, c, h);
            b.instance = c;
            b.dragSelection = h;
            G(I(b), "selector", [">", vl, Ba].join(" "));
            G(I(b), "doRevalidate", void 0);
            b.doRevalidate = b._revalidate.bind(I(b));
            return b
        }
        Id(a, k);
        var e = Jd(a);
        Ta(a, [{
            key: "reset",
            value: function() {
                this.drag.off("revert", this.doRevalidate)
            }
        },
        {
            key: "_revalidate",
            value: function(c) {
                this.instance.revalidate(c)
            }
        },
        {
            key: "init",
            value: function(c) {
                this.drag = c;
                c.on("revert", this.doRevalidate)
            }
        },
        {
            key: "useGhostProxy",
            value: function(c, h) {
                c = h._jsPlumbParentGroup;
                return null == c ? !1 : !0 === c.ghost
            }
        },
        {
            key: "makeGhostProxy",
            value: function(c) {
                var h = c.cloneNode(!0);
                h._jsPlumbParentGroup = c._jsPlumbParentGroup;
                return h
            }
        }]);
        return a
    } (of),
    gb = function() {
        function k(a, e) {
            Sa(this, k);
            this.instance = a;
            this.overlay = e;
            G(this, "htmlElementOverlay", void 0);
            this.htmlElementOverlay = e
        }
        Ta(k, null, [{
            key: "createElement",
            value: function(a) {
                var e = Zc(null, "div", {},
                a.instance.overlayClass + " " + (a.cssClass ? a.cssClass: ""), void 0);
                a.instance.setAttribute(e, "jtk-overlay-id", a.id);
                return e
            }
        },
        {
            key: "getElement",
            value: function(a, e, c) {
                null == a.canvas && (a.canvas = c && e ? c(e) : k.createElement(a), a.canvas.style.position = "absolute", a.instance._appendElement(a.canvas, a.instance.getContainer()), a.instance.getId(a.canvas), a.canvas.style.webkitTransform = "translate(-50%, -50%)", a.canvas.style.mozTransform = "translate(-50%, -50%)", a.canvas.style.msTransform = "translate(-50%, -50%)", a.canvas.style.oTransform = "translate(-50%, -50%)", a.canvas.style.transform = "translate(-50%, -50%)", a.isVisible() || (a.canvas.style.display = "none"), a.canvas.jtk = {
                    overlay: a
                });
                return a.canvas
            }
        },
        {
            key: "destroy",
            value: function(a) {
                a.canvas && a.canvas.parentNode && a.canvas.parentNode.removeChild(a.canvas);
                delete a.canvas;
                delete a.cachedDimensions
            }
        },
        {
            key: "_getDimensions",
            value: function(a, e) {
                if (null == a.cachedDimensions || e) a.cachedDimensions = {
                    w: 1,
                    h: 1
                };
                return a.cachedDimensions
            }
        }]);
        return k
    } (),
    Mc = function(k) {
        function a() {
            Sa(this, a);
            var c = arguments.length;
            for (var h = Array(c), b = 0; b < c; b++) h[b] = arguments[b];
            c = e.call.apply(e, [this].concat(h));
            G(I(c), "path", void 0);
            return c
        }
        Id(a, k);
        var e = Jd(a);
        Ta(a, null, [{
            key: "ensurePath",
            value: function(c) {
                if (null == c.path) {
                    c.path = Ib("path", {
                        "jtk-overlay-id": c.id
                    });
                    var h = null;
                    c.component instanceof mc ? (h = c.component.connector, h = null != h ? h.canvas: null) : c.component instanceof Ud && (h = c.component.endpoint, h = null != h ? h.svg: h);
                    null != h && Kd(h, c.path, 1);
                    c.instance.addClass(c.path, c.instance.overlayClass);
                    c.path.jtk = {
                        overlay: c
                    }
                }
                return c.path
            }
        },
        {
            key: "paint",
            value: function(c, h, b, g) {
                this.ensurePath(c);
                var m = [0, 0];
                0 > g.xmin && (m[0] = -g.xmin);
                0 > g.ymin && (m[1] = -g.ymin);
                Hb(c.path, {
                    d: h,
                    stroke: b.stroke ? b.stroke: null,
                    fill: b.fill ? b.fill: null,
                    transform: "translate(" + m[0] + "," + m[1] + ")",
                    "pointer-events": "visibleStroke"
                })
            }
        },
        {
            key: "destroy",
            value: function(c, h) {
                null != c.path && null != c.path.parentNode && c.path.parentNode.removeChild(c.path);
                null != c.bgPath && null != c.bgPath.parentNode && c.bgPath.parentNode.removeChild(c.bgPath);
                delete c.path;
                delete c.bgPath
            }
        }]);
        return a
    } (Td),
    Hi = function() {
        function k() {
            Sa(this, k)
        }
        Ta(k, null, [{
            key: "paint",
            value: function(a, e, c, h) {
                if (null != c) {
                    var b = [a.x, a.y];
                    c = [a.w, a.h];
                    null != h && (0 > h.xmin && (b[0] += h.xmin), 0 > h.ymin && (b[1] += h.ymin), c[0] = h.xmax + (0 > h.xmin ? -h.xmin: 0), c[1] = h.ymax + (0 > h.ymin ? -h.ymin: 0));
                    isFinite(c[0]) && isFinite(c[1]) && (e ? (ug(a.canvas, b[0], b[1], c[0], c[1]), b[0] = 0, b[1] = 0, e = Ke([0, 0]), Hb(a.svg, {
                        style: e,
                        width: "" + (c[0] || 0),
                        height: "" + (c[1] || 0)
                    })) : (e = Ke([b[0], b[1]]), Hb(a.canvas, {
                        style: e,
                        width: "" + (c[0] || 0),
                        height: "" + (c[1] || 0)
                    })))
                }
            }
        }]);
        return k
    } (),
    Gl = function() {
        function k() {
            Sa(this, k)
        }
        Ta(k, null, [{
            key: "getEndpointElement",
            value: function(a) {
                if (null != a.canvas) return a.canvas;
                var e = Ib("svg", {
                    style: "",
                    width: "0",
                    height: "0",
                    "pointer-events": "none",
                    position: "absolute"
                });
                a.svg = e;
                var c = Zc(null, "div", {
                    position: "absolute"
                },
                void 0, void 0);
                a.canvas = c;
                var h = a.classes.join(" ");
                a.instance.addClass(c, h);
                h = a.endpoint.scope.split(/\s/);
                for (var b = 0; b < h.length; b++) a.instance.setAttribute(c, "data-jtk-scope-" + h[b], "true");
                a.instance._suspendDrawing || ug(c, 0, 0, 1, 1);
                a.instance._appendElement(c, a.instance.getContainer());
                c.appendChild(e);
                null != a.cssClass && a.instance.addClass(c, a.cssClass);
                a.instance.addClass(c, a.instance.endpointClass);
                c.jtk = c.jtk || {};
                c.jtk.endpoint = a.endpoint;
                c.style.display = !1 !== a.endpoint.visible ? "block": "none";
                return c
            }
        },
        {
            key: "paint",
            value: function(a, e, c) {
                this.getEndpointElement(a);
                Hi.paint(a, !0, c);
                c = A({},
                c);
                c.outlineStroke && (c.stroke = c.outlineStroke);
                null == a.node ? (a.node = e.makeNode(a, c), a.svg.appendChild(a.node)) : null != e.updateNode && e.updateNode(a, a.node);
                Le(a.canvas, a.node, c)
            }
        }]);
        return k
    } (),
    Bg = {},
    Rj = function(k) {
        function a(c, h) {
            Sa(this, a);
            var b = e.call(this, c, h);
            b._instanceIndex = c;
            G(I(b), "dragSelection", void 0);
            G(I(b), "dragManager", void 0);
            G(I(b), "_connectorClick", void 0);
            G(I(b), "_connectorDblClick", void 0);
            G(I(b), "_connectorTap", void 0);
            G(I(b), "_connectorDblTap", void 0);
            G(I(b), "_endpointClick", void 0);
            G(I(b), "_endpointDblClick", void 0);
            G(I(b), "_overlayClick", void 0);
            G(I(b), "_overlayDblClick", void 0);
            G(I(b), "_overlayTap", void 0);
            G(I(b), "_overlayDblTap", void 0);
            G(I(b), "_connectorMouseover", void 0);
            G(I(b), "_connectorMouseout", void 0);
            G(I(b), "_endpointMouseover", void 0);
            G(I(b), "_endpointMouseout", void 0);
            G(I(b), "_connectorContextmenu", void 0);
            G(I(b), "_connectorMousedown", void 0);
            G(I(b), "_connectorMouseup", void 0);
            G(I(b), "_endpointMousedown", void 0);
            G(I(b), "_endpointMouseup", void 0);
            G(I(b), "_overlayMouseover", void 0);
            G(I(b), "_overlayMouseout", void 0);
            G(I(b), "_elementClick", void 0);
            G(I(b), "_elementTap", void 0);
            G(I(b), "_elementDblTap", void 0);
            G(I(b), "_elementMouseenter", void 0);
            G(I(b), "_elementMouseexit", void 0);
            G(I(b), "_elementMousemove", void 0);
            G(I(b), "_elementMouseup", void 0);
            G(I(b), "_elementMousedown", void 0);
            G(I(b), "_elementContextmenu", void 0);
            G(I(b), "eventManager", void 0);
            G(I(b), "draggingClass", "jtk-dragging");
            G(I(b), "elementDraggingClass", "jtk-element-dragging");
            G(I(b), "hoverClass", "jtk-hover");
            G(I(b), "sourceElementDraggingClass", "jtk-source-element-dragging");
            G(I(b), "targetElementDraggingClass", "jtk-target-element-dragging");
            G(I(b), "hoverSourceClass", "jtk-source-hover");
            G(I(b), "hoverTargetClass", "jtk-target-hover");
            G(I(b), "dragSelectClass", "jtk-drag-select");
            G(I(b), "managedElementsSelector", void 0);
            G(I(b), "elementsDraggable", void 0);
            G(I(b), "elementDragHandler", void 0);
            G(I(b), "groupDragOptions", void 0);
            G(I(b), "elementDragOptions", void 0);
            G(I(b), "svg", {
                node: function(g, m) {
                    return Ib(g, m)
                },
                attr: function(g, m) {
                    return Hb(g, m)
                },
                pos: function(g) {
                    return Ke(g)
                }
            });
            b.elementsDraggable = h && !1 !== h.elementsDraggable;
            b.managedElementsSelector = h ? h.managedElementsSelector || Ba: Ba;
            b.eventManager = new $b;
            b.dragSelection = new Dl(I(b));
            b.dragManager = new El(I(b), b.dragSelection, h && h.dragOptions ? h.dragOptions: null);
            b.dragManager.addHandler(new Fi(I(b)));
            b.groupDragOptions = {
                constrainFunction: Pj
            };
            b.dragManager.addHandler(new Gi(I(b), b.dragSelection), b.groupDragOptions);
            b.elementDragHandler = new of(I(b), b.dragSelection);
            b.elementDragOptions = h && h.dragOptions || {};
            b.dragManager.addHandler(b.elementDragHandler, b.elementDragOptions);
            c = function(g, m) {
                if (!m.defaultPrevented) {
                    var r = sb(fb(m), tb, this.getContainer(), !0);
                    this.fire(g, r.jtk.connector.connection, m)
                }
            };
            b._connectorClick = c.bind(I(b), wi);
            b._connectorDblClick = c.bind(I(b), xi);
            b._connectorTap = c.bind(I(b), Ei);
            b._connectorDblTap = c.bind(I(b), yi);
            c = function(g, m) {
                var r = fb(m).parentNode;
                r.jtk && r.jtk.connector && (this.setConnectorHover(r.jtk.connector, g), this.fire(g ? Ai: zi, r.jtk.connector.connection, m))
            };
            b._connectorMouseover = c.bind(I(b), !0);
            b._connectorMouseout = c.bind(I(b), !1);
            c = function(g, m) {
                var r = fb(m).parentNode;
                r.jtk && r.jtk.connector && this.fire(g ? Bi: Ci, r.jtk.connector.connection, m)
            };
            b._connectorMouseup = c.bind(I(b), !0);
            b._connectorMousedown = c.bind(I(b), !1);
            b._connectorContextmenu = function(g) {
                var m = fb(g).parentNode;
                m.jtk && m.jtk.connector && this.fire(Di, m.jtk.connector.connection, g)
            }.bind(I(b));
            c = function(g, m, r) {
                m.defaultPrevented || this.fire(g, r.jtk.endpoint, m)
            };
            b._endpointClick = c.bind(I(b), ui);
            b._endpointDblClick = c.bind(I(b), vi);
            c = function(g, m) {
                var r = fb(m);
                r.jtk && r.jtk.endpoint && (this.setEndpointHover(r.jtk.endpoint, g), this.fire(g ? sl: rl, r.jtk.endpoint, m))
            };
            b._endpointMouseover = c.bind(I(b), !0);
            b._endpointMouseout = c.bind(I(b), !1);
            c = function(g, m) {
                var r = fb(m);
                r.jtk && r.jtk.endpoint && this.fire(g ? tl: ul, r.jtk.endpoint, m)
            };
            b._endpointMouseup = c.bind(I(b), !0);
            b._endpointMousedown = c.bind(I(b), !1);
            c = function(g, m) {
                Ha(m);
                var r = sb(fb(m), Lb, this.getContainer(), !0).jtk.overlay;
                r && this.fireOverlayMethod(r, g, m)
            }.bind(I(b));
            b._overlayClick = c.bind(I(b), "click");
            b._overlayDblClick = c.bind(I(b), "dblclick");
            b._overlayTap = c.bind(I(b), "tap");
            b._overlayDblTap = c.bind(I(b), "dbltap");
            c = function(g, m) { (m = sb(fb(m), Lb, this.getContainer(), !0).jtk.overlay) && this.setOverlayHover(m, g)
            };
            b._overlayMouseover = c.bind(I(b), !0);
            b._overlayMouseout = c.bind(I(b), !1);
            b._elementClick = function(g, m, r) {
                m.defaultPrevented || this.fire(1 === m.detail ? gf: ni, r, m)
            }.bind(I(b), gf);
            b._elementTap = function(g, m, r) {
                m.defaultPrevented || this.fire(jf, r, m)
            }.bind(I(b), jf);
            b._elementDblTap = function(g, m, r) {
                m.defaultPrevented || this.fire(hf, r, m)
            }.bind(I(b), hf);
            c = function(g, m) {
                this.fire(g ? pi: oi, fb(m), m)
            };
            b._elementMouseenter = c.bind(I(b), !0);
            b._elementMouseexit = c.bind(I(b), !1);
            b._elementMousemove = function(g) {
                this.fire(qi, fb(g), g)
            }.bind(I(b));
            b._elementMouseup = function(g) {
                this.fire(ri, fb(g), g)
            }.bind(I(b));
            b._elementMousedown = function(g) {
                this.fire(si, fb(g), g)
            }.bind(I(b));
            b._elementContextmenu = function(g) {
                this.fire(ti, fb(g), g)
            }.bind(I(b));
            b._attachEventDelegates();
            return b
        }
        Id(a, k);
        var e = Jd(a);
        Ta(a, [{
            key: "fireOverlayMethod",
            value: function(c, h, b) {
                var g = la(c.component instanceof mc ? "connection": "endpoint", h);
                c.fire(h, {
                    e: b,
                    overlay: c
                });
                this.fire(g, c.component, b)
            }
        },
        {
            key: "addDragFilter",
            value: function(c, h) {
                this.dragManager.addFilter(c, h)
            }
        },
        {
            key: "removeDragFilter",
            value: function(c) {
                this.dragManager.removeFilter(c)
            }
        },
        {
            key: "setDragGrid",
            value: function(c) {
                this.dragManager.setOption(this.elementDragHandler, {
                    grid: c
                })
            }
        },
        {
            key: "_removeElement",
            value: function(c) {
                c.parentNode && c.parentNode.removeChild(c)
            }
        },
        {
            key: "_appendElement",
            value: function(c, h) {
                h && h.appendChild(c)
            }
        },
        {
            key: "_getAssociatedElements",
            value: function(c) {
                var h = [];
                3 !== c.nodeType && 8 !== c.nodeType && (c = c.querySelectorAll(Ba), Array.prototype.push.apply(h, c));
                return h.filter(function(b) {
                    return 3 !== b.nodeType && 8 !== b.nodeType
                })
            }
        },
        {
            key: "shouldFireEvent",
            value: function(c, h, b) {
                return ! 0
            }
        },
        {
            key: "getClass",
            value: function(c) {
                return Je(c)
            }
        },
        {
            key: "addClass",
            value: function(c, h) {
                sa(c, h)
            }
        },
        {
            key: "hasClass",
            value: function(c, h) {
                c = c.classList ? c.classList.contains(h) : -1 !== Je(c).indexOf(h);
                return c
            }
        },
        {
            key: "removeClass",
            value: function(c, h) {
                ta(c, h)
            }
        },
        {
            key: "toggleClass",
            value: function(c, h) {
                Gj(c, h)
            }
        },
        {
            key: "setAttribute",
            value: function(c, h, b) {
                c.setAttribute(h, b)
            }
        },
        {
            key: "getAttribute",
            value: function(c, h) {
                return c.getAttribute(h)
            }
        },
        {
            key: "setAttributes",
            value: function(c, h) {
                for (var b in h) c.setAttribute(b, h[b])
            }
        },
        {
            key: "removeAttribute",
            value: function(c, h) {
                c.removeAttribute && c.removeAttribute(h)
            }
        },
        {
            key: "on",
            value: function(c, h, b, g) {
                var m = this,
                r = function(t) {
                    if (null == g) m.eventManager.on(t, h, b);
                    else m.eventManager.on(t, h, b, g)
                };
                hc(c) ? P(c,
                function(t) {
                    return r(t)
                }) : r(c);
                return this
            }
        },
        {
            key: "off",
            value: function(c, h, b) {
                var g = this;
                hc(c) ? P(c,
                function(m) {
                    return g.eventManager.off(m, h, b)
                }) : this.eventManager.off(c, h, b);
                return this
            }
        },
        {
            key: "trigger",
            value: function(c, h, b, g, m) {
                this.eventManager.trigger(c, h, b, g, m)
            }
        },
        {
            key: "getOffsetRelativeToRoot",
            value: function(c) {
                return sc(c)
            }
        },
        {
            key: "getOffset",
            value: function(c) {
                for (var h = this.getContainer(), b = {
                    x: c.offsetLeft,
                    y: c.offsetTop
                },
                g = c !== h && c.offsetParent !== h ? c.offsetParent: null; null != g;) {
                    b.x += g.offsetLeft;
                    b.y += g.offsetTop;
                    var m = g;
                    null != m && m !== document.body && (0 < m.scrollTop || 0 < m.scrollLeft) && (b.x -= m.scrollLeft, b.y -= m.scrollTop);
                    g = g.offsetParent === h ? null: g.offsetParent
                }
                null != h && (0 < h.scrollTop || 0 < h.scrollLeft) && (g = null != c.offsetParent ? this.getStyle(c.offsetParent, "position") : "static", c = this.getStyle(c, "position"), "absolute" !== c && "fixed" !== c && "absolute" !== g && "fixed" !== g && (b.x -= h.scrollLeft, b.y -= h.scrollTop));
                return b
            }
        },
        {
            key: "getSize",
            value: function(c) {
                return Ja(c)
            }
        },
        {
            key: "getStyle",
            value: function(c, h) {
                return "undefined" !== Yc(window.getComputedStyle) ? getComputedStyle(c, null).getPropertyValue(h) : c.currentStyle[h]
            }
        },
        {
            key: "getGroupContentArea",
            value: function(c) {
                var h = this.getSelector(c.el, wl);
                return h && 0 < h.length ? h[0] : c.el
            }
        },
        {
            key: "getSelector",
            value: function(c, h) {
                if (1 === arguments.length) {
                    if (!J(c)) {
                        var b = document.createDocumentFragment();
                        b.appendChild(c);
                        return td(b.childNodes)
                    }
                    b = td(document.querySelectorAll(c))
                } else b = td(c.querySelectorAll(h));
                return b
            }
        },
        {
            key: "setPosition",
            value: function(c, h) {
                c.style.left = h.x + "px";
                c.style.top = h.y + "px"
            }
        },
        {
            key: "setDraggable",
            value: function(c, h) {
                h ? this.removeAttribute(c, "data-jtk-not-draggable") : this.setAttribute(c, "data-jtk-not-draggable", "true")
            }
        },
        {
            key: "isDraggable",
            value: function(c) {
                c = this.getAttribute(c, "data-jtk-not-draggable");
                return null == c || "false" === c
            }
        },
        {
            key: "toggleDraggable",
            value: function(c) {
                var h = this.isDraggable(c);
                this.setDraggable(c, !h);
                return ! h
            }
        },
        {
            key: "_attachEventDelegates",
            value: function() {
                var c = this.getContainer();
                this.eventManager.on(c, "click", Lb, this._overlayClick);
                this.eventManager.on(c, "dblclick", Lb, this._overlayDblClick);
                this.eventManager.on(c, "tap", Lb, this._overlayTap);
                this.eventManager.on(c, "dbltap", Lb, this._overlayDblTap);
                this.eventManager.on(c, "click", tb, this._connectorClick);
                this.eventManager.on(c, "dblclick", tb, this._connectorDblClick);
                this.eventManager.on(c, "tap", tb, this._connectorTap);
                this.eventManager.on(c, "dbltap", tb, this._connectorDblTap);
                this.eventManager.on(c, "click", pc, this._endpointClick);
                this.eventManager.on(c, "dblclick", pc, this._endpointDblClick);
                this.eventManager.on(c, "click", this.managedElementsSelector, this._elementClick);
                this.eventManager.on(c, "tap", this.managedElementsSelector, this._elementTap);
                this.eventManager.on(c, "dbltap", this.managedElementsSelector, this._elementDblTap);
                this.eventManager.on(c, "mouseover", tb, this._connectorMouseover);
                this.eventManager.on(c, "mouseout", tb, this._connectorMouseout);
                this.eventManager.on(c, "contextmenu", tb, this._connectorContextmenu);
                this.eventManager.on(c, "mouseup", tb, this._connectorMouseup);
                this.eventManager.on(c, "mousedown", tb, this._connectorMousedown);
                this.eventManager.on(c, "mouseover", pc, this._endpointMouseover);
                this.eventManager.on(c, "mouseout", pc, this._endpointMouseout);
                this.eventManager.on(c, "mouseup", pc, this._endpointMouseup);
                this.eventManager.on(c, "mousedown", pc, this._endpointMousedown);
                this.eventManager.on(c, "mouseover", Lb, this._overlayMouseover);
                this.eventManager.on(c, "mouseout", Lb, this._overlayMouseout);
                this.eventManager.on(c, "mouseover", Ba, this._elementMouseenter);
                this.eventManager.on(c, "mouseout", Ba, this._elementMouseexit);
                this.eventManager.on(c, "mousemove", Ba, this._elementMousemove);
                this.eventManager.on(c, "mouseup", Ba, this._elementMouseup);
                this.eventManager.on(c, "mousedown", Ba, this._elementMousedown);
                this.eventManager.on(c, "contextmenu", Ba, this._elementContextmenu)
            }
        },
        {
            key: "_detachEventDelegates",
            value: function() {
                var c = this.getContainer();
                c && (this.eventManager.off(c, "click", this._connectorClick), this.eventManager.off(c, "dblclick", this._connectorDblClick), this.eventManager.off(c, "tap", this._connectorTap), this.eventManager.off(c, "dbltap", this._connectorDblTap), this.eventManager.off(c, "click", this._endpointClick), this.eventManager.off(c, "dblclick", this._endpointDblClick), this.eventManager.off(c, "click", this._overlayClick), this.eventManager.off(c, "dblclick", this._overlayDblClick), this.eventManager.off(c, "tap", this._overlayTap), this.eventManager.off(c, "dbltap", this._overlayDblTap), this.eventManager.off(c, "click", this._elementClick), this.eventManager.off(c, "tap", this._elementTap), this.eventManager.off(c, "dbltap", this._elementDblTap), this.eventManager.off(c, "mouseover", this._connectorMouseover), this.eventManager.off(c, "mouseout", this._connectorMouseout), this.eventManager.off(c, "contextmenu", this._connectorContextmenu), this.eventManager.off(c, "mouseup", this._connectorMouseup), this.eventManager.off(c, "mousedown", this._connectorMousedown), this.eventManager.off(c, "mouseover", this._endpointMouseover), this.eventManager.off(c, "mouseout", this._endpointMouseout), this.eventManager.off(c, "mouseup", this._endpointMouseup), this.eventManager.off(c, "mousedown", this._endpointMousedown), this.eventManager.off(c, "mouseover", this._overlayMouseover), this.eventManager.off(c, "mouseout", this._overlayMouseout), this.eventManager.off(c, "mouseenter", this._elementMouseenter), this.eventManager.off(c, "mouseexit", this._elementMouseexit), this.eventManager.off(c, "mousemove", this._elementMousemove), this.eventManager.off(c, "mouseup", this._elementMouseup), this.eventManager.off(c, "mousedown", this._elementMousedown), this.eventManager.off(c, "contextmenu", this._elementContextmenu))
            }
        },
        {
            key: "setContainer",
            value: function(c) {
                var h = this;
                if (c === document || c === document.body) throw Error("Cannot set document or document.body as container element");
                this._detachEventDelegates();
                var b;
                null != this.dragManager && (b = this.dragManager.reset());
                this.setAttribute(c, "data-jtk-container", fa().replace("-", ""));
                var g = this.getContainer();
                null != g && (g.removeAttribute("data-jtk-container"), g = td(g.childNodes).filter(function(m) {
                    return null != m && (h.hasClass(m, "jtk-connector") || h.hasClass(m, "jtk-endpoint") || h.hasClass(m, "jtk-overlay") || m.getAttribute && null != m.getAttribute("data-jtk-managed"))
                }), P(g,
                function(m) {
                    c.appendChild(m)
                }));
                Ab(eb(a.prototype), "setContainer", this).call(this, c);
                null != this.eventManager && this._attachEventDelegates();
                null != this.dragManager && (this.dragManager.addHandler(new Fi(this)), this.dragManager.addHandler(new Gi(this, this.dragSelection), this.groupDragOptions), this.elementDragHandler = new of(this, this.dragSelection), this.dragManager.addHandler(this.elementDragHandler, this.elementDragOptions), null != b && this.dragManager.setFilters(b))
            }
        },
        {
            key: "reset",
            value: function() {
                Ab(eb(a.prototype), "reset", this).call(this);
                var c = this.getContainer().querySelectorAll([Ba, pc, tb, Lb].join());
                P(c,
                function(h) {
                    return h.parentNode && h.parentNode.removeChild(h)
                })
            }
        },
        {
            key: "destroy",
            value: function() {
                this._detachEventDelegates();
                null != this.dragManager && this.dragManager.reset();
                this.clearDragSelection();
                Ab(eb(a.prototype), "destroy", this).call(this)
            }
        },
        {
            key: "unmanage",
            value: function(c, h) {
                this.removeFromDragSelection(c);
                Ab(eb(a.prototype), "unmanage", this).call(this, c, h)
            }
        },
        {
            key: "addToDragSelection",
            value: function() {
                for (var c = this,
                h = arguments.length,
                b = Array(h), g = 0; g < h; g++) b[g] = arguments[g];
                P(b,
                function(m) {
                    return c.dragSelection.add(m)
                })
            }
        },
        {
            key: "clearDragSelection",
            value: function() {
                this.dragSelection.clear()
            }
        },
        {
            key: "removeFromDragSelection",
            value: function() {
                for (var c = this,
                h = arguments.length,
                b = Array(h), g = 0; g < h; g++) b[g] = arguments[g];
                P(b,
                function(m) {
                    return c.dragSelection.remove(m)
                })
            }
        },
        {
            key: "toggleDragSelection",
            value: function() {
                for (var c = this,
                h = arguments.length,
                b = Array(h), g = 0; g < h; g++) b[g] = arguments[g];
                P(b,
                function(m) {
                    return c.dragSelection.toggle(m)
                })
            }
        },
        {
            key: "addToDragGroup",
            value: function(c) {
                for (var h, b = arguments.length,
                g = Array(1 < b ? b - 1 : 0), m = 1; m < b; m++) g[m - 1] = arguments[m]; (h = this.elementDragHandler).addToDragGroup.apply(h, [c].concat(g))
            }
        },
        {
            key: "removeFromDragGroup",
            value: function() {
                var c; (c = this.elementDragHandler).removeFromDragGroup.apply(c, arguments)
            }
        },
        {
            key: "setDragGroupState",
            value: function(c) {
                for (var h, b = arguments.length,
                g = Array(1 < b ? b - 1 : 0), m = 1; m < b; m++) g[m - 1] = arguments[m]; (h = this.elementDragHandler).setDragGroupState.apply(h, [c].concat(g))
            }
        },
        {
            key: "consume",
            value: function(c, h) {
                Ha(c, h)
            }
        },
        {
            key: "rotate",
            value: function(c, h, b) {
                var g = this.getId(c);
                return this._managedElements[g] ? (this._managedElements[g].el.style.transform = "rotate(" + h + "deg)", this._managedElements[g].el.style.transformOrigin = "center center", Ab(eb(a.prototype), "rotate", this).call(this, c, h, b)) : {
                    c: new Set,
                    e: new Set
                }
            }
        },
        {
            key: "addOverlayClass",
            value: function(c, h) {
                if (Ob(c)) c.instance.addClass(gb.getElement(c), h);
                else if (tc(c)) c.instance.addClass(Mc.ensurePath(c), h);
                else if (Rb(c)) c.instance.addClass(ic(c), h);
                else throw "Could not add class to overlay of type [" + c.type + "]";
            }
        },
        {
            key: "removeOverlayClass",
            value: function(c, h) {
                if (Ob(c)) c.instance.removeClass(gb.getElement(c), h);
                else if (tc(c)) c.instance.removeClass(Mc.ensurePath(c), h);
                else if (Rb(c)) c.instance.removeClass(ic(c), h);
                else throw "Could not remove class from overlay of type [" + c.type + "]";
            }
        },
        {
            key: "paintOverlay",
            value: function(c, h, b) {
                if (Ob(c)) gb.getElement(c),
                b = c.component.getXY(),
                c.canvas.style.left = b.x + h.d.minx + "px",
                c.canvas.style.top = b.y + h.d.miny + "px";
                else if (tc(c)) {
                    var g = isNaN(h.d.cxy.x) || isNaN(h.d.cxy.y) ? "M 0 0": "M" + h.d.hxy.x + "," + h.d.hxy.y + " L" + h.d.tail[0].x + "," + h.d.tail[0].y + " L" + h.d.cxy.x + "," + h.d.cxy.y + " L" + h.d.tail[1].x + "," + h.d.tail[1].y + " L" + h.d.hxy.x + "," + h.d.hxy.y;
                    Mc.paint(c, g, h, b)
                } else if (Rb(c)) ic(c),
                b = c.component.getXY(),
                c.canvas.style.left = b.x + h.d.minx + "px",
                c.canvas.style.top = b.y + h.d.miny + "px";
                else throw "Could not paint overlay of type [" + c.type + "]";
            }
        },
        {
            key: "setOverlayVisible",
            value: function(c, h) {
                function b(m) {
                    null != m && (m.style.display = g)
                }
                var g = h ? "block": "none";
                Ob(c) ? b(gb.getElement(c)) : Rb(c) ? b(ic(c)) : tc(c) && b(c.path)
            }
        },
        {
            key: "reattachOverlay",
            value: function(c, h) {
                Ob(c) ? c.instance._appendElement(gb.getElement(c), this.getContainer()) : Rb(c) ? c.instance._appendElement(ic(c), this.getContainer()) : tc(c) && this._appendElement(Mc.ensurePath(c), h.connector.canvas)
            }
        },
        {
            key: "setOverlayHover",
            value: function(c, h) {
                var b = h ? "addClass": "removeClass",
                g;
                Ob(c) ? g = gb.getElement(c) : Rb(c) ? g = ic(c) : tc(c) && (g = Mc.ensurePath(c));
                if (null != g) {
                    if (null != this.hoverClass) this[b](g, this.hoverClass);
                    this.setHover(c.component, h)
                }
            }
        },
        {
            key: "destroyOverlay",
            value: function(c) {
                if (Ob(c)) {
                    var h = gb.getElement(c);
                    h.parentNode.removeChild(h);
                    delete c.canvas;
                    delete c.cachedDimensions
                } else c.type === Kb.type || c.type === uc.type || c.type === dd.type ? Mc.destroy(c) : Rb(c) && (h = ic(c), h.parentNode.removeChild(h), delete c.canvas, delete c.cachedDimensions)
            }
        },
        {
            key: "drawOverlay",
            value: function(c, h, b, g) {
                if (Ob(c) || Rb(c)) {
                    b = gb._getDimensions(c);
                    if (null != b && null != b.w && null != b.h) {
                        if (g) h = {
                            x: g.x,
                            y: g.y
                        };
                        else if (h instanceof Ac) g = Array.isArray(c.location) ? c.location: [c.location, c.location],
                        h = {
                            x: g[0] * h.w,
                            y: g[1] * h.h
                        };
                        else {
                            g = c.location;
                            var m = !1;
                            if (J(c.location) || 0 > c.location || 1 < c.location) g = parseInt("" + c.location, 10),
                            m = !0;
                            h = h.pointOnPath(g, m)
                        }
                        g = h.x - b.w / 2;
                        m = h.y - b.h / 2;
                        return {
                            component: c,
                            d: {
                                minx: g,
                                miny: m,
                                td: b,
                                cxy: h
                            },
                            xmin: g,
                            xmax: g + b.w,
                            ymin: m,
                            ymax: m + b.h
                        }
                    }
                    return {
                        xmin: 0,
                        xmax: 0,
                        ymin: 0,
                        ymax: 0
                    }
                }
                if (c.type === Kb.type || c.type === uc.type || c.type === dd.type) return c.draw(h, b, g);
                throw "Could not draw overlay of type [" + c.type + "]";
            }
        },
        {
            key: "updateLabel",
            value: function(c) {
                if (Z(c.label)) {
                    var h = c.label(this);
                    null != h ? gb.getElement(c).innerText = h: gb.getElement(c).innerText = ""
                } else null == c.labelText && (c.labelText = c.label, null != c.labelText ? gb.getElement(c).innerText = c.labelText: gb.getElement(c).innerText = "")
            }
        },
        {
            key: "setHover",
            value: function(c, h) {
                c._hover = h;
                c instanceof Ud && null != c.endpoint ? this.setEndpointHover(c, h) : c instanceof mc && null != c.connector && this.setConnectorHover(c.connector, h)
            }
        },
        {
            key: "paintConnector",
            value: function(c, h, b) {
                if (null == c.canvas) {
                    var g = Ib("svg", {
                        style: "",
                        width: "0",
                        height: "0",
                        "pointer-events": "none",
                        position: "absolute"
                    });
                    c.canvas = g;
                    this._appendElement(c.canvas, this.getContainer());
                    null != c.cssClass && this.addClass(g, c.cssClass);
                    this.addClass(g, this.connectorClass);
                    g.jtk = g.jtk || {};
                    g.jtk.connector = c
                }
                Hi.paint(c, !1, h, b);
                g = [0, 0];
                0 > b.xmin && (g[0] = -b.xmin);
                0 > b.ymin && (g[1] = -b.ymin);
                if (0 < c.segments.length) {
                    b = this.getPathData(c);
                    b = {
                        d: b,
                        transform: "translate(" + g[0] + "," + g[1] + ")",
                        "pointer-events": "visibleStroke"
                    };
                    if (h.outlineStroke) {
                        var m = h.strokeWidth + 2 * (h.outlineWidth || 1);
                        g = A({},
                        h);
                        g.stroke = h.outlineStroke;
                        g.strokeWidth = m;
                        null == c.bgPath ? (c.bgPath = Ib("path", b), this.addClass(c.bgPath, this.connectorOutlineClass), Kd(c.canvas, c.bgPath, 0)) : Hb(c.bgPath, b);
                        Le(c.canvas, c.bgPath, g)
                    }
                    null == c.path ? (c.path = Ib("path", b), Kd(c.canvas, c.path, h.outlineStroke ? 1 : 0)) : (c.path.parentNode !== c.canvas && Kd(c.canvas, c.path, h.outlineStroke ? 1 : 0), Hb(c.path, b));
                    Le(c.canvas, c.path, h)
                }
            }
        },
        {
            key: "setConnectorHover",
            value: function(c, h, b) {
                if (!1 === h || !this.currentlyDragging && !this.isHoverSuspended()) {
                    var g = h ? "addClass": "removeClass",
                    m = c.canvas;
                    if (null != m) {
                        if (null != c.hoverClass) this[g](m, c.hoverClass);
                        this[g](m, this.hoverClass)
                    }
                    null != c.connection.hoverPaintStyle && (c.connection.paintStyleInUse = h ? c.connection.hoverPaintStyle: c.connection.paintStyle, this._suspendDrawing || this.paintConnection(c.connection));
                    b || (this.setEndpointHover(c.connection.endpoints[0], h, !0), this.setEndpointHover(c.connection.endpoints[1], h, !0))
                }
            }
        },
        {
            key: "destroyConnector",
            value: function(c) {
                null != c.connector && Cg(c.connector)
            }
        },
        {
            key: "addConnectorClass",
            value: function(c, h) {
                c.canvas && this.addClass(c.canvas, h)
            }
        },
        {
            key: "removeConnectorClass",
            value: function(c, h) {
                c.canvas && this.removeClass(c.canvas, h)
            }
        },
        {
            key: "getConnectorClass",
            value: function(c) {
                return c.canvas ? c.canvas.className.baseVal: ""
            }
        },
        {
            key: "setConnectorVisible",
            value: function(c, h) {
                c.canvas && (c.canvas.style.display = h ? "block": "none")
            }
        },
        {
            key: "applyConnectorType",
            value: function(c, h) {
                c.canvas && h.cssClass && (h = Array.isArray(h.cssClass) ? h.cssClass: [h.cssClass], this.addClass(c.canvas, h.join(" ")))
            }
        },
        {
            key: "addEndpointClass",
            value: function(c, h) {
                c = c.endpoint.canvas;
                null != c && this.addClass(c, h)
            }
        },
        {
            key: "applyEndpointType",
            value: function(c, h) {
                h.cssClass && (c = c.endpoint.canvas) && (h = Array.isArray(h.cssClass) ? h.cssClass: [h.cssClass], this.addClass(c, h.join(" ")))
            }
        },
        {
            key: "destroyEndpoint",
            value: function(c) {
                this.removeClass(c.element, this.endpointAnchorClassPrefix + (c.currentAnchorClass ? "-" + c.currentAnchorClass: ""));
                Cg(c.endpoint)
            }
        },
        {
            key: "renderEndpoint",
            value: function(c, h) {
                var b = Bg[c.endpoint.type];
                null != b ? Gl.paint(c.endpoint, b, h) : pa("jsPlumb: no endpoint renderer found for type [" + c.endpoint.type + "]")
            }
        },
        {
            key: "removeEndpointClass",
            value: function(c, h) {
                c = c.endpoint.canvas;
                null != c && this.removeClass(c, h)
            }
        },
        {
            key: "getEndpointClass",
            value: function(c) {
                c = c.endpoint.canvas;
                return null != c ? c.className: ""
            }
        },
        {
            key: "setEndpointHover",
            value: function(c, h, b) {
                if (null != c && (!1 === h || !this.currentlyDragging && !this.isHoverSuspended())) {
                    var g = h ? "addClass": "removeClass",
                    m = c.endpoint.canvas;
                    if (null != m && null != c.hoverClass) this[g](m, c.hoverClass);
                    null != c.hoverPaintStyle && (c.paintStyleInUse = h ? c.hoverPaintStyle: c.paintStyle, this._suspendDrawing || this.renderEndpoint(c, c.paintStyleInUse));
                    if (!b) for (b = 0; b < c.connections.length; b++) this.setConnectorHover(c.connections[b].connector, h, !0)
                }
            }
        },
        {
            key: "setEndpointVisible",
            value: function(c, h) {
                c = c.endpoint;
                c.canvas && (c.canvas.style.display = h ? "block": "none")
            }
        },
        {
            key: "setGroupVisible",
            value: function(c, h) {
                c = c.el.querySelectorAll(Ba);
                for (var b = 0; b < c.length; b++) h ? this.show(c[b], !0) : this.hide(c[b], !0)
            }
        },
        {
            key: "deleteConnection",
            value: function(c, h) {
                return null != c && !0 !== c.deleted ? (this.setEndpointHover(c.endpoints[0], !1, !0), this.setEndpointHover(c.endpoints[1], !1, !0), Ab(eb(a.prototype), "deleteConnection", this).call(this, c, h)) : !1
            }
        },
        {
            key: "addSourceSelector",
            value: function(c, h, b) {
                this.addDragFilter(c);
                return Ab(eb(a.prototype), "addSourceSelector", this).call(this, c, h, b)
            }
        },
        {
            key: "removeSourceSelector",
            value: function(c) {
                this.removeDragFilter(c.selector);
                Ab(eb(a.prototype), "removeSourceSelector", this).call(this, c)
            }
        }]);
        return a
    } (Kk),
    Ii = {
        width: 10,
        height: 0,
        fill: "transparent",
        stroke: "transparent"
    }; (function() {
        Oe(Bc.type, {
            makeNode: function(k, a) {
                return Ib("circle", {
                    cx: k.w / 2,
                    cy: k.h / 2,
                    r: k.radius
                })
            },
            updateNode: function(k, a) {
                Hb(a, {
                    cx: "" + k.w / 2,
                    cy: "" + k.h / 2,
                    r: "" + k.radius
                })
            }
        })
    })(); (function() {
        Oe(nd.type, {
            makeNode: function(k, a) {
                return Ib("rect", Ii)
            },
            updateNode: function(k, a) {
                Hb(a, Ii)
            }
        })
    })(); (function() {
        Oe(Rd.type, {
            makeNode: function(k, a) {
                return Ib("rect", {
                    width: k.w,
                    height: k.h
                })
            },
            updateNode: function(k, a) {
                Hb(a, {
                    width: k.w,
                    height: k.h
                })
            }
        })
    })();
    var Dg = 0,
    Ka = {
        POSITION: "data-position",
        AXIS: "data-axis",
        JTK_CANCEL: "jtk-cancel",
        JTK_COMMIT: "jtk-commit",
        MULTIPLE: "multiple",
        JTK: "jtk-att",
        TITLE: "title",
        FOCUS: "jtk-focus",
        TYPE: "type",
        CANCEL: "cancel",
        ID: "id"
    },
    $a = {
        RESIZE: "resize",
        CLICK: "click",
        KEYUP: "keyup",
        SCROLL: "scroll"
    },
    Tj = {
        TEXT: function(k, a) {
            k.value = a
        },
        RADIO: function(k, a) {
            k.checked = k.value == a
        },
        CHECKBOX: function(k, a) {
            k.checked = 1 == a
        },
        SELECT: function(k, a) {
            for (var e = k.getAttribute(Ka.MULTIPLE), c = 0; c < k.options.length; c++) if (e) - 1 < a.indexOf(k.options[c].value) && (k.options[c].selected = !0);
            else if (k.options[c].value === a) return void(k.selectedIndex = c)
        },
        TEXTAREA: function(k, a) {
            k.value = a
        },
        COLOR: function(k, a) {
            k.value = a
        },
        HIDDEN: function(k, a) {
            k.value = a
        }
    },
    Uj = {
        TEXT: function(k) {
            return k.value
        },
        RADIO: function(k) {
            if (k.checked) return k.value
        },
        CHECKBOX: function(k) {
            if (k.checked) return ! 0
        },
        SELECT: function(k) {
            var a = k.selectedOptions;
            if (k.getAttribute(Ka.MULTIPLE)) {
                k = [];
                for (var e = 0; e < a.length; e++) k.push(a[e].value);
                return k
            }
            return - 1 !== k.selectedIndex ? k.options[k.selectedIndex].value: null
        },
        TEXTAREA: function(k) {
            return k.value
        },
        COLOR: function(k) {
            return k.value
        },
        HIDDEN: function(k) {
            return k.value
        }
    },
    Hl = {
        TEXT: function(k) {
            k.value = ""
        },
        RADIO: function(k) {
            k.checked = !1
        },
        CHECKBOX: function(k) {
            k.checked = !1
        },
        SELECT: function(k) {
            k.selectedIndex = -1
        },
        TEXTAREA: function(k) {
            k.value = ""
        },
        COLOR: function(k) {
            k.value = ""
        },
        HIDDEN: function(k) {
            k.value = ""
        }
    },
    Nc = function(k, a, e) {
        try {
            null != k && k.apply(k, Array.prototype.slice.apply(arguments, [1]))
        } catch(c) {}
    },
    Il = function() {
        function k(a) {
            var e = this;
            if (! (this instanceof k)) throw new TypeError("Cannot call a class as a function");
            if (va(this, "eventManager", void 0), va(this, "cache", void 0), va(this, "current", void 0), va(this, "underlay", void 0), va(this, "overlay", void 0), va(this, "title", void 0), va(this, "content", void 0), va(this, "buttons", void 0), va(this, "onOK", void 0), va(this, "onCancel", void 0), va(this, "onOpen", void 0), va(this, "onMaybeClose", void 0), va(this, "onClose", void 0), va(this, "btnOk", void 0), va(this, "btnCancel", void 0), va(this, "labels", {
                ok: "OK",
                cancel: "Cancel"
            }), va(this, "container", document.body), va(this, "visible", !1), va(this, "_rotors", void 0), va(this, "globals", {}), va(this, "reposition", !0), va(this, "templates", {}), va(this, "_positioners", {
                x: function(g, m, r) {
                    r = (e.container.clientWidth - r.w) / 2;
                    g = window.pageXOffset || g.scrollLeft || document.body.scrollLeft;
                    0 > r && (r = 10);
                    g = m ? g: e.container.scrollLeft;
                    e.overlay.style.left = r + g + "px"
                },
                y: function(g, m, r) {
                    r = .1 * e.container.clientHeight;
                    g = window.pageYOffset || g.scrollTop || document.body.scrollTop;
                    0 > r && (r = 10);
                    g = m ? g: e.container.scrollTop;
                    e.overlay.style.top = r + g + "px"
                }
            }), a = a || {},
            this.cache = {},
            this.eventManager = new $b, this._rotors = new mi({
                templateResolver: function(g) {
                    return e.templates[g] || document.getElementById(g).innerHTML
                }
            },
            function(g, m) {
                return null
            },
            function(g) {
                return null
            }), a.dialogs) for (var c in a.dialogs) this.templates[c] = a.dialogs[c].template,
            this.cache[c] = {
                content: this.templates[c],
                title: a.dialogs[c].title || "",
                cancelable: !1 !== a.dialogs[c].cancelable
            };
            else {
                c = a.selector || Eb("jtk-dialog");
                c = document.querySelectorAll(c);
                for (var h = 0; h < c.length; h++) {
                    var b = c[h].getAttribute(Ka.ID);
                    null != b && (this.cache[b] = {
                        content: c[h].innerHTML,
                        title: c[h].getAttribute(Ka.TITLE) || "",
                        el: c[h],
                        cancelable: "false" !== c[h].getAttribute(Ka.CANCEL)
                    })
                }
            }
            a.labels && A(this.labels, a.labels);
            a.globals && A(this.globals, a.globals);
            this.underlay = document.createElement("div");
            this.underlay.className = "jtk-dialog-underlay";
            this.eventManager.on(this.underlay, $a.CLICK,
            function() {
                e._close(!0)
            });
            this.overlay = document.createElement("div");
            this.overlay.className = "jtk-dialog-overlay";
            this.title = document.createElement("div");
            this.title.className = "jtk-dialog-title";
            this.overlay.appendChild(this.title);
            this.content = document.createElement("div");
            this.content.className = "jtk-dialog-content";
            this.overlay.appendChild(this.content);
            this.buttons = document.createElement("div");
            this.buttons.className = "jtk-dialog-buttons";
            this.overlay.appendChild(this.buttons)
        }
        return Sj(k, [{
            key: "_positionOverlay",
            value: function() {
                if (this.visible) {
                    var a = document.documentElement,
                    e = Ja(this.overlay),
                    c = this.container == document.body,
                    h = this.overlay.getAttribute(Ka.AXIS);
                    this.underlay.style.position = c ? "fixed": "absolute";
                    this._positioners[h](a, c, e)
                }
            }
        },
        {
            key: "_resolveContainer",
            value: function(a) {
                return null == a ? document.body: "string" == typeof a ? document.getElementById(a) : a
            }
        },
        {
            key: "_setCurrent",
            value: function(a) {
                var e, c = this;
                if (a.id && this.cache[a.id]) {
                    this.reposition = !1 !== a.reposition;
                    this.onOK = a.onOK;
                    this.onCancel = a.onCancel;
                    this.onOpen = a.onOpen;
                    this.onMaybeClose = a.onMaybeClose;
                    this.onClose = a.onClose;
                    var h = a.position || "top",
                    b = ["jtk-dialog-overlay", h].join("-"),
                    g = "top" === h || "bottom" === h ? "x": "y",
                    m = ["jtk-dialog-overlay", g].join("-");
                    this._createButtons(a);
                    this.container = this._resolveContainer(a.container);
                    var r = a.data || {},
                    t = this._rotors.template(a.id, r);
                    this.title.innerHTML = a.title || this.cache[a.id].title || "";
                    this.content.innerHTML = "";
                    var u = t.childNodes.length;
                    for (e = 0; e < u; e++) this.content.appendChild(t.childNodes[0]);
                    this.container.appendChild(this.underlay);
                    this.container.appendChild(this.overlay);
                    sa(this.overlay, b);
                    sa(this.overlay, m);
                    this.underlay.style.display = "block";
                    this.overlay.style.display = "block";
                    this.overlay.setAttribute(Ka.POSITION, h);
                    this.overlay.setAttribute(Ka.AXIS, g);
                    a = this.cache[a.id].cancelable ? "visible": "hidden";
                    h = this.buttons.querySelectorAll("[jtk-cancel='true']");
                    for (e = 0; e < h.length; e++) h[e].style.visibility = a;
                    this.visible = !0;
                    this._positionOverlay();
                    Fg(r, this.content, !0, this);
                    this.eventManager.on(document, $a.KEYUP, this.keyListener);
                    this.reposition && (this.eventManager.on(window, $a.RESIZE, this._positionOverlay), this.eventManager.on(window, $a.SCROLL, this._positionOverlay));
                    this.eventManager.on(this.overlay, $a.CLICK, "[jtk-clear]",
                    function(w) { (w = c.overlay.getAttribute("jtk-att")) && c.clear(c.overlay.querySelectorAll("[jtk-att='" + w + "']:not([jtk-clear])"), c)
                    });
                    this.eventManager.on(this.overlay, $a.CLICK, "[jtk-clear-all]",
                    function(w) {
                        c.clear(c.overlay.querySelectorAll("[jtk-att]:not([jtk-clear])"), c)
                    });
                    this.globals.onOpen && this.globals.onOpen(this.overlay);
                    this.onOpen && this.onOpen(this.overlay);
                    sa(this.overlay, "jtk-dialog-overlay-visible");
                    try {
                        var v = this.content.querySelector("[jtk-focus]");
                        v && setTimeout(function() {
                            v.focus()
                        },
                        0)
                    } catch(w) {}
                }
            }
        },
        {
            key: "keyListener",
            value: function(a) {
                27 == a.keyCode && this._close(!0)
            }
        },
        {
            key: "_createButtons",
            value: function(a) {
                var e = this;
                if (this.buttons.innerHTML = "", a.buttons) for (var c, h = 0; h < a.buttons.length; h++) c = a.buttons[h],
                this.buttons.appendChild(c),
                "true" === c.getAttribute(Ka.JTK_COMMIT) ? this.eventManager.on(c, $a.CLICK,
                function() {
                    e._close()
                }) : "true" === c.getAttribute(Ka.JTK_CANCEL) && this.eventManager.on(c, $a.CLICK,
                function() {
                    e._close(!0)
                });
                else this.btnOk = document.createElement("button"),
                this.btnOk.className = ue("jtk-dialog-button", "jtk-dialog-button-ok"),
                this.btnOk.innerHTML = this.labels.ok,
                this.buttons.appendChild(this.btnOk),
                this.eventManager.on(this.btnOk, $a.CLICK,
                function() {
                    e._close()
                }),
                this.btnCancel = document.createElement("button"),
                this.btnCancel.className = ue("jtk-dialog-button", "jtk-dialog-button-cancel"),
                this.btnCancel.innerHTML = this.labels.cancel,
                this.btnCancel.setAttribute(Ka.JTK_CANCEL, "true"),
                this.buttons.appendChild(this.btnCancel),
                this.eventManager.on(this.btnCancel, $a.CLICK,
                function() {
                    e._close(!0)
                }),
                this.btnOk.innerHTML = a.labels && a.labels.ok || this.labels.ok,
                this.btnCancel.innerHTML = a.labels && a.labels.cancel || this.labels.cancel
            }
        },
        {
            key: "_cleanupButtons",
            value: function() {
                for (var a = this.buttons.children,
                e = 0; e < a.length; e++) a[e].parentNode.removeChild(a[e])
            }
        },
        {
            key: "show",
            value: function(a) {
                this._setCurrent(a)
            }
        },
        {
            key: "hide",
            value: function() {
                this._close(!0)
            }
        },
        {
            key: "clear",
            value: function(a, e) {
                for (var c = 0; c < a.length; c++) if (a[c] !== e) {
                    var h = a[c].tagName.toUpperCase();
                    h = "INPUT" === h ? (a[c].getAttribute(Ka.TYPE) || "TEXT").toUpperCase() : h; (h = Hl[h]) && h(a[c])
                }
            }
        },
        {
            key: "apply",
            value: function(a, e) {
                Fg(a, e, !1, this)
            }
        },
        {
            key: "extract",
            value: function(a) {
                return Gg(a, this._rotors)
            }
        },
        {
            key: "_close",
            value: function(a) {
                var e = a ? null: Gg(this.content, this._rotors); (a || null == this.onMaybeClose || !1 !== this.onMaybeClose(e)) && (this.visible = !1, this.underlay.style.display = "none", this.overlay.style.display = "none", this.eventManager.off(document, $a.KEYUP, this.keyListener), this.eventManager.off(window, $a.RESIZE, this._positionOverlay), this.eventManager.off(window, $a.SCROLL, this._positionOverlay), ta(this.overlay, "jtk-dialog-overlay-visible"), ta(this.overlay, "jtk-dialog-overlay-top"), ta(this.overlay, "jtk-dialog-overlay-bottom"), ta(this.overlay, "jtk-dialog-overlay-left"), ta(this.overlay, "jtk-dialog-overlay-right"), ta(this.overlay, "jtk-dialog-overlay-x"), ta(this.overlay, "jtk-dialog-overlay-y"), this.overlay.setAttribute(Ka.POSITION, ""), this.overlay.setAttribute(Ka.AXIS, ""), this.container.removeChild(this.underlay), this.container.removeChild(this.overlay), this._cleanupButtons(), a ? (Nc(this.globals.onCancel, this.content), Nc(this.onCancel, this.content)) : (Nc(this.globals.onOK, e, this.content), Nc(this.onOK, e, this.content)), Nc(this.globals.onClose), Nc(this.onClose), this.onOK = this.onCancel = this.onOpen = this.onClose = this.onMaybeClose = this.current = null)
            }
        }]),
        k
    } ();
    var Ji = {},
    ak = {
        get: function(k, a, e, c) {
            var h = Ji[k];
            if (h) return new h(a, e, c);
            throw {
                message: "jsPlumb: unknown decorator type '" + k + "'"
            };
        },
        register: function(k, a) {
            Ji[k] = a
        }
    },
    pf = {
        webkit: {
            mac: vc("deltaY", 120),
            win: vc("deltaY", 100)
        },
        safari: vc("wheelDeltaY", 120, !0),
        firefox: {
            mac: Mg,
            win: Mg
        },
        ie: function(k) {
            return k.wheelDelta / 120
        },
    default:
        function(k) {
            return k.deltaY || k.wheelDelta
        }
    },
    qf = {
        webkit: {
            mac: vc("deltaX", 120),
            win: vc("deltaX", 100)
        },
        safari: vc("wheelDeltaX", 120, !0),
        firefox: {
            mac: Ng,
            win: Ng
        },
        ie: function(k) {
            return k.wheelDelta / 120
        },
    default:
        function(k) {
            return k.deltaX || k.wheelDelta
        }
    },
    Ki = "undefined" != typeof navigator,
    Li = Ki ? /Mac/.test(navigator.userAgent) ? "mac": "win": "mac",
    Oc = Ki ? -1 !== navigator.userAgent.indexOf("Firefox") ? "firefox": /Chrome/.test(navigator.userAgent) ? "webkit": /Safari/.test(navigator.userAgent) ? "safari": /WebKit/.test(navigator.userAgent) ? "webkit": /Trident/.test(navigator.userAgent) ? "ie": "default": "default",
    Jl = "function" == typeof pf[Oc] ? pf[Oc] : pf[Oc][Li],
    Kl = "function" == typeof qf[Oc] ? qf[Oc] : qf[Oc][Li],
    Wj = function(k, a, e) {
        var c = function(h) {
            if (!a || null == h.mozInputSource || 1 === h.mozInputSource) {
                var b = Jl(h || event),
                g = Kl(h || event);
                h.normalizedWheelDelta = b; (!e || h.metaKey || h.ctrlKey) && k(h, g, b, h.metaKey || h.ctrlKey)
            }
        };
        return k._jtkwl = c,
        c
    },
    Pg = "onwheel" in document.createElement("div") ? "wheel": void 0 !== document.onmousewheel ? "mousewheel": "DOMMouseScroll",
    Mi = function() {
        function k(a) {
            Aa(this, k);
            this.el = a
        }
        return Ia(k, [{
            key: "value",
            value: function(a, e) {
                a = this.el.getAttribute(a);
                return null == a ? e: a
            }
        },
        {
            key: "findDataValues",
            value: function(a) {
                for (var e = 0; e < this.el.attributes.length; e++) {
                    var c = this.el.attributes[e];
                    0 === c.name.indexOf("data-") && (a[c.value] = c.name.split("-")[1])
                }
            }
        }]),
        k
    } (),
    Ll = function() {
        function k(a, e) {
            Aa(this, k);
            this.obj = a;
            D(this, "stripPrefix", void 0);
            this.stripPrefix = e || ""
        }
        return Ia(k, [{
            key: "value",
            value: function(a, e) {
                a = this.obj[a.replace(this.stripPrefix, "").replace(/(\-\w)/g,
                function(c) {
                    return c[1].toUpperCase()
                })];
                return null == a ? e: a
            }
        },
        {
            key: "findDataValues",
            value: function(a) {
                for (var e in this.obj) 0 === e.indexOf("data-") && (a[this.obj[e]] = e.split("-")[1])
            }
        }]),
        k
    } (),
    Ml = function() {
        function k(a, e, c) {
            Aa(this, k);
            D(this, "scaledImageSize", void 0);
            D(this, "scaledImageSizeH", void 0);
            D(this, "container", void 0);
            D(this, "zoom", void 0);
            D(this, "specs", void 0);
            D(this, "url", void 0);
            D(this, "urlGenerator", void 0);
            D(this, "apparentZoom", void 0);
            D(this, "xTiles", void 0);
            D(this, "yTiles", void 0);
            D(this, "_images", []);
            var h = Math.pow(2, e.options.maxZoom - c) * e.options.tileSize.h;
            this.scaledImageSize = Math.pow(2, e.options.maxZoom - c) * e.options.tileSize.w;
            this.scaledImageSizeH = h;
            this.container = document.createElement("div");
            this.container.style.position = "relative";
            this.container.style.height = "100%";
            this.container.style.width = "100%";
            this.container.style.display = "none";
            e.canvas.appendChild(this.container);
            this.zoom = c;
            this.specs = a.getTileSpecs(c);
            this.url = e.url;
            this.urlGenerator = a.urlGenerator;
            this.apparentZoom = Math.min(this.specs[2], this.specs[3]);
            this.xTiles = this.specs[0];
            this.yTiles = this.specs[1];
            for (a = 0; a < this.xTiles; a++) for (this._images[a] = this._images[a] || [], e = 0; e < this.yTiles; e++) c = document.createElement("img"),
            c._tiledBg = !0,
            c.className = "jtk-surface-tile",
            c.ondragstart = function() {
                return ! 1
            },
            this.container.appendChild(c),
            c.style.position = "absolute",
            c.style.opacity = 0,
            this._images[a][e] = [c, new Image, !1]
        }
        return Ia(k, [{
            key: "_url",
            value: function(a, e, c) {
                return this.url.replace("{z}", a + "").replace("{x}", e + "").replace("{y}", c + "")
            }
        },
        {
            key: "_resolver",
            value: function(a, e, c) {
                return null == this.urlGenerator ? this._url(a, e, c) : this.urlGenerator(a, e, c)
            }
        },
        {
            key: "setActive",
            value: function(a) {
                this.container.style.display = a ? "block": "none"
            }
        },
        {
            key: "_load",
            value: function(a, e, c, h) {
                a.style.left = c * this.scaledImageSize + "px";
                a.style.top = h * this.scaledImageSizeH + "px";
                a.style.width = this.scaledImageSize + "px";
                a.style.height = this.scaledImageSizeH + "px";
                e.onload = function() {
                    a.setAttribute("src", e.src);
                    a.style.opacity = 1
                };
                e.src = this._resolver(this.zoom, c, h)
            }
        },
        {
            key: "ensureLoaded",
            value: function(a, e, c, h) {
                for (; a <= c; a++) for (var b = e; b <= h; b++) null != this._images[a] && null != this._images[a][b] && (this._images[a][b][2] || (this._load(this._images[a][b][0], this._images[a][b][1], a, b), this._images[a][b][2] = !0))
            }
        }]),
        k
    } (),
    Ni = function() {
        function k(a) {
            if (Aa(this, k), D(this, "canvas", void 0), D(this, "viewport", void 0), D(this, "layers", []), D(this, "currentLayer", void 0), D(this, "widgetZoom", void 0), D(this, "zoomWidget", void 0), D(this, "getWidthOf", void 0), D(this, "getHeightOf", void 0), D(this, "width", void 0), D(this, "height", void 0), D(this, "tileSize", void 0), D(this, "panDebounceTimeout", void 0), D(this, "zoomDebounceTimeout", void 0), D(this, "maxZoom", void 0), D(this, "urlGenerator", void 0), D(this, "_debounceUpdateZoom", void 0), D(this, "_doEnsureVisibleTiles", void 0), null == a.options.maxZoom) throw Error("Parameter `maxZoom` not set; cannot initialize TiledBackground");
            if (!a.options.tileSize) throw Error("Parameter `tileSize not set; cannot initialize TiledBackground. It should be in the form {w:width, h:height}.");
            if (!a.options.width || !a.options.height) throw Error("Parameters `width` and `height` must be set");
            this.canvas = a.canvas;
            this.viewport = a.viewport;
            this.urlGenerator = a.options.urlGenerator;
            for (var e = 0; e <= a.options.maxZoom; e++) this.layers.push(new Ml(this, a, e));
            this.width = a.options.width;
            this.height = a.options.height;
            this.maxZoom = a.options.maxZoom;
            this.panDebounceTimeout = a.options.panDebounceTimeout || 50;
            this.zoomDebounceTimeout = a.options.zoomDebounceTimeout || 120;
            this.canvas.style.width = this.width + "px";
            this.canvas.style.height = this.height + "px";
            this.zoomWidget = a.zoomWidget;
            this.getWidthOf = a.getWidth;
            this.getHeightOf = a.getHeight;
            this._debounceUpdateZoom = this.debounce(this._doUpdateZoom, this.zoomDebounceTimeout);
            this._doEnsureVisibleTiles = this.debounce(this._ensureVisibleTiles, this.panDebounceTimeout);
            this.setZoom(a.zoomWidget.getZoom(), !0);
            null != a.onBackgroundReady && setTimeout(a.onBackgroundReady, 0)
        }
        return Ia(k, [{
            key: "_mapZoomToLayer",
            value: function() {
                if (this.widgetZoom <= this.layers[0].apparentZoom) return 0;
                if (this.widgetZoom >= this.layers[this.layers.length - 1].apparentZoom) return this.layers.length - 1;
                for (var a = this.layers.length - 1; 0 < a; a--) if (this.layers[a].apparentZoom >= this.widgetZoom && this.widgetZoom >= this.layers[a - 1].apparentZoom) return a
            }
        },
        {
            key: "_calculateScale",
            value: function(a) {
                a = this.layers[a];
                null != this.currentLayer && this.currentLayer !== a && this.currentLayer.setActive(!1);
                a.setActive(!0);
                this.currentLayer = a
            }
        },
        {
            key: "_ensureVisibleTiles",
            value: function() {
                var a = this.zoomWidget.getApparentCanvasLocation(),
                e = this.getWidthOf(this.viewport),
                c = this.getHeightOf(this.viewport),
                h = this.currentLayer.scaledImageSize * this.widgetZoom,
                b = this.currentLayer.scaledImageSizeH * this.widgetZoom,
                g = 0 > a.x ? Math.floor( - a.x / h) : a.x < e ? 0 : null,
                m = 0 > a.y ? Math.floor( - a.y / b) : a.y < c ? 0 : null;
                e = Math.min(this.currentLayer.xTiles, Math.floor((e - a.x) / h));
                a = Math.min(this.currentLayer.yTiles, Math.floor((c - a.y) / b));
                null != g && null != m && this.currentLayer.ensureLoaded(g, m, e, a)
            }
        },
        {
            key: "getCurrentLayer",
            value: function() {
                return this.currentLayer
            }
        },
        {
            key: "debounce",
            value: function(a, e) {
                e = e || 150;
                var c = null;
                return function() {
                    window.clearTimeout(c);
                    c = window.setTimeout(a, e)
                }
            }
        },
        {
            key: "_doUpdateZoom",
            value: function() {
                this._calculateScale(this._mapZoomToLayer());
                this._ensureVisibleTiles()
            }
        },
        {
            key: "setZoom",
            value: function(a, e) {
                this.widgetZoom = a;
                e ? this._doUpdateZoom() : this._debounceUpdateZoom()
            }
        },
        {
            key: "pan",
            value: function() {
                this._doEnsureVisibleTiles()
            }
        },
        {
            key: "owns",
            value: function(a) {
                return a === this.canvas || !0 === a._tiledBg
            }
        },
        {
            key: "getHeight",
            value: function() {
                return this.height
            }
        },
        {
            key: "getWidth",
            value: function() {
                return this.width
            }
        }]),
        k
    } (),
    Nl = function(k) {
        function a(c) {
            return Aa(this, a),
            e.call(this, c)
        }
        Vb(a, Ni);
        var e = Wb(a);
        return Ia(a, [{
            key: "getTileSpecs",
            value: function(c) {
                var h = Math.pow(2, this.maxZoom - c);
                c = Math.ceil(this.width / h / this.tileSize[0]);
                h = Math.ceil(this.height / h / this.tileSize[1]);
                return [c, h, c * this.tileSize[0] / this.width, h * this.tileSize[1] / this.height]
            }
        }]),
        a
    } (),
    Ol = function() {
        function k(a) {
            var e = this;
            Aa(this, k);
            D(this, "canvas", void 0);
            D(this, "onBackgroundReady", void 0);
            D(this, "backgroundImage", void 0);
            this.canvas = a.canvas;
            this.onBackgroundReady = a.onBackgroundReady ||
            function() {};
            this.backgroundImage = new Image;
            this.backgroundImage.onload = function() {
                e.canvas.style.backgroundImage = "url('" + e.backgroundImage.src + "')";
                e.canvas.style.backgroundRepeat = "no-repeat";
                e.canvas.style.width = e.backgroundImage.width + "px";
                e.canvas.style.height = e.backgroundImage.height + "px";
                e.onBackgroundReady(e)
            };
            this.backgroundImage.src = a.img ? a.img.src: a.url
        }
        return Ia(k, [{
            key: "owns",
            value: function(a) {
                return a === this.canvas
            }
        },
        {
            key: "getWidth",
            value: function() {
                return this.backgroundImage.width || 0
            }
        },
        {
            key: "getHeight",
            value: function() {
                return this.backgroundImage.height || 0
            }
        },
        {
            key: "setZoom",
            value: function(a, e) {}
        },
        {
            key: "pan",
            value: function() {}
        }]),
        k
    } (),
    Pl = function(k) {
        function a(c) {
            return Aa(this, a),
            e.call(this, c)
        }
        Vb(a, Ni);
        var e = Wb(a);
        return Ia(a, [{
            key: "getTileSpecs",
            value: function(c) {
                var h = Math.pow(2, c + 1) * this.tileSize[0] * (this.width > this.height ? 1 : this.width / this.height);
                c = Math.pow(2, c + 1) * this.tileSize[1] * (this.height > this.width ? 1 : this.height / this.width);
                return [Math.ceil(h / this.tileSize[0]), Math.ceil(c / this.tileSize[1]), h / this.width, c / this.height]
            }
        }]),
        a
    } (),
    Ql = function() {
        function k(a) {
            Aa(this, k);
            this.panZoom = a;
            D(this, "fixedElements", {})
        }
        return Ia(k, [{
            key: "_fixElements",
            value: function(a) {
                var e, c, h = this,
                b;
                for (b in this.fixedElements) this.fixedElements.hasOwnProperty(b) &&
                function() {
                    if (e = e || h.panZoom.getApparentCanvasLocation(), c = null == c ? h.panZoom.getZoom() : c, null != a && a !== b) return "continue";
                    var g = h.fixedElements[b],
                    m = function(r, t) {
                        g[r] && (0 > e[t] / c + g.pos[t] ? g.el.style[r] = -e[t] / c + "px": g.el.style[r] = g.pos[t] + "px")
                    };
                    m("left", 0);
                    m("top", 1)
                } ()
            }
        },
        {
            key: "pan",
            value: function() {
                this._fixElements()
            }
        },
        {
            key: "append",
            value: function(a, e, c) {
                if (null != a) {
                    e = e || {};
                    var h = this.panZoom.idFunction(a);
                    this.fixedElements[h] = {
                        el: a,
                        left: e.left,
                        top: e.top,
                        pos: c
                    };
                    a.style.position = "absolute";
                    a.style.left = c.x + "px";
                    a.style.top = c.y + "px";
                    this.panZoom.canvasElement.appendChild(a);
                    this._fixElements(h)
                }
            }
        }]),
        k
    } (),
    Oi = function(k) {
        function a(c) {
            var h;
            return Aa(this, a),
            (h = e.call(this)).surface = c,
            h
        }
        Vb(a, Nk);
        var e = Wb(a);
        return Ia(a, [{
            key: "getOffset",
            value: function(c, h) {
                return this.surface.getOffset(c)
            }
        },
        {
            key: "getViewportPosition",
            value: function(c) {
                return this.surface.getViewportPosition(c)
            }
        },
        {
            key: "getViewportPositionById",
            value: function(c) {
                return this.surface.getViewportPositionById(c)
            }
        },
        {
            key: "getSize",
            value: function(c) {
                return this.surface.jsplumb.getSize(c)
            }
        }]),
        a
    } (),
    Pi = function(k) {
        function a(c) {
            var h;
            return Aa(this, a),
            (h = e.call(this, c)).surface = c,
            h
        }
        Vb(a, Oi);
        var e = Wb(a);
        return Ia(a, [{
            key: "filter",
            value: function(c) {
                return null == c.group
            }
        },
        {
            key: "getElements",
            value: function() {
                var c = this.surface.getNodes();
                return Array.prototype.push.apply(c, this.surface.getGroups()),
                c = c.filter(function(h, b, g) {
                    return null == h.group
                })
            }
        }]),
        a
    } (),
    Rl = function(k) {
        function a(c, h) {
            var b;
            return Aa(this, a),
            (b = e.call(this, h)).group = c,
            b.surface = h,
            b
        }
        Vb(a, Oi);
        var e = Wb(a);
        return Ia(a, [{
            key: "getOffset",
            value: function(c, h) {
                return this.surface.getOffset(c)
            }
        },
        {
            key: "getElements",
            value: function() {
                return this.group.getMembers()
            }
        },
        {
            key: "filter",
            value: function(c) {
                return ka(c) && c.group == this.group
            }
        }]),
        a
    } (),
    Sl = function() {
        function k(a) {
            var e = this;
            Aa(this, k);
            D(this, "isPointerDevice", void 0);
            D(this, "isTouchDevice", void 0);
            D(this, "center", void 0);
            D(this, "radius", void 0);
            D(this, "startRadius", void 0);
            D(this, "onPinchStart", void 0);
            D(this, "onPinch", void 0);
            D(this, "onPinchEnd", void 0);
            D(this, "eventManager", void 0);
            D(this, "listenerTypes", {
                pointer: function(c) {
                    var h = {},
                    b = [],
                    g = 0,
                    m = !1,
                    r = function() {
                        2 === g && (e.center = {
                            x: (b[1].p[0] + b[0].p[0]) / 2,
                            y: (b[1].p[1] + b[0].p[1]) / 2
                        },
                        e.radius = Math.sqrt(Math.pow(b[0].p[0] - b[1].p[0], 2) + Math.pow(b[0].p[1] - b[1].p[1], 2)))
                    };
                    e.bind(c.el, "pointerdown",
                    function(t) {
                        2 <= g || m || (b[g] = {
                            e: t,
                            p: [t.pageX, t.pageY]
                        },
                        h["" + t.pointerId] = g, g++, r(), 2 === g && (e.startRadius = e.radius, e._fire(e.onPinchStart)))
                    },
                    {
                        passive: !1
                    });
                    e.bind(document, "pointerup",
                    function(t) {
                        null != h["" + t.pointerId] && (delete h["" + t.pointerId], g--, m = 0 !== g, e._fireEnd())
                    },
                    {
                        passive: !1
                    });
                    e.bind(document, "pointermove",
                    function(t) {
                        if (!m && 2 === g) {
                            var u = h[t.pointerId];
                            null != u && (b[u].p = [t.pageX, t.pageY], r(), e._fire(e.onPinch))
                        }
                    },
                    {
                        passive: !1
                    })
                },
                touch: function(c) {
                    var h = function(u, v) {
                        return u.item ? u.item(v) : u[v]
                    },
                    b = function(u) {
                        var v = h(u, 0);
                        u = h(u, 1);
                        return Math.sqrt(Math.pow(u.pageX - v.pageX, 2) + Math.pow(u.pageY - v.pageY, 2))
                    },
                    g = function(u) {
                        var v = h(u, 0);
                        u = h(u, 1);
                        return {
                            x: (v.pageX + u.pageX) / 2,
                            y: (v.pageY + u.pageY) / 2
                        }
                    },
                    m = !1,
                    r = function w(v) {
                        m = !1;
                        Ha(v);
                        e.unbind(document, "touchmove", t);
                        e.unbind(document, "touchend", w);
                        e._fireEnd()
                    },
                    t = function(v) {
                        if (m) {
                            var w = v.touches || [];
                            2 === w.length && (Ha(v), e.radius = b(w), e.center = g(w), e._fire(e.onPinch))
                        }
                    };
                    e.bind(c.el, "touchstart",
                    function(v) {
                        var w = v.touches || [];
                        2 === w.length && !1 !== c.enableWheelZoom && (e.center = g(w), e.radius = e.startRadius = b(w), m = !0, e.bind(document, "touchmove", t), e.bind(document, "touchend", r), Ha(v), e._fire(e.onPinchStart))
                    })
                }
            });
            this.eventManager = new $b;
            this.isPointerDevice = "onpointerdown" in document.documentElement;
            this.isTouchDevice = "ontouchstart" in document.documentElement;
            this.center = {
                x: 0,
                y: 0
            };
            this.startRadius = this.radius = 0;
            this.onPinch = a.onPinch;
            this.onPinchStart = a.onPinchStart;
            this.onPinchEnd = a.onPinchEnd;
            this.isPointerDevice ? this.listenerTypes.pointer(a) : this.isTouchDevice && this.listenerTypes.touch(a)
        }
        return Ia(k, [{
            key: "_fire",
            value: function(a) {
                a(this.center, this.startRadius, this.radius, this.radius / this.startRadius)
            }
        },
        {
            key: "_fireEnd",
            value: function() {
                this.onPinchEnd()
            }
        },
        {
            key: "bind",
            value: function(a, e, c, h) {
                this.eventManager.on(a, e, c)
            }
        },
        {
            key: "unbind",
            value: function(a, e, c) {
                this.eventManager.off(a, e, c)
            }
        },
        {
            key: "destroy",
            value: function() {}
        }]),
        k
    } (),
    Qi = function() {
        function k(a, e) {
            var c = this;
            Aa(this, k);
            this.surface = a;
            D(this, "canvasElement", void 0);
            D(this, "viewportElement", void 0);
            D(this, "_doWheelZoom", void 0);
            D(this, "eventManager", void 0);
            D(this, "pinchListener", void 0);
            D(this, "position", {
                x: 0,
                y: 0
            });
            D(this, "zoom", void 0);
            D(this, "transformOrigin", {
                x: 0,
                y: 0
            });
            D(this, "panning", !1);
            D(this, "pinchZooming", !1);
            D(this, "zooming", !1);
            D(this, "zoomingWithWheel", !1);
            D(this, "downAt", void 0);
            D(this, "_viewportElementSize", void 0);
            D(this, "_canvasElementSize", void 0);
            D(this, "zoomRange", void 0);
            D(this, "zoomAtZoomStart", void 0);
            D(this, "maximumZoomTravel", 150);
            D(this, "distanceAtZoomStart", void 0);
            D(this, "lastDistance", void 0);
            D(this, "canvasAtPanStart", void 0);
            D(this, "lastMouseX", -1);
            D(this, "lastMouseY", -1);
            D(this, "lastMovedAt", null);
            D(this, "lastVelocity", 0);
            D(this, "lastAcceleration", 0);
            D(this, "onZoom", void 0);
            D(this, "onMaybeZoom", void 0);
            D(this, "onPan", void 0);
            D(this, "onMouseDown", void 0);
            D(this, "onMouseUp", void 0);
            D(this, "onMouseMove", void 0);
            D(this, "onSetTransformOrigin", void 0);
            D(this, "clamp", void 0);
            D(this, "clampZoom", void 0);
            D(this, "panDistance", void 0);
            D(this, "enablePan", void 0);
            D(this, "directRender", void 0);
            D(this, "enableWheelZoom", void 0);
            D(this, "enableAnimation", void 0);
            D(this, "wheelFilter", void 0);
            D(this, "wheelZoomRequiresMetaKey", void 0);
            D(this, "wheelDirection", void 0);
            D(this, "wheelSensitivity", void 0);
            D(this, "wheelPan", void 0);
            D(this, "background", void 0);
            D(this, "fixedLayer", void 0);
            D(this, "_mouseMove", void 0);
            D(this, "_mouseMoveEnd", void 0);
            D(this, "_mouseMoveReset", void 0);
            D(this, "viewport", void 0);
            D(this, "padding", void 0);
            D(this, "consumeRightClick", void 0);
            D(this, "smartMinimumZoom", void 0);
            D(this, "_renderingSuspended", void 0);
            D(this, "idFunction", void 0);
            D(this, "enabled", void 0);
            D(this, "clampToBackground", void 0);
            D(this, "clampToBackgroundExtents", void 0);
            D(this, "filter", void 0);
            D(this, "_suspendMap", {});
            D(this, "_sortDirtyFlag", !1);
            D(this, "handlers", D({
                start: function(h, b) {
                    if (!c.pinchZooming) {
                        var g = h.srcElement || h.target;
                        c.enabled && (g === c.canvasElement || g === c.viewportElement || g._jtkDecoration || c.background && c.background.owns(g) || !0 === c.filter(g, h)) && (c.zoomingWithWheel = !1, c.lastMouseX = -1, c.lastMouseY = -1, 3 !== h.which || !1 === c.enableWheelZoom || null != h.mozInputSource && 1 !== h.mozInputSource ? 1 >= b.length && (c._viewportElementSize = Ja(c.viewportElement), c._canvasElementSize = Ja(c.canvasElement), c.panning = !0, c.downAt = bb(h), c.canvasAtPanStart = A({},
                        c.position), Ha(h)) : (c.zooming = !0, c.downAt = bb(h), c._viewportElementSize = Ja(c.viewportElement), c._canvasElementSize = Ja(c.canvasElement), c._setTransformOriginToEvent(h), c.canvasAtPanStart = A({},
                        c.position), c.zoomAtZoomStart = c.zoom));
                        c.onMouseDown(h, c)
                    }
                },
                move: function(h, b) {
                    var g; (c.zoomingWithWheel = !1, c.pinchZooming) || (c.zooming ? (b = (g = bb(h)).x - c.downAt.x, g = g.y - c.downAt.y, c._zoomBy(b, g, h)) : c.panning && c.enablePan && null != c.downAt && (Ha(h), b = (g = bb(h)).x - c.downAt.x, g = g.y - c.downAt.y, b = c._setCanvasPosition({
                        x: c.canvasAtPanStart.x + b,
                        y: c.canvasAtPanStart.y + g,
                        animate: !1
                    }), c.onPan(b.x, b.y, c.zoom, c.zoom, h), c.background && c.background.pan(), c.fixedLayer.pan(), Ha(h)), c.onMouseMove(h, c))
                },
                end: function(h, b) {
                    c.pinchZooming || (c.zooming = !1, c.downAt = null, c.panning = !1, c._viewportElementSize = null, c._canvasElementSize = null, c.zoomingWithWheel = !1, c.eventManager.off(document, "mousemove", c._mouseMove), c.eventManager.off(document, "mouseup", c._mouseMoveEnd), c.eventManager.on(document, "mousemove", c._mouseMoveReset), c.onMouseUp(h, c))
                }
            },
            "contextmenu",
            function(h) {}));
            e.events = e.events || {};
            this.zoom = e.zoom || 1;
            this.zoomRange = e.zoomRange || [.05, 3];
            this.fixedLayer = new Ql(this);
            this.eventManager = new $b;
            this.viewport = e.viewport;
            this.canvasElement = e.canvasElement;
            this._setCanvasPosition({
                x: 0,
                y: 0,
                animate: !1
            });
            this.viewportElement = e.viewportElement;
            this.idFunction = e.idFunction;
            this.onZoom = e.events.zoom || wc;
            this.onMaybeZoom = e.events.maybeZoom ||
            function() {
                return ! 0
            };
            this.onPan = e.events.pan || wc;
            this.onMouseDown = e.events.mousedown || wc;
            this.onMouseUp = e.events.mouseup || wc;
            this.onMouseMove = e.events.mousemove || wc;
            this.onSetTransformOrigin = e.events.transformOrigin || wc;
            this.clamp = !1 !== e.clamp;
            this.clampZoom = !1 !== e.clampZoom;
            this.panDistance = e.panDistance || 50;
            this.enablePan = !1 !== e.enablePan;
            this.directRender = !0 === e.directRender;
            this.enableWheelZoom = !1 !== e.enableWheelZoom;
            this.enableAnimation = !1 !== e.enableAnimation;
            this.wheelFilter = e.wheelFilter ||
            function() {
                return ! 0
            };
            this.wheelZoomRequiresMetaKey = !0 === e.wheelZoomMetaKey;
            this.wheelDirection = !0 === e.wheelReverse ? -1 : 1;
            this.wheelSensitivity = this.wheelDirection * (e.wheelSensitivity || 10);
            this.wheelPan = !0 === e.wheelPan;
            this.padding = e.padding || [0, 0];
            this.consumeRightClick = !1 !== e.consumeRightClick;
            this.smartMinimumZoom = e.smartMinimumZoom;
            this._renderingSuspended = !1;
            this._mouseMove = function(h) {
                this._call("move", h)
            }.bind(this);
            this._mouseMoveEnd = function(h) {
                this._call("end", h)
            }.bind(this);
            this._mouseMoveReset = function(h) {
                this.zoomingWithWheel = !1
            }.bind(this);
            this.enabled = !1 !== e.enabled;
            this.clampToBackground = e.clampToBackground;
            this.clampToBackgroundExtents = e.clampToBackgroundExtents;
            this.filter = e.filter ||
            function() {
                return ! 1
            };
            this.enableWheelZoom && (this._doWheelZoom = function(h, b, g, m) {
                return c.wheelPanOrZoom(h, b, g, m)
            },
            Og(this.viewportElement, this._doWheelZoom, !0, this.wheelZoomRequiresMetaKey));
            this.pinchListener = new Sl({
                el: this.viewportElement,
                enableWheelZoom: this.enableWheelZoom,
                onPinch: function(h, b, g, m) {
                    c._zoom(m * c.zoomAtZoomStart);
                    c._setCanvasPosition({
                        x: c.canvasAtPanStart.x + (h.x - c.downAt.x),
                        y: c.canvasAtPanStart.y + (h.y - c.downAt.y),
                        animate: !1
                    })
                },
                onPinchStart: function(h, b) {
                    c.pinchZooming = !0;
                    c.downAt = h;
                    c.distanceAtZoomStart = c.lastDistance = b;
                    c.zoomAtZoomStart = c.zoom;
                    c._setTransformOriginToPoint(c.downAt.x, c.downAt.y);
                    c.canvasAtPanStart = A({},
                    c.position)
                },
                onPinchEnd: function() {
                    c.pinchZooming = !1;
                    c.downAt = null
                }
            });
            this._zoom(this.zoom, null, !1, !1, !0);
            this._writeTransformOrigin();
            e.background && this.setBackground(e.background);
            this.eventManager.on(this.viewportElement, "mousedown",
            function(h) {
                c.start(h)
            });
            this.eventManager.on(document, "mousemove", this._mouseMoveReset);
            this.eventManager.on(this.viewportElement, "contextmenu",
            function(h) {
                c._call("contextmenu", h)
            })
        }
        return Ia(k, [{
            key: "_setCanvasPosition",
            value: function(a) {
                return this.position = this._clamp(a.x, a.y),
                this.enableAnimation && a.animate ? this._animateTransform(null, a.onComplete) : (this._writeTransform(), a.onComplete && a.onComplete(this.position)),
                this.position
            }
        },
        {
            key: "_moveCanvas",
            value: function(a, e, c, h) {
                var b = this.position;
                return this._setCanvasPosition({
                    x: b.x + a,
                    y: b.y + e,
                    animate: c,
                    onComplete: h
                })
            }
        },
        {
            key: "_wheelPan",
            value: function(a, e, c, h) {
                h || this.pan(100 * -e, 100 * -c)
            }
        },
        {
            key: "_wheelZoom",
            value: function(a, e, c, h) {
                this.zoomAtZoomStart = this.zoom;
                this.zoomingWithWheel || (this._setTransformOriginToEvent(a), this.zoomingWithWheel = !0);
                this._zoomBy(0, a.normalizedWheelDelta * this.wheelSensitivity, a, !0)
            }
        },
        {
            key: "wheelPanOrZoom",
            value: function(a, e, c, h) {
                this.wheelFilter(a) && (a.preventDefault && a.preventDefault(), a.stopPropagation && a.stopPropagation(), !this.wheelPan || h ? this._wheelZoom(a, e, c, h) : this._wheelPan(a, e, c, h))
            }
        },
        {
            key: "setSuspendRendering",
            value: function(a) {
                this._renderingSuspended = a
            }
        },
        {
            key: "_cssAnimation",
            value: function(a, e, c) {
                var h = this;
                this.canvasElement.animate(a, {
                    duration: e || 250
                }).finished.then(function() {
                    for (var b in a) h.canvasElement.style[b] = a[b];
                    c && c(h.position)
                })
            }
        },
        {
            key: "_constructTransformProperty",
            value: function() {
                return "scale(".concat(this.zoom, ") translateX(").concat(this.position.x / this.zoom, "px) translateY(").concat(this.position.y / this.zoom, "px)")
            }
        },
        {
            key: "_writeTransform",
            value: function() {
                this.canvasElement.style.transform = this._constructTransformProperty()
            }
        },
        {
            key: "_animateTransform",
            value: function(a, e) {
                if (null != this.canvasElement.animate) {
                    var c = D({},
                    "transform", this._constructTransformProperty());
                    this._cssAnimation(c, a, e)
                } else this._writeTransform()
            }
        },
        {
            key: "_constructTransformOriginProperty",
            value: function() {
                return this.transformOrigin.x + "% " + this.transformOrigin.y + "%"
            }
        },
        {
            key: "_writeTransformOrigin",
            value: function() {
                this.canvasElement.style.transformOrigin = this._constructTransformOriginProperty()
            }
        },
        {
            key: "_animateTransformOrigin",
            value: function(a, e) {
                null != this.canvasElement.animate ? this._cssAnimation(D({},
                "transformOrigin", this._constructTransformOriginProperty()), a, e) : this._writeTransformOrigin()
            }
        },
        {
            key: "_animateTransformAndOrigin",
            value: function(a, e) {
                var c = this;
                if (null != this.canvasElement.animate) {
                    var h;
                    a = this.canvasElement.animate((D(h = {},
                    "transformOrigin", this._constructTransformOriginProperty()), D(h, "transform", this._constructTransformProperty()), h), {
                        duration: a || 250
                    });
                    e && (a.onfinish = function() {
                        return e(c.position)
                    })
                } else this._writeTransformOrigin(),
                this._writeTransform()
            }
        },
        {
            key: "_originHelper",
            value: function(a, e) {
                a = this.fromPageLocation(a, e);
                e = this._canvasElementSize || Ja(this.canvasElement);
                return {
                    w: e.w,
                    h: e.h,
                    xy: a,
                    xScale: a.x / e.w,
                    yScale: a.y / e.h,
                    o: {
                        x: a.x / e.w * 100,
                        y: a.y / e.h * 100
                    }
                }
            }
        },
        {
            key: "_setTransformHelper",
            value: function(a, e, c, h) {
                var b = this.transformOrigin.x / 100 * e,
                g = this.transformOrigin.y / 100 * c;
                h = -b * (1 - this.zoom);
                var m = -g * (1 - this.zoom);
                this.transformOrigin = a;
                this._writeTransformOrigin();
                b = this.transformOrigin.x / 100 * e;
                g = this.transformOrigin.y / 100 * c;
                a = this._moveCanvas( - b * (1 - this.zoom) - h, -g * (1 - this.zoom) - m, !1);
                this.onSetTransformOrigin && this.onSetTransformOrigin(this.transformOrigin, a)
            }
        },
        {
            key: "_setTransformOriginToPoint",
            value: function(a, e, c) {
                a = this._originHelper(a, e);
                this._setTransformHelper(a.o, a.w, a.h, c)
            }
        },
        {
            key: "_setTransformOriginToEvent",
            value: function(a) {
                var e = bb(a);
                this._setTransformOriginToPoint(e.x, e.y, a)
            }
        },
        {
            key: "_setTransformOriginToCanvasPoint",
            value: function(a, e) {
                var c = this._canvasElementSize || Ja(this.canvasElement);
                this._setTransformHelper({
                    x: a / c.w * 100,
                    y: e / c.h * 100
                },
                c.w, c.h)
            }
        },
        {
            key: "_zoom",
            value: function(a, e, c, h, b) {
                var g = this;
                if (! (this.directRender || null == a || isNaN(a) || 0 > a)) {
                    var m = this.zoomRange[0];
                    if (this.smartMinimumZoom) {
                        m = .5;
                        var r = this.getBoundsInfo().z;
                        a / r < m && (a = r * m)
                    } else a < m && (a = m);
                    a > this.zoomRange[1] && (a = this.zoomRange[1]);
                    var t = this.zoom;
                    this.zoom = a;
                    m = function(u) {
                        if (b || g.onZoom(0, 0, a, t, e, c), null != g.background && g.background.setZoom(a), g.fixedLayer.pan(), g.clampZoom) {
                            u = g.position;
                            var v = g._clamp(u.x, u.y);
                            v.x == u.x && v.y == u.y || g._setCanvasPosition({
                                x: v.x,
                                y: v.y,
                                animate: !1
                            })
                        }
                    };
                    h ? (h = this.getViewportCenter(), this._setTransformOriginToCanvasPoint(h.x, h.y), this.zoom = a, this._animateTransform(null, m)) : (this.zoom = a, this._writeTransform(), m(this.position));
                    return this.zoom
                }
            }
        },
        {
            key: "_zoomBy",
            value: function(a, e, c, h) {
                e < -this.maximumZoomTravel && (e = -this.maximumZoomTravel);
                e > this.maximumZoomTravel && (e = this.maximumZoomTravel);
                this._zoomWithMappedRange(this.zoomAtZoomStart, e, -this.maximumZoomTravel, this.maximumZoomTravel, c, h)
            }
        },
        {
            key: "_zoomWithMappedRange",
            value: function(a, e, c, h, b, g) {
                this._zoom(a + e / (0 <= e ? h: c) * (this.zoomRange[0 <= e ? 1 : 0] - a), b, g)
            }
        },
        {
            key: "_clamp",
            value: function(a, e, c) {
                if (this.clamp || this.clampToBackground || this.clampToBackgroundExtents) {
                    var h = this._viewportElementSize || Ja(this.viewportElement),
                    b = this._apparentOffset(),
                    g = a,
                    m = e;
                    h = this.clamp ? this.getBoundsInfo() : {
                        x: 0,
                        y: 0,
                        w: 0,
                        h: 0,
                        vw: h.w,
                        vh: h.h,
                        padding: c,
                        z: 1
                    };
                    if (c = (c || 20) * this.zoom, (this.clampToBackground || this.clampToBackgroundExtents) && null != this.background) {
                        var r = this.background.getWidth(),
                        t = this.background.getHeight();
                        t = Math.max(h.y + h.h, t);
                        h.w = Math.max(h.x + h.w, r) - h.w;
                        h.h = t - h.h;
                        h.z = Math.min(h.vw / h.w, h.vh / h.h);
                        this.clampToBackgroundExtents && (c = Math.max(h.vw, h.vh))
                    }
                    t = [h.x + h.w, h.y + h.h];
                    this.background && (t[0] = Math.max(t[0], this.background.getWidth()), t[1] = Math.max(t[1], this.background.getHeight()));
                    r = a + b.x + t[0] * this.zoom - c;
                    t = e + b.y + t[1] * this.zoom - c;
                    a = a + b.x + h.x * this.zoom + c;
                    e = e + b.y + h.y * this.zoom + c;
                    return 0 > r && (g -= r),
                    a > h.vw && (g -= a - h.vw),
                    0 > t && (m -= t),
                    e > h.vh && (m -= e - h.vh),
                    {
                        x: g,
                        y: m
                    }
                }
                return {
                    x: a,
                    y: e
                }
            }
        },
        {
            key: "_getPosition",
            value: function(a) {
                return {
                    x: parseInt(a.style.left, 10) || 0,
                    y: parseInt(a.style.top, 10) || 0
                }
            }
        },
        {
            key: "_apparentOffset",
            value: function() {
                var a = this._canvasElementSize || Ja(this.canvasElement);
                return {
                    x: this.transformOrigin.x / 100 * a.w * (1 - this.zoom),
                    y: this.transformOrigin.y / 100 * a.h * (1 - this.zoom)
                }
            }
        },
        {
            key: "_call",
            value: function(a, e) {
                "contextmenu" === a && this.consumeRightClick && e.preventDefault && e.preventDefault();
                var c = Ld(e);
                this.handlers[a](e, c)
            }
        },
        {
            key: "start",
            value: function(a) {
                this.enabled && null != a && (this.eventManager.off(document, "mousemove", this._mouseMoveReset), this.eventManager.on(document, "mousemove", this._mouseMove), this.eventManager.on(document, "mouseup", this._mouseMoveEnd), this.handlers.start(a, Ld(a)))
            }
        },
        {
            key: "getBoundsInfo",
            value: function(a, e) {
                var c = this._viewportElementSize || Ja(this.viewportElement);
                if (this.viewport.isEmpty()) return {
                    w: 0,
                    h: 0,
                    x: 0,
                    y: 0,
                    vw: c.w,
                    vh: c.h,
                    padding: a,
                    z: 1,
                    zoom: 1
                };
                a = a || 0;
                e = e || .9;
                var h = this.viewport.getBoundsWidth(),
                b = this.viewport.getBoundsHeight();
                e = Math.min(c.w / ((h + 2 * a) / e), c.h / ((b + 2 * a) / e));
                return {
                    w: h,
                    h: b,
                    x: this.viewport.getX(),
                    y: this.viewport.getY(),
                    vw: c.w,
                    vh: c.h,
                    padding: a,
                    z: e,
                    zoom: this.zoom
                }
            }
        },
        {
            key: "isPinchZooming",
            value: function() {
                return this.pinchZooming
            }
        },
        {
            key: "add",
            value: function(a, e, c, h) {
                h && (a._jtkDecoration = !0)
            }
        },
        {
            key: "suspend",
            value: function(a) {
                a = "string" == typeof a ? a: this.idFunction(a);
                this._suspendMap[a] = !0;
                this._removeFromTracking(a)
            }
        },
        {
            key: "isSuspended",
            value: function(a) {
                a = "string" == typeof a ? a: this.idFunction(a);
                return ! 0 === this._suspendMap[a]
            }
        },
        {
            key: "restore",
            value: function(a) {
                a = "string" == typeof a ? a: this.idFunction(a);
                delete this._suspendMap[a]
            }
        },
        {
            key: "remove",
            value: function(a) {
                a = this.idFunction(a);
                delete this._suspendMap[a];
                this._removeFromTracking(a)
            }
        },
        {
            key: "_removeFromTracking",
            value: function(a) {}
        },
        {
            key: "reset",
            value: function() {
                this._suspendMap = {};
                this._setCanvasPosition({
                    x: 0,
                    y: 0,
                    animate: !1
                })
            }
        },
        {
            key: "zoomToFit",
            value: function(a) {
                a = a || {};
                var e = this.getBoundsInfo(a.padding, a.fill);
                a.doNotZoomIfVisible && e.z > this.zoom || this._zoom(e.z);
                this.centerContent({
                    bounds: e,
                    doNotAnimate: !1 !== a.doNotAnimate,
                    onComplete: a.onComplete,
                    doNotFirePanEvent: a.doNotFirePanEvent
                })
            }
        },
        {
            key: "zoomToFitIfNecessary",
            value: function(a) {
                a = A(a || {},
                {});
                a.doNotZoomIfVisible = !0;
                this.zoomToFit(a)
            }
        },
        {
            key: "zoomToElements",
            value: function(a) {
                var e = Ja(this.viewportElement);
                e = {
                    x: 1 / 0,
                    y: 1 / 0,
                    xMax: -1 / 0,
                    yMax: -1 / 0,
                    z: 1,
                    vw: e.w,
                    vh: e.h
                };
                for (var c = 0; c < a.elements.length; c++) {
                    var h = this.viewport.getPosition(this.idFunction(a.elements[c]));
                    h && (e.x = Math.min(e.x, h.x), e.y = Math.min(e.y, h.y), e.xMax = Math.max(e.xMax, h.x2), e.yMax = Math.max(e.yMax, h.y2))
                }
                c = a.fill || .9;
                e.w = e.xMax - e.x;
                e.h = e.yMax - e.y;
                e.z = c * Math.min(e.vw / e.w, e.vh / e.h);
                a.doNotZoomIfVisible && e.z > this.zoom || this._zoom(e.z);
                this.centerContent({
                    bounds: e,
                    doNotAnimate: !1 !== a.doNotAnimate,
                    onComplete: a.onComplete,
                    doNotFirePanEvent: a.doNotFirePanEvent
                })
            }
        },
        {
            key: "zoomToBackground",
            value: function(a) {
                if (a = a || {},
                null != this.background) {
                    var e = this.background.getWidth(),
                    c = this.background.getHeight(),
                    h = Ja(this.viewportElement),
                    b = Math.min(h.w / e, h.h / c);
                    e = {
                        w: e,
                        h: c,
                        x: 0,
                        y: 0,
                        vw: h.w,
                        vh: h.h,
                        padding: 0,
                        z: b,
                        zoom: b
                    };
                    this._zoom(e.z);
                    this.centerContent({
                        bounds: e,
                        doNotAnimate: a.doNotAnimate,
                        onComplete: a.onComplete
                    })
                }
            }
        },
        {
            key: "setFilter",
            value: function(a) {
                this.filter = a ||
                function() {
                    return ! 1
                }
            }
        },
        {
            key: "centerBackground",
            value: function(a) {
                if (null != this.background) {
                    var e = A({},
                    this.getBoundsInfo());
                    e.x = this.background.getWidth() / 2;
                    e.y = this.background.getHeight() / 2;
                    e.w = 1;
                    e.h = 1;
                    this.centerContent({
                        bounds: e,
                        doNotAnimate: a.doNotAnimate,
                        onComplete: a.onComplete,
                        vertical: !0,
                        horizontal: !0
                    })
                }
            }
        },
        {
            key: "alignBackground",
            value: function(a) {
                if (null != this.background) {
                    var e = a.split(" ");
                    a = e[0] || "left";
                    e = e[1] || "top";
                    var c = this.getBoundsInfo();
                    a = "left" === a ? 0 : c.vw - this.background.getWidth() * this.zoom;
                    e = "top" === e ? 0 : c.vh - this.background.getHeight() * this.zoom;
                    c = this._apparentOffset();
                    this._setCanvasPosition({
                        x: a - c.x,
                        y: e - c.y,
                        animate: !0
                    });
                    this.background.pan();
                    this.fixedLayer.pan()
                }
            }
        },
        {
            key: "positionElementAt",
            value: function(a, e, c, h, b, g) {
                h = h || 0;
                b = b || 0;
                var m = this._apparentOffset(),
                r = this.position,
                t = this.surface.getOffset(a.parentNode),
                u = this.surface.getOffset(this.viewportElement);
                e = u.x - t.x + (r.x + m.x) + e * this.zoom + h;
                c = u.y - t.y + (r.y + m.y) + c * this.zoom + b;
                g && 0 > e && (e = 0);
                g && 0 > c && (c = 0);
                a.style.left = e + "px";
                a.style.top = c + "px"
            }
        },
        {
            key: "positionElementAtPageLocation",
            value: function(a, e, c, h, b) {
                e = this.fromPageLocation(e, c);
                this.positionElementAt(a, e.x, e.y, h, b)
            }
        },
        {
            key: "positionElementAtEventLocation",
            value: function(a, e, c, h) {
                e = this.mapEventLocation(e);
                this.positionElementAt(a, e.x, e.y, c, h)
            }
        },
        {
            key: "zoomToEvent",
            value: function(a, e) {
                this._setTransformOriginToEvent(a);
                this._zoom(this.zoom + e, a)
            }
        },
        {
            key: "relayout",
            value: function(a) {
                if (!1 === this.enablePan) {
                    var e = a[2] - a[0],
                    c = a[3] - a[1],
                    h = window.getComputedStyle(this.viewportElement),
                    b = 1,
                    g = 1,
                    m = parseInt(h.getPropertyValue("max-width"), 10);
                    h = parseInt(h.getPropertyValue("max-height"), 10); ! isNaN(m) && e > m && (b = m / e, e = m); ! isNaN(h) && c > h && (g = h / c, c = h);
                    b = Math.min(b, g);
                    this.canvasElement.style.width = e + "px";
                    this.canvasElement.style.height = c + "px";
                    this.canvasElement.style.left = "0";
                    this.canvasElement.style.top = "0";
                    this.canvasElement.style.transform = "translateX(" + (0 > a[0] ? -a[0] : 0) * b + "px) translateY(" + (0 > a[1] ? -a[1] : 0) * b + "px) scale(" + b + ")";
                    this.setTransformOrigin(0, 0)
                }
            }
        },
        {
            key: "nudgeZoom",
            value: function(a, e) {
                var c = this.surface.jsplumb.getOffsetRelativeToRoot(this.viewportElement),
                h = Ja(this.viewportElement);
                return this._setTransformOriginToPoint(c.x + h.w / 2, c.y + h.h / 2),
                this._zoom(this.zoom + a, e)
            }
        },
        {
            key: "nudgeWheelZoom",
            value: function(a, e) {
                this.zoomAtZoomStart = this.zoom;
                this._zoomBy(0, a, e, !0)
            }
        },
        {
            key: "centerContent",
            value: function(a) {
                var e = this;
                if (!this.directRender) {
                    var c = (a = a || {}).bounds || this.getBoundsInfo(),
                    h = this._apparentOffset(),
                    b = c.vw / 2 - (c.x * this.zoom + c.w * this.zoom / 2),
                    g = c.vh / 2 - (c.y * this.zoom + c.h * this.zoom / 2),
                    m = this.position,
                    r = !1 !== a.horizontal ? b - h.x: m.x,
                    t = !1 !== a.vertical ? g - h.y: m.y;
                    this._setCanvasPosition({
                        x: r,
                        y: t,
                        animate: !a.doNotAnimate,
                        onComplete: function() {
                            a.doNotFirePanEvent || e.onPan(!1 !== a.horizontal ? b - m.x: 0, !1 !== a.vertical ? g - m.y: 0, e.zoom, e.zoom);
                            e.background && e.background.pan();
                            e.fixedLayer.pan();
                            a.onComplete && a.onComplete({
                                x: r,
                                y: t
                            })
                        }
                    })
                }
            }
        },
        {
            key: "centerContentHorizontally",
            value: function(a) {
                this.centerContent(A({
                    horizontal: !0,
                    vertical: !1
                },
                a))
            }
        },
        {
            key: "centerContentVertically",
            value: function(a) {
                this.centerContent(A({
                    vertical: !0,
                    horizontal: !1
                },
                a))
            }
        },
        {
            key: "centerOn",
            value: function(a, e) {
                var c = this;
                e = e || {};
                var h = A({},
                this.getBoundsInfo()),
                b = this._getPosition(a),
                g = Ja(a);
                h.x = b.x;
                h.y = b.y;
                h.w = g.w;
                h.h = g.h;
                this.centerContent({
                    bounds: h,
                    doNotAnimate: e.doNotAnimate,
                    onComplete: function() {
                        c._setTransformOriginToCanvasPoint(b.x + g.w / 2, b.y + g.h / 2);
                        e.onComplete && e.onComplete(b)
                    },
                    vertical: !1 !== e.vertical,
                    horizontal: !1 !== e.horizontal
                })
            }
        },
        {
            key: "centerOnHorizontally",
            value: function(a, e) {
                this.centerOn(a, {
                    vertical: !1,
                    doNotAnimate: e.doNotAnimate,
                    onComplete: e.onComplete
                })
            }
        },
        {
            key: "centerOnVertically",
            value: function(a, e) {
                this.centerOn(a, {
                    horizontal: !1,
                    doNotAnimate: e.doNotAnimate,
                    onComplete: e.onComplete
                })
            }
        },
        {
            key: "centerOnAndZoom",
            value: function(a, e) {
                var c = this,
                h = e.fillRatio || .6,
                b = Ja(a),
                g = this._getPosition(a),
                m = this.getBoundsInfo();
                m = m.vw < m.vh ? [m.vw, "w"] : [m.vh, "h"];
                var r = h * m[0] / b[m[1]];
                r < this.zoomRange[0] && (r = this.zoomRange[0]);
                r > this.zoomRange[1] && (r = this.zoomRange[1]);
                this.zoom;
                this.zoom;
                this._setTransformOriginToCanvasPoint(g.x + b.w / 2, g.y + b.h / 2);
                this.centerOn(a, {
                    onComplete: function() {
                        c._zoom(r, null, null, !e.doNotAnimate)
                    }
                })
            }
        },
        {
            key: "getViewportCenter",
            value: function() {
                var a = A({},
                this.getBoundsInfo()),
                e = this._apparentOffset(),
                c = this.position;
                return {
                    x: (a.vw / 2 - (c.x + e.x)) / this.zoom,
                    y: (a.vh / 2 - (c.y + e.y)) / this.zoom
                }
            }
        },
        {
            key: "setViewportCenter",
            value: function(a) {
                var e = A({},
                this.getBoundsInfo()),
                c = this._apparentOffset();
                this._setCanvasPosition({
                    x: -(a.x * this.zoom - e.vw / 2 + c.x),
                    y: -(a.y * this.zoom - e.vh / 2 + c.y),
                    animate: !1
                })
            }
        },
        {
            key: "setClamping",
            value: function(a) {
                this.clamp = a
            }
        },
        {
            key: "isClamping",
            value: function() {
                return this.clamp
            }
        },
        {
            key: "setZoom",
            value: function(a, e) {
                return this._zoom(a, null, null, e)
            }
        },
        {
            key: "setZoomRange",
            value: function(a, e) {
                return null != a && 2 === a.length && a[0] < a[1] && null != a[0] && null != a[1] && 0 < a[0] && 0 < a[1] && (this.zoomRange = a, e || (this.zoom < this.zoomRange[0] || this.zoom > this.zoomRange[1]) && this._zoom(this.zoom)),
                this.zoomRange
            }
        },
        {
            key: "getZoomRange",
            value: function() {
                return this.zoomRange
            }
        },
        {
            key: "getZoom",
            value: function() {
                return this.zoom
            }
        },
        {
            key: "getPan",
            value: function() {
                return A({},
                this.position)
            }
        },
        {
            key: "pan",
            value: function(a, e, c, h) {
                var b = this;
                this._moveCanvas(a, e, c,
                function(g) {
                    b.onPan(g.x, g.y, b.zoom, b.zoom);
                    b.background && b.background.pan();
                    b.fixedLayer.pan();
                    h && h(g)
                })
            }
        },
        {
            key: "setPan",
            value: function(a, e, c, h) {
                return this._setCanvasPosition({
                    x: a,
                    y: e,
                    animate: c,
                    onComplete: h
                })
            }
        },
        {
            key: "setTransformOrigin",
            value: function(a, e) {
                this.transformOrigin = {
                    x: a,
                    y: e
                };
                this._writeTransformOrigin()
            }
        },
        {
            key: "fromPageLocation",
            value: function(a, e, c) {
                var h = this._apparentOffset(),
                b = this.position,
                g = Rg(this.viewportElement);
                c = c ? {
                    x: 0,
                    y: 0
                }: Sg(this.viewportElement);
                return {
                    x: (a - (b.x + h.x) - c.x + g.x) / this.zoom,
                    y: (e - (b.y + h.y) - c.y + g.y) / this.zoom
                }
            }
        },
        {
            key: "toPageLocation",
            value: function(a, e, c) {
                var h = this._apparentOffset(),
                b = this.position,
                g = Rg(this.viewportElement);
                c = c ? {
                    x: 0,
                    y: 0
                }: Sg(this.viewportElement);
                return {
                    x: a * this.zoom - g.x + c.x + b.x + h.x,
                    y: e * this.zoom - g.y + c.y + b.y + h.y
                }
            }
        },
        {
            key: "mapEventLocation",
            value: function(a, e) {
                a = bb(a);
                return this.fromPageLocation(a.x, a.y, e)
            }
        },
        {
            key: "setEnabled",
            value: function(a) {
                this.enabled = a
            }
        },
        {
            key: "showElementAt",
            value: function(a, e, c) {
                var h = this.surface.getOffset(a.parentNode),
                b = this.surface.getOffset(this.viewportElement),
                g = this._apparentOffset();
                c = h.y - b.y + g.y + c;
                a.style.left = h.x - b.x + g.x + e + "px";
                a.style.top = c + "px"
            }
        },
        {
            key: "getApparentCanvasLocation",
            value: function() {
                var a = this._apparentOffset(),
                e = this.position;
                return {
                    x: e.x + a.x,
                    y: e.y + a.y
                }
            }
        },
        {
            key: "setApparentCanvasLocation",
            value: function(a, e) {
                var c = this._apparentOffset();
                a = this._setCanvasPosition({
                    x: a - c.x,
                    y: e - c.y,
                    animate: !1
                });
                return this.background && this.background.pan(),
                this.fixedLayer.pan(),
                a
            }
        },
        {
            key: "floatElement",
            value: function(a, e) {
                null != a && (a.style.position = "absolute", a.style.left = e.x + "px", a.style.top = e.y + "px", this.viewportElement.appendChild(a))
            }
        },
        {
            key: "fixElement",
            value: function(a, e, c) {
                this.fixedLayer.append(a, e, c)
            }
        },
        {
            key: "findIntersectingElements",
            value: function(a, e, c, h) {
                var b = this,
                g = this.getApparentCanvasLocation(),
                m = this.surface.getOffset(this.viewportElement),
                r = [],
                t = {
                    x: a.x,
                    y: a.y,
                    w: e.w,
                    h: e.h
                },
                u = m.x + g.x - this.viewportElement.scrollLeft,
                v = m.y + g.y - this.viewportElement.scrollTop;
                return this.viewport.getElements().forEach(function(w, z) {
                    if (!b._suspendMap[z]) {
                        var y = {
                            x: u + w.x * b.zoom,
                            y: v + w.y * b.zoom,
                            w: w.w * b.zoom,
                            h: w.h * b.zoom
                        };
                        if (c) {
                            var E = t.x + t.w;
                            var F = t.y,
                            M = t.y + t.h,
                            S = y.x + y.w,
                            X = y.y,
                            da = y.y + y.h;
                            E = t.x < y.x && E > S && F < X && M > da
                        } else E = cc(t, y);
                        E && (null == h || h(w, y, z)) && r.push({
                            id: z,
                            r: y
                        })
                    }
                }),
                r
            }
        },
        {
            key: "findNearbyElements",
            value: function(a, e, c, h) {
                var b = [];
                if (!c || this.isInViewport(a.x, a.y)) {
                    b = this.findIntersectingElements({
                        x: a.x - e,
                        y: a.y - e
                    },
                    {
                        w: 2 * e,
                        h: 2 * e
                    },
                    !1, h);
                    var g = this.fromPageLocation(a.x, a.y);
                    b.sort(function(m, r) {
                        r = {
                            x: r.x + r.w / 2,
                            y: r.y + r.h / 2
                        };
                        m = Va({
                            x: g.x,
                            y: g.y
                        },
                        {
                            x: m.x + m.w / 2,
                            y: m.y + m.h / 2
                        });
                        r = Va({
                            x: g.x,
                            y: g.y
                        },
                        r);
                        return m < r ? -1 : m > r ? 1 : 0
                    })
                }
                return b
            }
        },
        {
            key: "isInViewport",
            value: function(a, e) {
                var c = this.surface.getOffset(this.viewportElement),
                h = this.surface.jsplumb.getSize(this.viewportElement);
                return c.x <= a && a <= c.x + h.w && c.y <= e && e <= c.y + h.h
            }
        },
        {
            key: "setWheelFilter",
            value: function(a) {
                this.wheelFilter = a ||
                function(e) {
                    return ! 0
                }
            }
        },
        {
            key: "setBackground",
            value: function(a) {
                this.background = new {
                    simple: Ol,
                    tiled: "absolute" === a.tiling ? Nl: Pl
                } [a.type || "simple"]({
                    canvas: this.canvasElement,
                    viewport: this.viewportElement,
                    url: a.url,
                    zoomWidget: this,
                    onBackgroundReady: a.onBackgroundReady,
                    options: a,
                    img: a.img
                })
            }
        },
        {
            key: "getBackground",
            value: function() {
                return this.background
            }
        },
        {
            key: "destroy",
            value: function() {
                null != this._doWheelZoom && Qg(this.viewportElement, this._doWheelZoom);
                this.pinchListener.destroy()
            }
        }]),
        k
    } (); (function() {
        function k() {
            Aa(this, k)
        }
        return Ia(k, null, [{
            key: "setNodeText",
            value: function(a, e) {
                a.text = e;
                try {
                    a.textContent = e
                } catch(c) {}
            }
        },
        {
            key: "getNodeText",
            value: function(a) {
                return null != a ? a.text || a.textContent: ""
            }
        },
        {
            key: "getChild",
            value: function(a, e) {
                for (var c = null,
                h = 0; h < a.childNodes.length; h++) if (1 === a.childNodes[h].nodeType && a.childNodes[h].nodeName === e) {
                    c = a.childNodes[h];
                    break
                }
                return c
            }
        },
        {
            key: "getChildren",
            value: function(a, e) {
                for (var c = [], h = 0; h < a.childNodes.length; h++) 1 === a.childNodes[h].nodeType && a.childNodes[h].nodeName === e && c.push(a.childNodes[h]);
                return c
            }
        },
        {
            key: "xmlToString",
            value: function(a) {
                try {
                    return (new XMLSerializer).serializeToString(a).replace(/\s*xmlns="http:\/\/www.w3.org\/1999\/xhtml"/g, "")
                } catch(e) {
                    try {
                        return a.xml
                    } catch(c) {
                        throw Error("Cannot serialize XML " + c);
                    }
                }
            }
        },
        {
            key: "createElement",
            value: function(a, e, c) {
                try {
                    var h = (new ActiveXObject("Microsoft.XMLDOM")).createNode(1, a, "")
                } catch(g) {
                    h = document.createElement(a)
                }
                if (c && k.setNodeText(h, c), e) for (var b in e) h.setAttribute(b, e[b]);
                return h
            }
        }]),
        k
    })();
    var Tl = function(k) {
        function a() {
            return Aa(this, a),
            e.apply(this, arguments)
        }
        Vb(a, fl);
        var e = Wb(a);
        return Ia(a, [{
            key: "loadData",
            value: function(c) {
                Tg(c)
            }
        }]),
        a
    } (),
    Pc; !
    function(k) {
        k.addType = "addType";
        k.removeType = "removeType"
    } (Pc || (Pc = {}));
    var Ul = function() {
        function k(a, e, c) {
            for (var h in Aa(this, k), this.id = a, this.state = e, this.jsplumb = c, e) if (e.hasOwnProperty(h)) {
                var b = "*" === h ? "".concat("e-state", "-").concat(a) : "".concat("e-state", "-").concat(a, "-").concat(h),
                g = "*" === h ? "".concat("c-state", "-").concat(a) : "".concat("c-state", "-").concat(a, "-").concat(h);
                c.registerEndpointType(b, e[h]);
                c.registerConnectionType(g, e[h])
            }
        }
        return Ia(k, [{
            key: "_portStateOperation",
            value: function(a, e, c, h, b, g) {
                a = e.endpoints[h];
                c = g.getPortType(c.data);
                a[b]("".concat("e-state", "-").concat(this.id, "-").concat(c));
                a[b]("".concat("e-state", "-").concat(this.id))
            }
        },
        {
            key: "activate",
            value: function(a, e, c) {
                var h = this;
                a.eachEdge(function(b, g) {
                    b = e.getRenderedConnection(g.getId());
                    var m = c.getEdgeType(g.data); (m = m ? "".concat("c-state", "-").concat(h.id, "-").concat(m) : null) && b.addType(m, g.data);
                    h.state["*"] && b.addType("".concat("c-state", "-").concat(h.id), g.data);
                    h._portStateOperation(g, b, g.source, 0, Pc.addType, c);
                    h._portStateOperation(g, b, g.target, 1, Pc.addType, c)
                });
                a.eachNode(function(b, g) {
                    b = (b = c.getNodeType(g.data)) ? h.state[b] : null;
                    g = e.getRenderedVertex(g.id);
                    b && b.cssClass && sa(g, b.cssClass);
                    h.state["*"] && sa(g, h.state["*"].cssClass)
                });
                a.eachGroup(function(b, g) {
                    b = (b = c.getNodeType(g.data)) ? h.state[b] : null;
                    g = e.getRenderedVertex(g.id);
                    b && b.cssClass && sa(g, b.cssClass);
                    h.state["*"] && sa(g, h.state["*"].cssClass)
                })
            }
        },
        {
            key: "deactivate",
            value: function(a, e, c) {
                var h = this;
                a.eachEdge(function(b, g) {
                    b = e.getRenderedConnection(g.getId());
                    var m = c.getEdgeType(g.data); (m = m ? "".concat("c-state", "-").concat(h.id, "-").concat(m) : null) && b.removeType(m, g.data);
                    h.state["*"] && b.removeType("".concat("c-state", "-").concat(h.id));
                    h._portStateOperation(g, b, g.source, 0, Pc.removeType, c);
                    h._portStateOperation(g, b, g.target, 1, Pc.removeType, c)
                });
                a.eachNode(function(b, g) {
                    b = (b = c.getNodeType(g.data)) ? h.state[b] : null;
                    g = e.getRenderedVertex(g.id);
                    b && b.cssClass && ta(g, b.cssClass);
                    h.state["*"] && ta(g, h.state["*"].cssClass)
                });
                a.eachGroup(function(b, g) {
                    b = (b = c.getNodeType(g.data)) ? h.state[b] : null;
                    g = e.getRenderedVertex(g.id);
                    b && b.cssClass && ta(g, b.cssClass);
                    h.state["*"] && ta(g, h.state["*"].cssClass)
                })
            }
        }]),
        k
    } (),
    Yj = "anchor anchors cssClass connector paintStyle hoverPaintStyle endpoint endpoints".split(" "),
    Mb,
    Vl = function() {
        function k(a, e, c) {
            var h;
            if (Aa(this, k), D(this, "_states", {}), D(this, "defMap", {
                nodes: new Map,
                edges: new Map,
                groups: new Map,
                ports: new Map
            }), D(this, "nodes", void 0), D(this, "edges", void 0), D(this, "groups", void 0), D(this, "ports", void 0), e = e || {},
            this.nodes = e.nodes || {},
            this.edges = e.edges || {},
            this.ports = e.ports || {},
            this.groups = e.groups || {},
            void 0 !== c) {
                for (r in e.edges) {
                    if ((a = this.getEdgeDefinition(r)).overlays) for (h = 0; h < a.overlays.length; h++) {
                        var b = a.overlays[h];
                        if (null != b.type && null != b.options) {
                            var g = b.options,
                            m;
                            for (m in g.events) g.events[m] = function(u, v) {
                                return function(w) {
                                    u.call(v, {
                                        overlay: w.overlay,
                                        e: w.e,
                                        connection: w.overlay.component,
                                        edge: w.overlay.component.edge
                                    })
                                }
                            } (g.events[m], b)
                        }
                    }
                    c.registerConnectionType(r, a)
                }
                for (h in e.ports) {
                    var r = this.getPortDefinition(h);
                    c.registerEndpointType(h, r)
                }
            }
            if (e.states) for (var t in e.states) this._states[t] = new Ul(t, e.states[t], c)
        }
        return Ia(k, [{
            key: "getEdgeDefinition",
            value: function(a) {
                if (null == a) return null;
                if (this.defMap.edges.has(a)) return this.defMap.edges.get(a);
                var e = Od([a, "default"], this.edges);
                if (null != e.label) {
                    e.overlays = e.overlays || [];
                    var c = {
                        type: Fb.type,
                        options: {
                            id: "label",
                            label: e.label
                        }
                    };
                    e.labelClass && (c.options.cssClass = e.labelClass);
                    e.labelLocation && (c.options.location = e.labelLocation);
                    e.labelLocationAttribute && (c.options.labelLocationAttribute = e.labelLocationAttribute);
                    e.overlays.push(c);
                    delete e.label
                }
                return delete e.parent,
                this.defMap.edges.set(a, e),
                e
            }
        },
        {
            key: "getNodeDefinition",
            value: function(a) {
                if (null == a) return null;
                if (this.defMap.nodes.has(a)) return this.defMap.nodes.get(a);
                var e = Od([a, "default"], this.nodes, Se);
                return delete e.parent,
                this.defMap.nodes.set(a, e),
                e
            }
        },
        {
            key: "getPortDefinition",
            value: function(a) {
                if (null == a) return null;
                if (this.defMap.ports.has(a)) return this.defMap.ports.get(a);
                var e = Od([a, "default"], this.ports, Se);
                return delete e.parent,
                this.defMap.ports.set(a, e),
                e
            }
        },
        {
            key: "getGroupDefinition",
            value: function(a) {
                if (null == a) return null;
                if (this.defMap.groups.has(a)) return this.defMap.groups.get(a);
                var e = Od([a, "default"], this.groups, Se);
                return delete e.parent,
                this.defMap.groups.set(a, e),
                e
            }
        },
        {
            key: "getState",
            value: function(a) {
                return this._states[a]
            }
        }]),
        k
    } (),
    Wl = function() {
        function k(a, e) {
            Aa(this, k);
            this.path = a;
            this.surface = e
        }
        return Ia(k, [{
            key: "getVertexCount",
            value: function() {
                return this.path.getVertexCount()
            }
        },
        {
            key: "getEdgeCount",
            value: function() {
                return this.path.getEdgeCount()
            }
        },
        {
            key: "setVisible",
            value: function(a) {
                this.surface.setVisible(this.path, a)
            }
        },
        {
            key: "addVertexClass",
            value: function(a) {
                var e = this;
                this.path.eachVertex(function(c, h) {
                    e.surface.addClass(h, a)
                })
            }
        },
        {
            key: "removeVertexClass",
            value: function(a) {
                var e = this;
                this.path.eachVertex(function(c, h) {
                    e.surface.removeClass(h, a)
                })
            }
        },
        {
            key: "addEdgeClass",
            value: function(a) {
                var e = this;
                this.path.eachEdge(function(c, h) {
                    e.surface.connMap[h.getId()].addClass(a)
                })
            }
        },
        {
            key: "removeEdgeClass",
            value: function(a) {
                var e = this;
                this.path.eachEdge(function(c, h) {
                    e.surface.connMap[h.getId()].removeClass(a)
                })
            }
        },
        {
            key: "addClass",
            value: function(a) {
                this.addVertexClass(a);
                this.addEdgeClass(a)
            }
        },
        {
            key: "removeClass",
            value: function(a) {
                this.removeVertexClass(a);
                this.removeEdgeClass(a)
            }
        }]),
        k
    } (); !
    function(k) {
        k.PAN = "pan";
        k.SELECT = "select";
        k.DISABLED = "disabled"
    } (Mb || (Mb = {}));
    var Xl = "canvasClick canvasDblClick contextmenu node:added node:removed node:render group:added group:removed group:move:end group:member:added group:member:removed group:collapse group:expand group:relayout group:resize node:move:start node:move:end port:added node:move port:removed edge:added edge:added edge:typeChanged dataLoadEnd anchor:changed objectRepainted modeChanged lasso:end pan zoom relayout click tap dbltap state:restore node:visibility afterLayoutRefresh destroy rotate".split(" "),
    Yl = function c(a, e) {
        Aa(this, c);
        this.gridProfile = e;
        D(this, "afterGroupCollapse", void 0);
        D(this, "afterGroupExpand", void 0);
        D(this, "afterGroupResize", void 0);
        D(this, "afterGroupShrink", void 0);
        D(this, "afterGroupGrow", void 0);
        D(this, "afterLayout", void 0);
        D(this, "afterDrag", void 0);
        D(this, "constant", void 0);
        D(this, "constrainToViewport", void 0);
        D(this, "repositionDraggedElement", void 0);
        D(this, "grid", void 0);
        null != a && (this.afterDrag = !0 === a.afterDrag, this.constant = !0 === a.constant, this.constrainToViewport = !0 === a.constrainToViewport, this.repositionDraggedElement = !0 === a.repositionDraggedElement, this.afterLayout = !0 === a.afterLayout, this.afterGroupResize = !0 === a.afterGroupResize, this.afterGroupShrink = !0 === a.afterGroupShrink || this.afterGroupResize && !1 !== a.afterGroupShrink, this.afterGroupGrow = !0 === a.afterGroupGrow || this.afterGroupResize && !1 !== a.afterGroupGrow, this.afterGroupCollapse = !0 === a.afterGroupCollapse, this.afterGroupExpand = !0 === a.afterGroupExpand, this.constant && this.afterDrag && (this.constant = !1), this.constant && (this.repositionDraggedElement = !1))
    },
    Zl = function c(e) {
        Aa(this, c);
        D(this, "grid", void 0);
        D(this, "snap", !1);
        D(this, "fitGroupsToGrid", !1);
        null != e && (this.snap = !0 === e.snap, this.grid = e.size, this.fitGroupsToGrid = !1 !== e.fitGroupsToGrid)
    },
    rf = function(e) {
        function c(b, g) {
            var m;
            Aa(this, c); (m = h.call(this)).templateRenderer = g;
            D(U(m), "_debug", void 0);
            D(U(m), "magnetizeProfile", void 0);
            D(U(m), "gridProfile", void 0);
            D(U(m), "viewport", void 0);
            D(U(m), "_layoutMap", new Map);
            D(U(m), "dataSource", void 0);
            D(U(m), "toolkitInstance", void 0);
            D(U(m), "_layout", void 0);
            D(U(m), "container", void 0);
            D(U(m), "containerId", void 0);
            D(U(m), "containerElement", void 0);
            D(U(m), "canvasElement", void 0);
            D(U(m), "_storePositionsInModel", void 0);
            D(U(m), "currentStates", []);
            D(U(m), "decorators", void 0);
            D(U(m), "vertexList", []);
            D(U(m), "connMap", {});
            D(U(m), "unrenderedEdges", []);
            D(U(m), "nodeRenderer", void 0);
            D(U(m), "portRenderer", void 0);
            D(U(m), "groupRenderer", void 0);
            D(U(m), "_suspendRendering", void 0);
            D(U(m), "_refreshAutomatically", void 0);
            D(U(m), "objectFilter", void 0);
            D(U(m), "_modelTopAttribute", void 0);
            D(U(m), "_modelLeftAttribute", void 0);
            D(U(m), "elementsDraggable", void 0);
            D(U(m), "enhancedView", void 0);
            D(U(m), "dragGroupAssigner", void 0);
            D(U(m), "_ignoreToolkitEvents", !1);
            D(U(m), "view", void 0);
            D(U(m), "dragOptions", void 0);
            D(U(m), "refreshLayoutOnEdgeConnect", void 0);
            D(U(m), "jsplumb", void 0);
            D(U(m), "id", void 0);
            D(U(m), "panZoom", void 0);
            D(U(m), "contentBounds", null);
            D(U(m), "plugins", void 0);
            D(U(m), "pluginMap", new Map);
            D(U(m), "wheelReverse", void 0);
            D(U(m), "directRender", void 0);
            D(U(m), "zoomToFitOnLoad", void 0);
            D(U(m), "mode", Mb.PAN);
            D(U(m), "autoExitSelectMode", !0);
            D(U(m), "_pendingDragGroupAssignments", []);
            D(U(m), "_boundToolkitEvents", []);
            g = R(b.defaults || {},
            {
                container: b.container,
                managedElementsSelector: wb("data-jtk-managed", "data-jtk-port")
            });
            if (m.jsplumb = b.jsPlumbInstance || Qj(g), m.viewport = m.jsplumb.viewport, m.decorators = Zj(b.decorators, U(m), b.container), m._debug = !0 === b.debug, m.container = b.container, m.dataSource = b.dataSource, m.toolkitInstance = b.toolkitInstance, m.containerElement = m.container, m.containerId = m.jsplumb.getId(m.containerElement), m.dragOptions = b.dragOptions || {},
            m.refreshLayoutOnEdgeConnect = !0 === b.refreshLayoutOnEdgeConnect, m.elementsDraggable = !1 !== b.elementsDraggable, m._suspendRendering = !1, m._refreshAutomatically = !1 !== b.refreshAutomatically, m.enhancedView = !1 !== b.enhancedView, m.dragGroupAssigner = b.assignDragGroup, m._modelLeftAttribute = b.modelLeftAttribute || La, m._modelTopAttribute = b.modelTopAttribute || wa, m._storePositionsInModel = !1 !== b.storePositionsInModel, m.objectFilter = b.objectFilter ||
            function(u) {
                return ! 0
            },
            m.gridProfile = new Zl(b.grid), m.magnetizeProfile = new Yl(b.magnetize, m.gridProfile), m._layout = od.get(Xd.type, {
                adapter: new Pi(U(m)),
                toolkit: m.toolkitInstance,
                container: b.container,
                options: {}
            }), m._storePositionsInModel = !1 !== b.storePositionsInModel, m.jsplumb.bind("beforeStartDetach", m.beforeStartDetach.bind(U(m))), m.jsplumb.bind("beforeDetach", m.beforeDetach.bind(U(m))), m.jsplumb.bind("beforeDrag", m.beforeDrag.bind(U(m))), m.jsplumb.bind("beforeDrop", m.beforeDrop.bind(U(m))), b.events) for (var r in b.events) m.bind(r, b.events[r]);
            if (b.interceptors) for (var t in b.interceptors) m.bind(t, b.interceptors[t]);
            m.setView(b.view);
            m._setSelectors();
            m._bindToJsPlumb();
            m._bindToolkitEvents();
            m.nodeRenderer = m.createRenderer("node", m.dataSource.getNodeId.bind(m.dataSource), m.dataSource.getNodeType.bind(m.dataSource));
            m.portRenderer = m.createRenderer("port", m.dataSource.getPortId.bind(m.dataSource), m.dataSource.getPortType.bind(m.dataSource));
            m.groupRenderer = m.createRenderer("group", m.dataSource.getNodeId.bind(m.dataSource), m.dataSource.getNodeType.bind(m.dataSource));
            m.id = b.id || fa();
            m.canvasElement = m._createElement({
                position: "relative",
                width: "50px",
                height: "50px",
                left: 0,
                top: 0,
                clazz: "jtk-surface-canvas"
            },
            m.containerElement);
            m.jsplumb.setContainer(m.canvasElement);
            null != m.dragOptions.filter && m.jsplumb.addDragFilter(m.dragOptions.filter, !0);
            null != m.gridProfile.grid && m.jsplumb.setDragGrid(m.gridProfile.grid);
            m.directRender = !0 === b.directRender;
            m.wheelReverse = !0 === b.wheelReverse;
            m.dragOptions = b.dragOptions || {};
            sa(m.containerElement, "jtk-surface");
            m.directRender && sa(m.containerElement, "jtk-surface-direct-render"); ! 1 === b.enablePan && sa(m.containerElement, "jtk-surface-nopan");
            r = function(u, v, w) {
                m.jsplumb.on(m.containerElement, u,
                function(z) {
                    var y = z.srcElement || z.target;
                    y !== m.containerElement && y !== m.canvasElement || m.fire(2 === z.button && null != w ? w: v, U(m), z)
                })
            };
            r("tap", "canvasClick", "contextmenu");
            r("dbltap", "canvasDblClick");
            m.zoomToFitOnLoad = !0 === b.zoomToFit;
            m.panZoom = new Qi(U(m), {
                viewport: m.viewport,
                viewportElement: m.containerElement,
                canvasElement: m.canvasElement,
                consumeRightClick: b.consumeRightClick,
                idFunction: function(u) {
                    return m.jsplumb.getId(u)
                },
                padding: b.padding,
                panDistance: b.panDistance,
                directRender: m.directRender,
                enablePan: !m.directRender && !1 !== b.enablePan,
                enableWheelZoom: !m.directRender && !1 !== b.enableWheelZoom,
                wheelSensitivity: b.wheelSensitivity,
                wheelReverse: m.wheelReverse,
                wheelZoomMetaKey: b.wheelZoomMetaKey,
                wheelPan: b.wheelPan,
                wheelFilter: b.wheelFilter ?
                function(u) {
                    return ! Bb(u.srcElement || u.target, b.wheelFilter)
                }: null,
                enableAnimation: b.enableAnimation,
                clamp: b.clamp,
                clampToBackground: b.clampToBackground,
                clampToBackgroundExtents: b.clampToBackgroundExtents,
                events: {
                    pan: function(u, v, w, z, y) {
                        m.fire("pan", {
                            x: u,
                            y: v,
                            zoom: w,
                            oldZoom: z,
                            event: y
                        })
                    },
                    zoom: function(u, v, w, z, y) {
                        m.jsplumb.setZoom(w);
                        m.fire("zoom", {
                            x: u,
                            y: v,
                            zoom: w,
                            oldZoom: z,
                            event: y
                        })
                    },
                    mousedown: function() {
                        m.addClass(m.containerElement, "jtk-surface-panning");
                        m.addClass(document.body, "jtk-drag-select-defeat")
                    },
                    mouseup: function() {
                        m.removeClass(m.containerElement, "jtk-surface-panning");
                        m.removeClass(document.body, "jtk-drag-select-defeat")
                    }
                },
                zoom: b.zoom,
                zoomRange: b.zoomRange
            });
            m.autoExitSelectMode = !1 !== b.autoExitSelectMode;
            r = b.plugins || [];
            return m.plugins = [],
            P(r,
            function(u) {
                m.addPlugin(u)
            }),
            m.bind("relayout",
            function() {
                m.panZoom.relayout(m._layout._getExtents())
            }),
            m.bind("node:removed",
            function(u) {
                m.panZoom.remove(u.el)
            }),
            m.bind("group:removed",
            function(u) {
                if (m.panZoom.remove(u.el), !1 === u.childrenRemoved) for (var v = 0; v < u.children.length; v++) {
                    var w = m.jsplumb.getManagedElement(u.children[v].id);
                    w && m.panZoom.restore(w)
                }
            }),
            m.jsplumb.bind("drag:start",
            function(u) {
                if (m.elementsDraggable && !m.panZoom.isPinchZooming() && m.mode !== Mb.DISABLED) {
                    m.toolkitInstance.openTransaction();
                    m.contentBounds = m.panZoom.getBoundsInfo();
                    sa(m.containerElement, "jtk-surface-element-dragging");
                    P(m.containerElement.querySelectorAll(".jtk-most-recently-dragged"),
                    function(w) {
                        ta(w, "jtk-most-recently-dragged")
                    });
                    var v = m.getModelObjectFromElement(u.el);
                    return m.fire("node:move:start", {
                        domEl: u.el,
                        pos: Re(u.el),
                        elementId: m.jsplumb.getId(u.el),
                        originalPosition: u.originalPosition,
                        vertex: v
                    }),
                    {
                        vertex: v
                    }
                }
                return ! 1
            }),
            m.jsplumb.bind("drag:move",
            function(u) {
                var v = u.payload.vertex;
                u = {
                    el: u.el,
                    vertex: v,
                    pos: u.pos,
                    e: u.e,
                    type: v.objectType,
                    originalPosition: u.originalPosition,
                    renderer: U(m)
                }; ! m.magnetizeProfile.constant || Sb(u.vertex) || Tb(u.vertex) || m._setMagnetizedPosition(u.vertex.id, u.pos.x, u.pos.y, !0, m._layout);
                m.fire("node:move", u)
            }),
            m.jsplumb.bind("drag:stop",
            function(u) {
                try {
                    var v = [],
                    w = [],
                    z = new Map;
                    ta(m.containerElement, "jtk-surface-element-dragging");
                    P(m.containerElement.querySelectorAll(".jtk-most-recently-dragged"),
                    function(y) {
                        ta(y, "jtk-most-recently-dragged")
                    });
                    P(u.elements,
                    function(y) {
                        sa(y.el, "jtk-most-recently-dragged");
                        var E = m.getModelObjectFromElement(y.el);
                        if (null != E && (ka(E) || ra(E))) {
                            var F = y.pos;
                            U(m);
                            var M = Sb(E) || Tb(E);
                            y.redrawResult.c.forEach(function(X) {
                                var da = X.edge;
                                null != da && null != da.geometry && m.dataSource.setEdgeGeometry(da, X.connector.exportGeometry(), U(m))
                            });
                            var S = M ? m._layoutMap.get(E.group.id) : m._layout;
                            S.getPosition(E.id);
                            if (null == y.dropGroup) if (m.magnetizeProfile.afterDrag && !M) v.push({
                                id: E.id,
                                x: F.x,
                                y: F.y
                            });
                            else if (w.push({
                                id: E.id,
                                x: F.x,
                                y: F.y,
                                layout: S
                            }), M) y = E.group,
                            E = m.view.getGroupDefinition(m.dataSource.getNodeType(y.data)),
                            z.set(y.id, [y, E])
                        }
                    });
                    P(w,
                    function(y) {
                        m._setDirectPosition(y.id, y.x, y.y, !1, y.layout)
                    });
                    z.forEach(function(y) {
                        m._autoSizeAGroup(y[0], y[1], null, !1)
                    });
                    m._setMagnetizedPositions(v, !m.magnetizeProfile.repositionDraggedElement, !0, m._layout)
                } catch(y) {
                    pa("Could not process dragged vertex", y)
                } finally {
                    m.toolkitInstance.commitTransaction()
                }
            }),
            b.layout && m.setLayout(b.layout, !0),
            m.dataSource.setSuspendGraph(!0),
            m._loadStartFn(),
            m._loadExistingData(b),
            m.dataSource.setSuspendGraph(!1),
            m._loadEndFn(),
            m
        }
        Vb(c, $e);
        var h = Wb(c);
        return Ia(c, [{
            key: "_updateMovedElements",
            value: function(b, g) {
                for (var m in b) {
                    var r = this.jsplumb.getManagedElement(m);
                    this.setAbsolutePosition(r, b[m].current);
                    this.repaint(r);
                    var t = this.toolkitInstance.getVertex(m);
                    r = {
                        el: r,
                        vertex: t,
                        e: g,
                        type: t.objectType,
                        renderer: this,
                        pos: b[m].current,
                        originalPosition: b[m].original
                    };
                    if (ka(t) ? this.fire("node:move:end", r) : ra(t) && this.fire("group:move:end", r), !1 !== this._storePositionsInModel) {
                        r = A({},
                        t.data);
                        this.storePositionInModel({
                            obj: t,
                            id: m,
                            leftAttribute: this._modelLeftAttribute,
                            topAttribute: this._modelTopAttribute
                        });
                        var u = {};
                        u[this._modelLeftAttribute] = b[m].current.x;
                        u[this._modelTopAttribute] = b[m].current.y;
                        ka(t) ? this.toolkitInstance.fire("node:updated", {
                            vertex: t,
                            updates: u,
                            originalData: r,
                            reason: "moved"
                        },
                        null) : ra(t) && this.toolkitInstance.fire("group:updated", {
                            vertex: t,
                            updates: u,
                            originalData: r,
                            reason: "moved"
                        },
                        null)
                    }
                }
            }
        },
        {
            key: "_setMagnetizedPosition",
            value: function(b, g, m, r, t) {
                var u = A({},
                this._layout.getPosition(b)),
                v = {};
                return v[b] = {
                    original: u,
                    current: {
                        x: g,
                        y: m
                    }
                },
                A(v, t.setMagnetizedPosition(b, g, m, r, this.gridProfile.grid)),
                v[b].current.x === v[b].original.x && v[b].current.y === v[b].original.y && delete v[b],
                !0 === r ? this.setAbsolutePosition(this.jsplumb.getManagedElement(b), {
                    x: g,
                    y: m
                }) : v[b].original = u,
                this._updateMovedElements(v),
                v
            }
        },
        {
            key: "_setMagnetizedPositions",
            value: function(b, g, m, r) {
                var t = this,
                u = {};
                return 0 < b.length && P(b,
                function(v) {
                    A(u, t._setMagnetizedPosition(v.id, v.x, v.y, !t.magnetizeProfile.repositionDraggedElement, r))
                }),
                u
            }
        },
        {
            key: "_setDirectPosition",
            value: function(b, g, m, r, t) {
                b = t.setPosition(b, g, m, r);
                this._updateMovedElements(b)
            }
        },
        {
            key: "getNodes",
            value: function() {
                return this.vertexList.filter(ka)
            }
        },
        {
            key: "getGroups",
            value: function() {
                return this.vertexList.filter(ra)
            }
        },
        {
            key: "setView",
            value: function(b) {
                this.view = new Vl(this.dataSource.getModel(), b, this.jsplumb)
            }
        },
        {
            key: "_ensureTemplate",
            value: function(b) {
                return null != b && b.template && null == b.templateId && this.templateRenderer.addTemplate && (b.templateId = fa(), this.templateRenderer.addTemplate(b.templateId, b.template)),
                b
            }
        },
        {
            key: "getGroupDefinition",
            value: function(b) {
                return this._ensureTemplate(this.view.getGroupDefinition(this.dataSource.getNodeType(b.data)))
            }
        },
        {
            key: "getPortDefinition",
            value: function(b) {
                return this._ensureTemplate(this.view.getPortDefinition(this.dataSource.getPortType(b.data)))
            }
        },
        {
            key: "getNodeDefinition",
            value: function(b) {
                return this._ensureTemplate(this.view.getNodeDefinition(this.dataSource.getNodeType(b.data)))
            }
        },
        {
            key: "_setSelectors",
            value: function() {
                var b = this,
                g = function(m, r, t) {
                    var u = m.getAttribute("data-jtk-port-id") || (r ? m.getAttribute("data-jtk-source-port") : t ? m.getAttribute("data-jtk-target-port") : null) || m.getAttribute("data-jtk-port") || (r ? m.getAttribute("data-jtk-source-port-id") : t ? m.getAttribute("data-jtk-target-port-id") : null);
                    t = (r ? m.getAttribute("data-jtk-source-port-type") : t ? m.getAttribute("data-jtk-target-port-type") : null) || m.getAttribute("data-jtk-port-type");
                    var v = m.getAttribute("data-jtk-edge-type");
                    r = {
                        portId: u,
                        portType: t,
                        edgeType: v
                    };
                    v = Q({
                        edgeType: v
                    });
                    var w = sb(m, wb("data-jtk-managed"), b.jsplumb.getContainer(), null == u);
                    r.vertexId = (w || m).getAttribute("data-jtk-managed"); (m = w = b.toolkitInstance.getVertex(r.vertexId)) && (u = w.getPort(u)) && (t = b.toolkitInstance.getPortType(u), m = u);
                    null != t && (u = b.view.getPortDefinition(t), null != u && A(v, u));
                    return v.parameters = Q(r),
                    null != m && (v.data = m.data),
                    v
                };
                this.jsplumb.addSourceSelector(Xb("data-jtk-source", "true"), {
                    parameterExtractor: function(m, r) {
                        return g(r, !0, !1)
                    },
                    parentSelector: wb("data-jtk-port", "data-jtk-source-port", "data-jtk-target-port")
                });
                this.jsplumb.addTargetSelector(Xb("data-jtk-target", "true"), {
                    parameterExtractor: function(m, r) {
                        return g(m, !1, !0)
                    },
                    parentSelector: wb("data-jtk-port", "data-jtk-source-port", "data-jtk-target-port")
                })
            }
        },
        {
            key: "addPlugin",
            value: function(b) {
                var g = J(b) ? b: b.type;
                b = J(b) ? {}: b.options || {};
                b.viewport = this.viewport;
                var m = de.get(g);
                if (null != m) return m.initialise(this, b),
                this.plugins.push(m),
                this.pluginMap.set(g, m),
                m
            }
        },
        {
            key: "getPlugin",
            value: function(b) {
                return this.pluginMap.get(b)
            }
        },
        {
            key: "setHoverSuspended",
            value: function(b) {
                this.jsplumb.hoverSuspended = b
            }
        },
        {
            key: "setMode",
            value: function(b, g) {
                var m, r = this,
                t = (D(m = {},
                Mb.PAN,
                function() {
                    r.panZoom.setEnabled(!0)
                }), D(m, Mb.SELECT,
                function() {
                    r.jsplumb.clearDragSelection();
                    r.panZoom.setEnabled(!1)
                }), D(m, Mb.DISABLED,
                function() {
                    r.jsplumb.clearDragSelection();
                    r.panZoom.setEnabled(!1)
                }), m);
                if (!t[b]) throw new TypeError("Surface: unknown mode '" + b + "'");
                this.mode = b;
                t[b]();
                "select" !== b || g || this.toolkitInstance.clearSelection();
                this.fire("modeChanged", b)
            }
        },
        {
            key: "_selectEdges",
            value: function(b, g) {
                var m = A({},
                b);
                m.source = this.getObjectInfo(b.source).obj;
                m.target = this.getObjectInfo(b.target).obj;
                m.element = this.getObjectInfo(b.element).obj;
                b = this.toolkitInstance[g](m);
                b = this.getConnectionsForEdges(b);
                return this.jsplumb.select({
                    connections: b
                })
            }
        },
        {
            key: "selectEdges",
            value: function(b) {
                return this._selectEdges(b, "getEdges")
            }
        },
        {
            key: "selectAllEdges",
            value: function(b) {
                return this._selectEdges(b, "getAllEdges")
            }
        },
        {
            key: "_createElement",
            value: function(b, g) {
                var m = {
                    width: b.width,
                    height: b.height,
                    position: b.position || "absolute"
                },
                r = {};
                null != b.display && (m.display = b.display);
                null != b.id && (r.id = b.id);
                null != b.top && (m.top = b.top + "px");
                null != b.left && (m.left = b.left + "px");
                null != b.right && (m.right = b.right + "px");
                null != b.bottom && (m.bottom = b.bottom + "px");
                b = Zc(null, b.type || "div", m, b.clazz, r);
                return null != g && this.jsplumb._appendElement(b, g),
                b
            }
        },
        {
            key: "_fireNodeMovedEvent",
            value: function(b, g, m, r, t, u) {
                if (u || g !== r || m !== t) b = this.getObjectInfo(b),
                b.el && this.fire("node:move:end", {
                    el: b.el,
                    id: b.id,
                    pos: {
                        x: g,
                        y: m
                    },
                    vertex: b.obj,
                    e: null,
                    type: b.obj.objectType,
                    originalPosition: {
                        x: r,
                        y: t
                    },
                    renderer: this
                })
            }
        },
        {
            key: "getOffset",
            value: function(b) {
                return this.jsplumb.getOffset(b)
            }
        },
        {
            key: "setPosition",
            value: function(b, g, m) {
                this.toolkitInstance.openTransaction(Jc);
                try {
                    var r = this._setPosition({
                        vertex: b,
                        x: g,
                        y: m,
                        doRevalidate: !0
                    });
                    this.gridProfile.snap && A(r, this.snapToGrid(b));
                    var t = this.getObjectInfo(b);
                    if (t.obj) {
                        var u = r[t.id];
                        this._fireNodeMovedEvent(b, u.current.x, u.current.y, u.original.x, u.original.y)
                    }
                } catch(v) {
                    pa("Exception thrown when setting position", v)
                } finally {
                    this.toolkitInstance.commitTransaction()
                }
            }
        },
        {
            key: "setAbsolutePosition",
            value: function(b, g) {
                ob(b, g.x, g.y)
            }
        },
        {
            key: "setVertexPosition",
            value: function(b, g, m) {
                this.toolkitInstance.openTransaction(Jc);
                this._setPosition({
                    vertex: b,
                    x: g,
                    y: m
                });
                b = this.getObjectInfo(b);
                b.el && this.jsplumb.revalidate(b.el);
                this.toolkitInstance.commitTransaction()
            }
        },
        {
            key: "getPosition",
            value: function(b) {
                if (this._layout) return b = this.getObjectInfo(b).id,
                this._layout.getPosition(b)
            }
        },
        {
            key: "addClass",
            value: function(b, g) {
                var m = this;
                b.constructor === Db ? (b.eachVertex(function(r, t) {
                    return m.addClass(t, g)
                }), b.eachEdge(function(r, t) {
                    return m.addClass(t, g)
                })) : this._classOperation(b, g, this.jsplumb.addClass)
            }
        },
        {
            key: "_classOperation",
            value: function(b, g, m) {
                var r = this,
                t = function(u) {
                    var v = r.getObjectInfo(u);
                    v.el ? m(v.el, g) : xc(u) && m(u, g)
                };
                null != b && (hc(b) ? m(b, g) : rg(b) ? P(b,
                function(u) {
                    return t(u)
                }) : t(b))
            }
        },
        {
            key: "removeClass",
            value: function(b, g) {
                var m = this;
                b.constructor === Db ? (b.eachVertex(function(r, t) {
                    return m.removeClass(t, g)
                }), b.eachEdge(function(r, t) {
                    return m.removeClass(t, g)
                })) : this._classOperation(b, g, this.jsplumb.removeClass)
            }
        },
        {
            key: "toggleClass",
            value: function(b, g) {
                var m = this;
                b.constructor === Db ? (b.eachVertex(function(r, t) {
                    return m.toggleClass(t, g)
                }), b.eachEdge(function(r, t) {
                    return m.toggleClass(t, g)
                })) : this._classOperation(b, g, this.jsplumb.toggleClass)
            }
        },
        {
            key: "hasClass",
            value: function(b, g) {
                if (null != b) {
                    var m = this.getObjectInfo(b);
                    return m.el ? this.jsplumb.hasClass(m.el, g) : !!xc(b) && this.jsplumb.hasClass(b, g)
                }
            }
        },
        {
            key: "on",
            value: function(b, g, m, r) {
                this.jsplumb.on(b, g, m, r)
            }
        },
        {
            key: "off",
            value: function(b, g, m) {
                this.jsplumb.off(b, g, m.__tkWrapper || m)
            }
        },
        {
            key: "bindModelEvent",
            value: function(b, g, m) {
                var r = this,
                t = function(u, v) {
                    m(u, v, r.getObjectInfo(v))
                };
                m.__tkWrapper = t;
                this.jsplumb.on(this.canvasElement, b, g, t)
            }
        },
        {
            key: "unbindModelEvent",
            value: function(b, g) {
                null != g.__tkWrapper && this.jsplumb.off(this.canvasElement, b, g.__tkWrapper)
            }
        },
        {
            key: "getCoordinates",
            value: function(b) {
                if (this._layout) {
                    var g = this.getObjectInfo(b);
                    return g.obj ? (b = this.jsplumb.getSize(g.el), g = (Sb(g.obj) || Tb(g.obj) ? this._layoutMap.get(g.obj.group.id) : this._layout).getPosition(g.id), {
                        x: g.x,
                        y: g.y,
                        w: b.w,
                        h: b.h
                    }) : {
                        x: 0,
                        y: 0,
                        w: 0,
                        h: 0
                    }
                }
            }
        },
        {
            key: "snapToGrid",
            value: function(b, g) {
                var m;
                if (g = g || this.gridProfile.grid) return null != b && (b = this.getObjectInfo(b), b.obj && (m = b.obj.id)),
                g = this._layout.snapToGrid(g, m),
                this._updateMovedElements(g),
                g
            }
        },
        {
            key: "fixElement",
            value: function(b, g, m) {
                this.panZoom.fixElement(b, g, m)
            }
        },
        {
            key: "floatElement",
            value: function(b, g) {
                this.panZoom.floatElement(b, g)
            }
        },
        {
            key: "zoomToFit",
            value: function(b) {
                this.panZoom.zoomToFit(b)
            }
        },
        {
            key: "zoomToFitIfNecessary",
            value: function(b) {
                this.panZoom.zoomToFitIfNecessary(b)
            }
        },
        {
            key: "zoomToElements",
            value: function(b) {
                this.panZoom.zoomToElements(b)
            }
        },
        {
            key: "mapEventLocation",
            value: function(b, g) {
                return this.panZoom.mapEventLocation(b, g)
            }
        },
        {
            key: "centerContent",
            value: function(b) {
                this.panZoom.centerContent(b)
            }
        },
        {
            key: "zoomToSelection",
            value: function(b) {
                var g = this,
                m = (b = b || {}).selection || (b.filter ? g.toolkitInstance.filter(b.filter) : g.toolkitInstance.getSelection()),
                r = [];
                m.eachNode(function(t, u) {
                    r.push(g.getRenderedElement(u.id))
                });
                m.eachGroup(function(t, u) {
                    r.push(g.getRenderedElement(u.id))
                });
                0 < r.length && this.panZoom.zoomToElements({
                    elements: r,
                    fill: b.fill,
                    doNotZoomIfVisible: b.doNotZoomIfVisible,
                    doNotAnimate: b.doNotAnimate
                })
            }
        },
        {
            key: "getPath",
            value: function(b) {
                return new Wl(this.toolkitInstance.getPath(b), this)
            }
        },
        {
            key: "_append",
            value: function(b, g, m, r) {
                this.canvasElement.appendChild(b);
                this.panZoom.add(b, g, m, r)
            }
        },
        {
            key: "_getGroupDragArea",
            value: function(b) {
                return (b = this.jsplumb.getGroup(b.id)) ? this.jsplumb.getGroupContentArea(b) : null
            }
        },
        {
            key: "_doAssignDragGroup",
            value: function(b, g) {
                null != this.dragGroupAssigner && (this._suspendRendering ? this._pendingDragGroupAssignments.push([b, g]) : (g = this.dragGroupAssigner(g), null != g ? this.jsplumb.addToDragGroup(g, b) : this.jsplumb.removeFromDragGroup(b)))
            }
        },
        {
            key: "_assignPendingDragGroups",
            value: function() {
                if (null != this.dragGroupAssigner) for (var b = 0; b < this._pendingDragGroupAssignments.length; b++) this._doAssignDragGroup.apply(this, this._pendingDragGroupAssignments[b])
            }
        },
        {
            key: "assignToDragGroup",
            value: function() {
                for (var b = this,
                g = arguments.length,
                m = Array(g), r = 0; r < g; r++) m[r] = arguments[r];
                P(m,
                function(t) {
                    t = b.getObjectInfo(t);
                    t.el && b._doAssignDragGroup(t.el, t.obj)
                })
            }
        },
        {
            key: "removeFromDragGroup",
            value: function() {
                for (var b, g = this,
                m = arguments.length,
                r = Array(m), t = 0; t < m; t++) r[t] = arguments[t]; (b = this.jsplumb).removeFromDragGroup.apply(b, Lg(r.map(function(u) {
                    return g.getObjectInfo(u).el
                }).filter(function(u) {
                    return null != u
                })))
            }
        },
        {
            key: "addToDragGroup",
            value: function(b) {
                for (var g, m = this,
                r = arguments.length,
                t = Array(1 < r ? r - 1 : 0), u = 1; u < r; u++) t[u - 1] = arguments[u]; (g = this.jsplumb).addToDragGroup.apply(g, [b].concat(Lg(t.map(function(v) {
                    return m.getObjectInfo(v).el
                }).filter(function(v) {
                    return null != v
                }))))
            }
        },
        {
            key: "setGrid",
            value: function(b) {
                this.gridProfile.grid = b;
                this.jsplumb.setDragGrid(b)
            }
        },
        {
            key: "getGrid",
            value: function() {
                return this.gridProfile.grid
            }
        },
        {
            key: "getApparentCanvasLocation",
            value: function() {
                return this.panZoom.getApparentCanvasLocation()
            }
        },
        {
            key: "setApparentCanvasLocation",
            value: function(b, g) {
                return this.panZoom.setApparentCanvasLocation(b, g)
            }
        },
        {
            key: "getBoundsInfo",
            value: function() {
                return this.panZoom.getBoundsInfo()
            }
        },
        {
            key: "setZoom",
            value: function(b, g) {
                return this.panZoom.setZoom(b, g)
            }
        },
        {
            key: "setZoomRange",
            value: function(b, g) {
                return this.panZoom.setZoomRange(b, g)
            }
        },
        {
            key: "getZoomRange",
            value: function() {
                return this.panZoom.getZoomRange()
            }
        },
        {
            key: "getZoom",
            value: function() {
                return this.panZoom.getZoom()
            }
        },
        {
            key: "nudgeZoom",
            value: function(b, g) {
                return this.panZoom.nudgeZoom(b, g)
            }
        },
        {
            key: "nudgeWheelZoom",
            value: function(b, g) {
                this.panZoom.nudgeWheelZoom(b, g)
            }
        },
        {
            key: "getPan",
            value: function() {
                return this.panZoom.getPan()
            }
        },
        {
            key: "pan",
            value: function(b, g, m) {
                this.panZoom.pan(b, g, !m)
            }
        },
        {
            key: "setPan",
            value: function(b, g, m, r) {
                this.panZoom.setPan(b, g, m, r)
            }
        },
        {
            key: "setPanAndZoom",
            value: function(b, g, m, r) {
                this.setPan(b, g, r);
                this.setZoom(m, r)
            }
        },
        {
            key: "centerOnAndZoom",
            value: function(b, g, m) {
                b = this.getObjectInfo(b);
                null != b.el && this.panZoom.centerOnAndZoom(b.el, {
                    fillRatio: g,
                    doNotAnimate: m
                })
            }
        },
        {
            key: "centerOn",
            value: function(b) {
                b = this.getObjectInfo(b);
                null != b.el && this.panZoom.centerOn(b.el)
            }
        },
        {
            key: "centerOnHorizontally",
            value: function(b) {
                b = this.getObjectInfo(b);
                null != b.el && this.panZoom.centerOnHorizontally(b.el, {})
            }
        },
        {
            key: "centerOnVertically",
            value: function(b) {
                b = this.getObjectInfo(b);
                null != b.el && this.panZoom.centerOnVertically(b.el, {})
            }
        },
        {
            key: "setClamping",
            value: function(b) {
                this.panZoom.setClamping(b)
            }
        },
        {
            key: "isClamping",
            value: function() {
                return this.panZoom.isClamping()
            }
        },
        {
            key: "getContainer",
            value: function() {
                return this.jsplumb.getContainer()
            }
        },
        {
            key: "isInViewport",
            value: function(b, g) {
                return this.panZoom.isInViewport(b, g)
            }
        },
        {
            key: "fromPageLocation",
            value: function(b, g, m) {
                return this.panZoom.fromPageLocation(b, g, m)
            }
        },
        {
            key: "toPageLocation",
            value: function(b, g, m) {
                return this.panZoom.toPageLocation(b, g, m)
            }
        },
        {
            key: "findIntersectingVertices",
            value: function(b, g, m, r, t, u, v) {
                var w = this;
                return ! 0 === t && !0 === r && !0 === u ? [] : this.panZoom.findIntersectingElements(b, g, m,
                function(z, y, E) {
                    var F = w.toolkitInstance.getVertex(E);
                    return null != F ? (y = (z = ka(F)) && Sb(F), F = (E = ra(F)) && Tb(F), !(!0 === t && z || !0 === r && E || u && y || v && F)) : !1
                }).map(function(z) {
                    return {
                        enclosed: m,
                        id: z.id,
                        r: z.r,
                        v: w.toolkitInstance.getVertex(z.id),
                        el: w.getRenderedElement(z.id)
                    }
                })
            }
        },
        {
            key: "findIntersectingNodes",
            value: function(b, g, m, r) {
                return this.findIntersectingVertices(b, g, m, !0, !1, r, !0)
            }
        },
        {
            key: "findIntersectingGroups",
            value: function(b, g, m, r) {
                return this.findIntersectingVertices(b, g, m, !0, !1, !0, !0)
            }
        },
        {
            key: "repaintEverything",
            value: function() {
                this.jsplumb.repaintEverything()
            }
        },
        {
            key: "reload",
            value: function() {
                this.dataSource instanceof Db ? this.dataSource.reload() : console.log("JSPLUMB: Surface not rendering a selection, `reload` has no effect.")
            }
        },
        {
            key: "destroy",
            value: function() {
                for (var b, g = 0; g < this._boundToolkitEvents.length; g++) try {
                    b = this._boundToolkitEvents[g],
                    this.dataSource.unbind(b.event, b.fn)
                } catch(m) {
                    console.log("WARN: Could not unbind event " + b.event + " during destroy operation.")
                }
                this.panZoom.destroy();
                this.canvasElement.parentNode.removeChild(this.canvasElement);
                ta(this.containerElement, "jtk-surface");
                ta(this.containerElement, "jtk-surface-direct-render");
                ta(this.containerElement, "jtk-surface-nopan");
                P(this.plugins,
                function(m) {
                    m.destroy()
                });
                this.fire("destroy", this)
            }
        },
        {
            key: "_loadExistingData",
            value: function(b) {
                var g, m, r = this;
                b = 0;
                for (g = this.dataSource.getGroupCount(); b < g; b++) {
                    var t = this.dataSource.getGroupAt(b);
                    this.objectFilter(t) && this._doRenderGroup(t)
                }
                b = 0;
                for (g = this.dataSource.getNodeCount(); b < g; b++) t = this.dataSource.getNodeAt(b),
                this.objectFilter(t) && this._doRenderNode(t);
                var u = function(v) {
                    var w = r.dataSource.getAllEdgesFor(v);
                    for (m = 0; m < w.length; m++) if (ze(w[m].source) === v) {
                        var z = r.view.getEdgeDefinition(r.dataSource.getNodeType(w[m].data));
                        if (!z || !0 !== z.ignore) {
                            var y = r._prepareConnectionParams(w[m]);
                            if (null != y.source && null != y.target && (z = r._connect(y, w[m], z), null != z)) {
                                var E = z.connector;
                                y.geometry && E.importGeometry && E.importGeometry(y.geometry, z);
                                z.edge = w[m];
                                r.connMap[w[m].getId()] = z
                            }
                        }
                    }
                };
                b = 0;
                for (g = this.dataSource.getNodeCount(); b < g; b++) t = this.dataSource.getNodeAt(b),
                this.jsplumb.getManagedElement(t.id) && u(t);
                b = 0;
                for (g = this.dataSource.getGroupCount(); b < g; b++) t = this.dataSource.getGroupAt(b),
                this.jsplumb.getManagedElement(t.id) && u(t)
            }
        },
        {
            key: "fireNodeAdded",
            value: function(b) {
                this.fire("node:added", b)
            }
        },
        {
            key: "createRenderer",
            value: function(b, g, m) {
                var r = this;
                return function(t, u, v, w, z) {
                    g(u);
                    var y, E = m(u),
                    F = u;
                    if (r.enhancedView) {
                        F = A({},
                        w && w.parameters || {});
                        A(F, u);
                        var M = {};
                        for (y in F) F.hasOwnProperty(y) && null != F[y] && (F[y].constructor == Function ? M[y] = F[y](u) : M[y] = F[y]);
                        F = M
                    }
                    w && (u = w.templateId || "jtk-template-" + E, w.templateRenderer ? w.templateRenderer(u, F, r.dataSource, b, r, w, t, v, z) : r.templateRenderer.render(u, F, r.dataSource, b, r, w, t, v, z))
                }
            }
        },
        {
            key: "_handleClickOrTap",
            value: function(b, g, m) {
                var r = this.getModelObjectFromElement(b);
                if (null != r) {
                    var t = ka(r) ? this.getNodeDefinition(r) : ra(r) ? this.getGroupDefinition(r) : qa(r) ? this.getPortDefinition(r) : null;
                    t && t.events && t.events[m] && t.events[m]({
                        el: b,
                        obj: r,
                        e: g,
                        toolkit: this.dataSource,
                        renderer: this
                    })
                }
            }
        },
        {
            key: "_handleEndpointClick",
            value: function(b, g, m) {
                var r = this.getModelObjectFromEndpoint(b);
                if (null != r && qa(r)) {
                    var t = this.getPortDefinition(r);
                    t && t.events && t.events[m] && t.events[m]({
                        el: b,
                        obj: r,
                        e: g,
                        toolkit: this.dataSource,
                        renderer: this
                    })
                }
            }
        },
        {
            key: "_bindToJsPlumb",
            value: function() {
                var b = this;
                this.jsplumb.bind("connection",
                function(g) {
                    if (null == g.connection.edge) {
                        var m = g.sourceEndpoint.parameters,
                        r = g.targetEndpoint.parameters,
                        t = m.portId;
                        m = m.vertexId;
                        var u = r.portId;
                        r = r.vertexId;
                        var v = b.view.getPortDefinition(g.sourceEndpoint.parameters.portType || "default"),
                        w = null != v && v.edgeType ? v.edgeType: g.sourceEndpoint.parameters.edgeType || "default",
                        z = b.getModelObjectFromEndpoint(g.sourceEndpoint);
                        v = b.getModelObjectFromEndpoint(g.targetEndpoint);
                        var y = z.getFullId(),
                        E = v.getFullId(),
                        F = {
                            sourceVertexId: m,
                            sourcePortId: t,
                            targetVertexId: r,
                            targetPortId: u,
                            type: w,
                            source: z,
                            target: v,
                            sourceId: y,
                            targetId: E,
                            sourceType: z.objectType,
                            targetType: v.objectType
                        }; ! 1 === b.dataSource.edgeFactory(w, g.connection.getData() || {},
                        function(M) { (M = Qc(M, z, null, !0)).type = M.type || w;
                            F.edge = b.dataSource.addEdge({
                                source: y,
                                target: E,
                                cost: g.connection.cost,
                                directed: g.connection.directed,
                                data: M,
                                addedByMouse: !0
                            },
                            b);
                            b.connMap[F.edge.getId()] = g.connection;
                            g.connection.edge = F.edge;
                            M = b._prepareConnectionParams(F.edge);
                            g.connection.setType(["default", M.type].join(" "), M.data);
                            F.addedByMouse = !0;
                            F.connection = g.connection;
                            b.fire("edge:added", F)
                        },
                        function() {
                            b.jsplumb.deleteConnection(g.connection)
                        },
                        F) && b.jsplumb.deleteConnection(g.connection)
                    }
                });
                this.jsplumb.bind("connection:move",
                function(g) {
                    var m = b.getModelObjectFromEndpoint(g.newEndpoint);
                    b.whileIgnoringToolkitEvents(function() {
                        b.dataSource.edgeMoved(g.connection.edge, m, g.index)
                    })
                });
                this.jsplumb.bind("connection:detach",
                function(g) {
                    var m = g.connection.edge;
                    b.whileIgnoringToolkitEvents(function() {
                        b.dataSource.removeEdge(m)
                    });
                    var r = g.sourceEndpoint.parameters;
                    g = g.targetEndpoint.parameters;
                    var t = r.nodeId + (r.portId ? "." + r.portId: ""),
                    u = g.nodeId + (g.portId ? "." + g.portId: "");
                    b.fire("edge:added", {
                        sourceNodeId: r.vertexId,
                        targetNodeId: g.vertexId,
                        sourcePortId: r.portId,
                        targetPortId: g.portId,
                        sourceId: t,
                        targetId: u,
                        source: b.dataSource.getNode(t),
                        target: b.dataSource.getNode(u),
                        edge: m
                    })
                });
                this.jsplumb.bind("group:member:added",
                function(g) {
                    var m = b.getModelObjectFromElement(g.el);
                    if (null != m && (ka(m) || ra(m))) {
                        var r = null == g.sourceGroup ? null: b.dataSource.getGroup(g.sourceGroup.id),
                        t = b.dataSource.getGroup(g.group.id);
                        t && b.dataSource.addToGroup(m, t, r, g.pos, b)
                    }
                });
                this.jsplumb.bind("group:member:removed",
                function(g) {
                    var m = b.getModelObjectFromElement(g.el);
                    null != m && (ka(m) || ra(m)) && (g = null == g.targetGroup ? null: b.dataSource.getGroup(g.targetGroup.id), b.dataSource.removeFromGroup(m, !1, g, b))
                });
                this.jsplumb.bind("group:nested:removed",
                function(g) {
                    g = b.getModelObjectFromElement(g.child.el);
                    null != g && (ka(g) || ra(g)) && b.dataSource.removeFromGroup(g, !1, null, b)
                });
                this.jsplumb.bind("group:collapse",
                function(g) {
                    var m = null == g.group.group ? b._layout: b._layoutMap.get(g.group.group.id),
                    r = b.jsplumb.getSize(g.group.el);
                    if (m.setSize(g.group.id, r), !0 === b.magnetizeProfile.afterGroupCollapse) null == g.group.group ? b.gather(g.group.id) : (m = b.toolkitInstance.getGroup(g.group.id), null != m && (r = b.view.getGroupDefinition(b.dataSource.getNodeType(m.data)), b._autoSizeAGroup(m, r, null, !1))); (m = b.dataSource.getGroup(g.group.id)) && b.fire("group:collapse", {
                        group: m,
                        uigroup: g.group,
                        renderer: b
                    })
                });
                this.jsplumb.bind("group:expand",
                function(g) {
                    var m = null == g.group.group ? b._layout: b._layoutMap.get(g.group.group.id),
                    r = b.jsplumb.getSize(g.group.el);
                    if (m.setSize(g.group.id, r), !1 !== b.magnetizeProfile.afterGroupExpand) null == g.group.group ? b.magnetize(g.group.id) : (m = b.toolkitInstance.getGroup(g.group.id), null != m && (r = b.view.getGroupDefinition(b.dataSource.getNodeType(m.data)), b._autoSizeAGroup(m, r, null, !1))); (m = b.dataSource.getGroup(g.group.id)) && b.fire("group:expand", {
                        group: m,
                        uigroup: g.group,
                        renderer: b
                    })
                });
                P([wi, xi, Ei, yi, Ci, Bi, Ai, zi, Di],
                function(g) {
                    b.jsplumb.bind(g,
                    function(m, r) {
                        if (m.edge) {
                            var t = m.edge,
                            u = b.view.getEdgeDefinition(b.dataSource.getEdgeType(t.data)),
                            v = g.split(":")[1];
                            u && u.events && u.events[v] && u.events[v]({
                                edge: t,
                                e: r,
                                toolkit: b.dataSource,
                                renderer: b,
                                connection: m
                            })
                        }
                    })
                });
                P([[gf, "click"], [jf, "tap"], [hf, "dbltap"], [ni, "dblclick"], [oi, "mouseout"], [pi, "mouseover"], [qi, "mousemove"], [ri, "mouseup"], [si, "mousedown"], [ti, "contextmenu"]],
                function(g) {
                    g = Pe(g, 2);
                    var m = g[1];
                    b.jsplumb.bind(g[0],
                    function(r, t) {
                        b._handleClickOrTap(r, t, m)
                    })
                });
                P([[ui, "click"], [vi, "dblclick"]],
                function(g) {
                    g = Pe(g, 2);
                    var m = g[1];
                    b.jsplumb.bind(g[0],
                    function(r, t) {
                        b._handleEndpointClick(r, t, m)
                    })
                })
            }
        },
        {
            key: "whileIgnoringToolkitEvents",
            value: function(b) {
                this._ignoreToolkitEvents = !0;
                try {
                    b()
                } catch(g) {
                    console.log("An error occurred while ignoring Toolkit events", g)
                } finally {
                    this._ignoreToolkitEvents = !1
                }
            }
        },
        {
            key: "_connectionEdited",
            value: function(b) {
                var g = b.connector.exportGeometry();
                this.dataSource.setEdgeGeometry(b.edge, g, this)
            }
        },
        {
            key: "bind",
            value: function(b, g) {
                return - 1 === Xl.indexOf(b) ? this.jsplumb.bind(b, g) : Jg(ed(c.prototype), "bind", this).call(this, b, g),
                this
            }
        },
        {
            key: "rotate",
            value: function(b, g) {
                var m = this;
                b = this.getObjectInfo(b);
                b.el && (b.obj.data.rotation = g, this.jsplumb.rotate(b.el, g).c.forEach(function(r) {
                    var t = r.edge;
                    r = r.connector;
                    r.geometry && r.exportGeometry && m.toolkitInstance.setEdgeGeometry(t, r.exportGeometry(), m)
                }), this.fire("rotate", {
                    obj: b.obj,
                    rotation: g
                }))
            }
        },
        {
            key: "_setPosition",
            value: function(b) {
                var g = {},
                m = b.info || this.getObjectInfo(b.vertex);
                if (m && m.obj) {
                    var r = m.obj;
                    qa(m.obj) && (r = m.obj.getParent());
                    var t = r.id;
                    if (!0 !== b.doNotUpdateLayout) {
                        var u = Sb(r) || Tb(r),
                        v = u ? this._layoutMap.get(r.group.id) : this._layout;
                        if (b.magnetize ? A(g, this._setMagnetizedPosition(t, b.x, b.y, !0, v)) : A(g, v.setPosition(t, b.x, b.y)), u) u = this.view.getGroupDefinition(this.dataSource.getNodeType(r.group.data)),
                        r = this._autoSizeAGroup(r.group, u, null, !1),
                        null != r && A(g, r)
                    }
                    r = b.size ? b.size.w: null;
                    u = b.size ? b.size.h: null;
                    null != m.el && (this.viewport.updateElement(this.jsplumb.getId(m.el), b.x, b.y, r, u, null), !0 === b.doNotUpdateElement || b.magnetize || ob(m.el, b.x, b.y), !0 === b.doRevalidate && this.jsplumb.revalidate(m.el));
                    b.storeInModel && this._storePositionsInModel && this.storePositionInModel(t)
                }
                return g
            }
        },
        {
            key: "setMagnetizedPosition",
            value: function(b, g, m, r) {
                this.toolkitInstance.openTransaction(Jc);
                b = this._setPosition({
                    info: null,
                    vertex: b,
                    x: g,
                    y: m,
                    doNotUpdateElement: r,
                    magnetize: !0,
                    doRevalidate: !0
                });
                return this.toolkitInstance.commitTransaction(),
                b
            }
        },
        {
            key: "storePositionInModel",
            value: function(b) {
                var g, m = "string" == typeof b ? b: b.id,
                r = "string" == typeof b ? "left": b.leftAttribute || "left",
                t = "string" == typeof b ? "top": b.topAttribute || "top",
                u = b.obj || this.dataSource.getVertex(m);
                u && (this._storePositionsInModel || b.force) && (g = (Sb(u) || Tb(u) ? this._layoutMap.get(u.group.id) : this._layout).getPosition(m), nb(u.data, r, g.x), nb(u.data, t, g.y));
                return g
            }
        },
        {
            key: "storePositionsInModel",
            value: function(b) {
                var g = this,
                m = (b = b || {}).leftAttribute || "left",
                r = b.topAttribute || "top";
                this._layout.getPositions().forEach(function(t, u) { (u = g.toolkitInstance.getNode(u) || g.toolkitInstance.getGroup(u)) && (nb(u.data, m, t.x), nb(u.data, r, t.y))
                });
                this.toolkitInstance.eachGroup(function(t, u) {
                    var v = u.getMembers();
                    u = g._layoutMap.get(u.id).getPositions();
                    for (t = 0; t < v.length; t++) nb(v[t].data, m, u.get(v[t].id).x),
                    nb(v[t].data, r, u.get(v[t].id).y)
                })
            }
        },
        {
            key: "magnetize",
            value: function(b) {
                this._doMagnetize(b, null, null, !1)
            }
        },
        {
            key: "magnetizeAtPoint",
            value: function(b) {
                this._doMagnetize(null, b, null, !1)
            }
        },
        {
            key: "magnetizeAtEvent",
            value: function(b) {
                this._doMagnetize(null, null, b, !1)
            }
        },
        {
            key: "gather",
            value: function(b) {
                this._doMagnetize(b, null, null, !0)
            }
        },
        {
            key: "_doMagnetize",
            value: function(b, g, m, r) {
                if (null != this._layout) {
                    var t = {
                        options: {}
                    };
                    if (g && (t.origin = g), r && (t.options.gather = r), m && (t.origin = this.panZoom.mapEventLocation(m)), b) b = this.getObjectInfo(b),
                    b.obj && (t.focus = b.obj.id);
                    this.gridProfile.grid && (t.options.grid = this.gridProfile.grid);
                    t = this._layout.magnetize(t);
                    this._updateMovedElements(t);
                    this.jsplumb.repaintEverything()
                }
            }
        },
        {
            key: "_toggleNode",
            value: function(b, g, m, r) {
                if (g && (g.style.display = m ? "block": "none", g._jtkVisible = m, this.fire("node:visibility", {
                    node: b,
                    el: g,
                    state: m
                }), !r)) {
                    g = this.dataSource.getAllEdgesFor(b);
                    for (var t = 0; t < g.length; t++) if (m) {
                        var u = ze(g[t].source),
                        v = ze(g[t].target);
                        this.isVisible(u === b ? v: u) && this._toggleEdge(g[t], m, r)
                    } else this._toggleEdge(g[t], m, r)
                }
            }
        },
        {
            key: "_togglePort",
            value: function(b, g) {
                b = b.getFullId();
                this.jsplumb.getEndpoint(b).setVisible(g)
            }
        },
        {
            key: "isVisible",
            value: function(b) {
                var g = this;
                return this._applyFunctionToObject(b,
                function(m) {
                    switch (m.type) {
                    case ab.objectType:
                        return m = g.getConnectionForEdge(m.obj),
                        !!m && m.isVisible();
                    case Pa.objectType:
                    case cb.objectType:
                        return ! 1 !== m.el._jtkVisible
                    }
                })
            }
        },
        {
            key: "setVisible",
            value: function(b, g, m) {
                var r = this;
                null != b && this._applyFunctionToObject(b,
                function(t) {
                    switch (t.type) {
                    case ab.objectType:
                        r._toggleEdge(t.obj, g, m);
                        break;
                    case Pa.objectType:
                    case cb.objectType:
                        r._toggleNode(t.obj, t.el, g, m);
                        break;
                    case oa.objectType:
                        r._togglePort(t.obj, g)
                    }
                })
            }
        },
        {
            key: "_applyFunctionToObject",
            value: function(b, g) {
                var m = this;
                if (null != b.eachNode && null != b.eachEdge && null != b.eachGroup && null != b.filter) {
                    var r = {
                        nodes: [],
                        edges: []
                    };
                    b.eachVertex(function(u, v) {
                        r.nodes.push(g(m.getObjectInfo(v)))
                    });
                    b.eachEdge(function(u, v) {
                        r.edges.push(g(m.getObjectInfo(v)))
                    })
                } else if (rg(b)) {
                    r = [];
                    for (var t = 0; t < b.length; t++) r.push(g(this.getObjectInfo(b[t])))
                } else r = g(this.getObjectInfo(b));
                return r
            }
        },
        {
            key: "getObjectInfo",
            value: function(b) {
                if (null == b) return {
                    id: null,
                    obj: null,
                    el: null,
                    type: null
                };
                if (b instanceof mc) {
                    var g = b.edge;
                    return {
                        obj: g,
                        id: g.id,
                        type: ab.objectType,
                        el: b.connector.canvas
                    }
                }
                if (xc(b)) return b = this.getModelObjectFromElement(b, !0),
                null != b ? {
                    el: this.getRenderedElement(b.getFullId()),
                    id: b.getFullId(),
                    type: b.objectType,
                    obj: b
                }: {
                    id: null,
                    obj: null,
                    el: null,
                    type: null
                };
                b = this.toolkitInstance.getObjectInfo(b);
                return null != b.obj ? b.type === ab.objectType ? A({
                    el: this.getRenderedConnection(b.id).connector.canvas
                },
                b) : A({
                    el: this.getRenderedElement(b.obj)
                },
                b) : A({
                    el: null
                },
                b)
            }
        },
        {
            key: "setRefreshAutomatically",
            value: function(b) {
                this._refreshAutomatically = b
            }
        },
        {
            key: "refresh",
            value: function(b) {
                var g = this;
                this._suspendRendering || b && !this._refreshAutomatically || (this._layout ? this._layout.layout(function(m) {
                    g.updateVertexPositions(m.positions, m.sizes);
                    g.fire("afterLayoutRefresh", {
                        bounds: g.getBoundsInfo(),
                        positions: m.positions,
                        sizes: g._layout.getSizes()
                    });
                    "undefined" != typeof window ? window.setTimeout(function() {
                        g.jsplumb.repaintEverything()
                    },
                    0) : g.jsplumb.repaintEverything()
                },
                this.magnetizeProfile.afterLayout) : this.jsplumb.repaintEverything())
            }
        },
        {
            key: "updateVertexPositions",
            value: function(b, g) {
                var m = this;
                b.forEach(function(r, t) {
                    m._setPosition({
                        vertex: t,
                        x: r.x,
                        y: r.y,
                        doNotUpdateElement: !1,
                        doNotUpdateLayout: !0,
                        doRevalidate: !1,
                        size: g.get(t)
                    })
                })
            }
        },
        {
            key: "relayout",
            value: function(b) {
                var g = this;
                this._suspendRendering || (this._layout ? this._layout.relayout(b,
                function(m) {
                    for (var r = 0; r < g.decorators.length; r++) g.decorators[r].decorate({
                        surface: g,
                        adapter: g._layout.adapter,
                        layout: g._layout,
                        append: function(t, u, v) {
                            g._append(t, u, v, !0)
                        },
                        setAbsolutePosition: function(t, u) {
                            return g.setAbsolutePosition(t, u)
                        },
                        toolkit: g.toolkitInstance,
                        bounds: m.bounds,
                        positions: m.positions
                    });
                    g.updateVertexPositions(m.positions, m.sizes);
                    g.relayoutGroups();
                    g.jsplumb.repaintEverything();
                    g.fire("relayout", {
                        bounds: g.getBoundsInfo(),
                        positions: m.positions,
                        sizes: g._layout.getSizes()
                    })
                },
                this.magnetizeProfile.afterLayout) : this.jsplumb.repaintEverything())
            }
        },
        {
            key: "relayoutGroups",
            value: function() {
                var b = this;
                this.dataSource.eachGroup(function(g, m) {
                    b.objectFilter(m) && b.relayoutGroup(m)
                })
            }
        },
        {
            key: "relayoutGroup",
            value: function(b) {
                var g = this,
                m = this._layoutMap.get(b.id);
                if (null != m) {
                    m.relayout(null,
                    function(t) {
                        t.positions.forEach(function(u, v) {
                            g.setAbsolutePosition(g.jsplumb.getManagedElement(v), u)
                        })
                    },
                    !1);
                    this.sizeGroupToFit(b);
                    var r = this.jsplumb.getManagedElement(b.id);
                    this.jsplumb.revalidate(r);
                    this.fire("group:relayout", {
                        group: b,
                        layout: m,
                        el: r
                    })
                }
            }
        },
        {
            key: "getModelObjectFromEndpoint",
            value: function(b) {
                b = b.parameters;
                var g = this.toolkitInstance.getNode(b.vertexId);
                return b.portId ? g.addPort({
                    id: b.portId,
                    type: b.portType
                }) : g
            }
        },
        {
            key: "getModelObjectFromElement",
            value: function(b, g) {
                var m = this;
                return function u(t) {
                    var v, w = t.getAttribute("data-jtk-managed");
                    null != w && (w = m.toolkitInstance.getVertex(w), null != w && (v = w));
                    if (null == v && (w = t.getAttribute("data-jtk-port") || t.getAttribute("data-jtk-source-port") || t.getAttribute("data-jtk-target-port"), null != w)) {
                        var z = sb(t, wb("data-jtk-managed"), m.jsplumb.getContainer(), !1);
                        if (null != z && (z = z.getAttribute("data-jtk-managed"), z = m.toolkitInstance.getNode(z) || m.toolkitInstance.getGroup(z))) return t = t.getAttribute("data-jtk-port-type") || t.getAttribute("data-jtk-source-port-type") || t.getAttribute("data-jtk-target-port-type") || "default",
                        z.addPort({
                            id: w,
                            type: t
                        })
                    }
                    return null == v && !0 === g ? (t = t.parentElement, null != t && t !== m.jsplumb.getContainer() ? u(t) : null) : v
                } (b)
            }
        },
        {
            key: "_createLayout",
            value: function(b) {
                var g = this,
                m = {
                    container: this.containerElement,
                    options: b.options || {},
                    toolkit: this.toolkitInstance,
                    adapter: new Pi(this)
                };
                return m.options.locationFunction || (m.options.locationFunction = function(r) {
                    return {
                        x: nb(r.data, g._modelLeftAttribute),
                        y: nb(r.data, g._modelTopAttribute)
                    }
                }),
                od.get(b.type, m)
            }
        },
        {
            key: "_createGroupLayout",
            value: function(b, g) {
                var m = this,
                r = this._getGroupDragArea(g);
                null == r && (r = this.jsplumb.getManagedElement(g.id));
                g = {
                    container: r,
                    negativeValuesAllowed: !1,
                    options: b.options || {},
                    toolkit: this.toolkitInstance,
                    adapter: new Rl(g, this)
                };
                return g.options.locationFunction || (g.options.locationFunction = function(t) {
                    return {
                        x: nb(t.data, m._modelLeftAttribute),
                        y: nb(t.data, m._modelTopAttribute)
                    }
                }),
                od.get(b.type, g)
            }
        },
        {
            key: "setLayout",
            value: function(b, g) {
                b && (this._layout = this._createLayout(b), g || this.refresh())
            }
        },
        {
            key: "adHocLayout",
            value: function(b) {
                if (b) {
                    var g = this._layout;
                    this.setLayout(b);
                    this._layout = g
                }
            }
        },
        {
            key: "getViewportPosition",
            value: function(b) {
                return this.getViewportPositionById(b.id)
            }
        },
        {
            key: "getViewportPositionById",
            value: function(b) {
                return this.viewport.getPosition(b)
            }
        },
        {
            key: "getModelPositionAttributes",
            value: function() {
                return [this._modelLeftAttribute, this._modelTopAttribute]
            }
        },
        {
            key: "getLabelLocationAttribute",
            value: function(b) {
                return this.view.getEdgeDefinition(this.dataSource.getEdgeType(b.data || {})).labelLocationAttribute || "labelLocation"
            }
        },
        {
            key: "setEnabled",
            value: function(b, g) {
                b = b.getFullId();
                b = this.getRenderedEndpoint(b) || this.getRenderedElement(b) || this.getRenderedPort(b);
                return null != b && (xc(b) ? g ? b.removeAttribute("data-jtk-enabled") : b.setAttribute("data-jtk-enabled", "false") : b.enabled = g),
                g
            }
        },
        {
            key: "batch",
            value: function(b) {
                this.setSuspendEvents(!0);
                this.dataSource.batch(b);
                this.setSuspendEvents(!1)
            }
        },
        {
            key: "getRenderedElement",
            value: function(b) {
                if (null == b) return null;
                b = (J(b) ? b: b.getFullId()).split(this.toolkitInstance.portSeparator);
                var g = this.jsplumb.getManagedElement(b[0]);
                if (! (g && 1 < b.length)) return g;
                var m = g.querySelector(Xb("data-jtk-port", b[1])) || g.querySelector(Xb("data-jtk-source-port", b[1])) || g.querySelector(Xb("data-jtk-target-port", b[1]));
                return null != m ? m: g.getAttribute("data-jtk-port") === b[1] || g.getAttribute("data-jtk-source-port") === b[1] || g.getAttribute("data-jtk-target-port") === b[1] || g.getAttribute("data-jtk-port-id") === b[1] || g.getAttribute("data-jtk-source-port-id") === b[1] || g.getAttribute("data-jtk-target-port-id") === b[1] ? g: void 0
            }
        },
        {
            key: "getRenderedVertex",
            value: function(b) {
                return this.jsplumb.getManagedElement(b)
            }
        },
        {
            key: "getRenderedPort",
            value: function(b) {
                b = b.split(".");
                var g = this.getRenderedElement(b[0]);
                b = g ? g.querySelector(Xb("data-jtk-port", b[1])) || g.querySelector(Xb("data-jtk-target-port", b[1])) || g.querySelector(Xb("data-jtk-source-port", b[1])) || g: null;
                return null == b || "jtk-endpoint" === b.tagName.toLowerCase() ? null: b
            }
        },
        {
            key: "getRenderedConnection",
            value: function(b) {
                return this.connMap[b]
            }
        },
        {
            key: "getRenderedEndpoint",
            value: function(b) {
                return this.jsplumb.getEndpoint(b)
            }
        },
        {
            key: "setSuspendRendering",
            value: function(b, g) {
                this.panZoom.setSuspendRendering(b);
                this._suspendRendering = b;
                this.jsplumb.setSuspendDrawing(b);
                g && this.refresh()
            }
        },
        {
            key: "_ingestEndpoint",
            value: function(b, g) {
                this.jsplumb.setEndpointUuid(g, b.getFullId());
                g.graph = {
                    vertex: b.getParent(),
                    vertexType: b.getParent().objectType,
                    port: b
                }
            }
        },
        {
            key: "repaint",
            value: function(b, g) {
                b = this.getObjectInfo(b);
                null != b.el && null != b.obj && (g && (g = this._layout.getPosition(b.id), this.setAbsolutePosition(b.el, g)), this.jsplumb.revalidate(b.el), this.fire("objectRepainted", b))
            }
        },
        {
            key: "expandGroup",
            value: function(b) {
                this.jsplumb.expandGroup("string" == typeof b ? b: b.id)
            }
        },
        {
            key: "collapseGroup",
            value: function(b) {
                this.jsplumb.collapseGroup("string" == typeof b ? b: b.id)
            }
        },
        {
            key: "toggleGroup",
            value: function(b) {
                this.jsplumb.toggleGroup("string" == typeof b ? b: b.id)
            }
        },
        {
            key: "autoSizeGroups",
            value: function(b) {
                var g = this;
                this.jsplumb.groupManager.forEach(function(m) {
                    if (m = g.dataSource.getGroup(m.id)) {
                        var r = g.view.getGroupDefinition(g.dataSource.getNodeType(m.data));
                        g._autoSizeAGroup(m, r, null, b)
                    }
                })
            }
        },
        {
            key: "sizeGroupToFit",
            value: function(b, g) {
                if (b) {
                    var m = this.view.getGroupDefinition(this.dataSource.getNodeType(b.data));
                    this._autoSizeAGroup(b, m, null, g)
                }
            }
        },
        {
            key: "activateState",
            value: function(b, g) {
                if (b = this.view.getState(b)) g = this._getStateTarget(g),
                b.activate(g, this, this.dataSource),
                this.currentStates.push(b)
            }
        },
        {
            key: "deactivateState",
            value: function(b, g) {
                var m = this.view.getState(b);
                m && (g = this._getStateTarget(g), m.deactivate(g, this, this.dataSource), ma(this.currentStates,
                function(r) {
                    return r == m
                }))
            }
        },
        {
            key: "resetState",
            value: function() {
                for (var b = 0; b < this.currentStates.length; b++) this.currentStates[b].deactivate(this.dataSource, this, this.dataSource);
                this.currentStates.length = 0
            }
        },
        {
            key: "setSize",
            value: function(b, g, m) {
                b = this.getObjectInfo(b);
                b.obj && b.el && ((Sb(b.obj) || Tb(b.obj) ? this._layoutMap.get(b.obj.group.id) : this._layout).setSize(b.obj.getFullId(), {
                    w: g,
                    h: m
                }), b = b.el, b.style.width = g + "px", b.style.height = m + "px")
            }
        },
        {
            key: "getConnectionForEdge",
            value: function(b) {
                return this.connMap[b.getId()]
            }
        },
        {
            key: "getConnectionsForEdges",
            value: function(b) {
                for (var g = [], m = 0; m < b.length; m++) g.push(this.connMap[b[m].getId()]);
                return g
            }
        },
        {
            key: "beforeDrop",
            value: function(b) {
                var g = b.connection,
                m = this.getModelObjectFromEndpoint(g.endpoints[0]),
                r = this.getModelObjectFromEndpoint(b.dropEndpoint);
                b = b.connection.edge;
                return null == b ? this.dataSource.beforeConnect(m, r, g.getData()) : this.dataSource.beforeMoveConnection(m, r, b)
            }
        },
        {
            key: "beforeDrag",
            value: function(b) {
                var g = b.endpoint.parameters,
                m = this.toolkitInstance.getNode(g.vertexId);
                m = g.portId ? m.addPort({
                    id: g.portId,
                    type: g.portType
                }) : m;
                var r = b.endpoint.edgeType;
                g = this.dataSource.beforeStartConnect(m, r);
                if (this._debug) {
                    var t = this.view.getEdgeDefinition(r) || {};
                    console.log("\n------------------------\nDrag started with edge type `" + r + "`, having definition :");
                    console.log(t);
                    console.log("Edge source is a " + m.objectType + ", having type [" + m.getType() + "], with definition :");
                    m = this.view["get" + m.objectType + "Definition"](m.getType()) || {};
                    console.log(m);
                    console.log("Toolkit response to drag start :");
                    console.log(g);
                    console.log("---------------------------\n")
                }
                return ! 1 === g && b.endpoint.isTemporarySource && b.endpoint._deleteOnDetach && this.jsplumb.deleteEndpoint(b.endpoint),
                g
            }
        },
        {
            key: "beforeDetach",
            value: function(b, g) {
                var m = this.getModelObjectFromEndpoint(b.endpoints[0]),
                r = this.getModelObjectFromEndpoint(b.endpoints[1]);
                return this.dataSource.beforeDetach(m, r, b.edge, g)
            }
        },
        {
            key: "beforeStartDetach",
            value: function(b) {
                var g = this.getModelObjectFromEndpoint(b.endpoint);
                return this.dataSource.beforeStartDetach(g, b.connection.edge)
            }
        },
        {
            key: "_fireEdgeRemoved",
            value: function(b) {
                this.fire("edge:removed", {
                    sourceNodeId: ag(b.source),
                    targetNodeId: ag(b.target),
                    sourcePortId: bg(b.source),
                    targetPortId: bg(b.target),
                    sourceId: b.source.getFullId(),
                    targetId: b.target.getFullId(),
                    source: b.source,
                    target: b.target,
                    edge: b
                })
            }
        },
        {
            key: "_loadStartFn",
            value: function() {
                this.setSuspendRendering(!0)
            }
        },
        {
            key: "_appendStartFn",
            value: function() {
                this.setSuspendRendering(!0)
            }
        },
        {
            key: "_loadEndFn",
            value: function() {
                this.setSuspendRendering(!1);
                this._assignPendingDragGroups();
                this.relayout();
                this.jsplumb.repaintEverything();
                this._layout && this.fire("dataLoadEnd");
                this.zoomToFitOnLoad && this.zoomToFit()
            }
        },
        {
            key: "_appendEndFn",
            value: function() {
                this.setSuspendRendering(!1);
                this._assignPendingDragGroups();
                this.refresh();
                this.jsplumb.setSuspendDrawing(!1, !0);
                this._layout && this.fire("dataAppendEnd")
            }
        },
        {
            key: "_appendNodeToGroup",
            value: function(b, g, m) {
                var r = this.jsplumb.getManagedElement(m.id);
                r && ((r.querySelector(wb("data-jtk-group-content")) || r).appendChild(b), this.jsplumb.addToGroup(m.id, b), this._layoutMap.get(m.id).vertexAdded({
                    el: b,
                    vertex: g
                }), this.panZoom.suspend(b))
            }
        },
        {
            key: "_extractEndpointsFromVertex",
            value: function(b) {
                var g = [],
                m = b.querySelectorAll([wb("data-jtk-endpoint"), "jtk-endpoint"].join());
                if (P(m,
                function(r) {
                    var t = Te(new Mi(r)),
                    u = "JTK-ENDPOINT" === r.tagName.toUpperCase();
                    u && null == t.portId ? u && pa("jsPlumb: jtk-endpoint element missing `data-jtk-port` attribute; not processed") : g.push([t, r])
                }), null != b.getAttribute("data-jtk-endpoint")) m = Te(new Mi(b)),
                g.push([m, b]);
                return g
            }
        },
        {
            key: "_extractEndpointFromElementAndDefinition",
            value: function(b, g) {
                var m = this,
                r = this._extractEndpointsFromVertex(b);
                P(r,
                function(t) {
                    var u, v = Pe(t, 2);
                    t = v[0];
                    var w = v[1];
                    v = A({},
                    t);
                    null != t.portId && (u = g.addPort({
                        id: t.portId,
                        type: t.portType
                    }), v.uuid = u.getFullId(), v.data = u.data);
                    null == v.uuid && (t.portId ? v.uuid = g.id + "." + t.portId: w === b && (v.uuid = g.id));
                    u = m.view.getPortDefinition(t.portType || "default");
                    null != u && A(v, u);
                    v.element = b;
                    m.jsplumb._internal_newEndpoint(v).mergeParameters(Q({
                        vertexId: g.id,
                        portId: t.portId,
                        portType: t.portType,
                        edgeType: t.edgeType
                    }))
                })
            }
        },
        {
            key: "_doRenderNode",
            value: function(b, g) {
                if (null == this.jsplumb.getManagedElement(b.id)) {
                    var m = this.getNodeDefinition(b); ! 0 !== m.ignore && this.nodeRenderer(b, b.data, b, m, g)
                }
            }
        },
        {
            key: "_doRenderGroup",
            value: function(b, g) {
                if (null == this.jsplumb.getManagedElement(b.id)) {
                    var m = this.getGroupDefinition(b); ! 0 !== m.ignore && (!0 === m.ghost && (m.ghostProxyParent = this.containerElement), this.groupRenderer(b, b.data, b, m, g))
                }
            }
        },
        {
            key: "_flushUnrenderedEdges",
            value: function() {
                for (var b = [], g = 0; g < this.unrenderedEdges.length; g++) null == this._maybeRenderEdge(this.unrenderedEdges[g]) && b.push(this.unrenderedEdges[g]);
                this.unrenderedEdges = b
            }
        },
        {
            key: "_prepareConnectionParams",
            value: function(b) {
                var g = this,
                m = this.dataSource.getEdgeType(b.data),
                r = {
                    type: m,
                    edgeType: m,
                    data: b.data,
                    cost: b.getCost(),
                    directed: b.isDirected(),
                    geometry: b.geometry,
                    ports: []
                },
                t = this.view.getEdgeDefinition(m); !
                function(v) {
                    if (t) for (var w = 0; w < v.length; w++) t[v[w]] && (r[v[w]] = t[v[w]])
                } ("connector endpoints endpoint endpointStyles endpointStyle cssClass hoverClass".split(" "));
                r.anchor && !r.anchors && (r.anchors = [r.anchor, r.anchor], delete r.anchor);
                r.endpoint && !r.endpoints && (r.endpoints = [r.endpoint, r.endpoint], delete r.endpoint);
                var u = function(v, w, z, y, E) {
                    if (y && y[z]) {
                        var F = v[w] || [y[z], y[z]];
                        F[E] = y[z];
                        v[w] = F
                    }
                };
                m = function(v, w, z) {
                    if (qa(v)) {
                        var y = v.getParent(),
                        E = v.getFullId();
                        E = g.jsplumb.getEndpoint(E) || g.getRenderedPort(E);
                        r[w] = E || g.jsplumb.getManagedElement(g.dataSource.getNodeId(y.data));
                        w = g.view.getPortDefinition(v.getType());
                        u(r, "anchors", "anchor", w, z);
                        u(r, "endpoints", "endpoint", w, z);
                        r.ports[z] = v.id
                    } else v = b[w].id,
                    z = g.jsplumb.getEndpoint(v),
                    r[w] = z || g.jsplumb.getManagedElement(v)
                };
                return m(b.source, "source", 0),
                m(b.target, "target", 1),
                r.doNotFireConnectionEvent = !0,
                r
            }
        },
        {
            key: "__bindToToolkit",
            value: function(b, g) {
                this._boundToolkitEvents.push({
                    event: b,
                    fn: g
                });
                this.dataSource.bind(b, g, !0)
            }
        },
        {
            key: "_bindToolkitEvents",
            value: function() {
                var b = this;
                this.__bindToToolkit("node:added",
                function(g) {
                    var m = g.node;
                    b.objectFilter(m) && b._doRenderNode(m, g.eventInfo)
                });
                this.__bindToToolkit("node:removed",
                function(g) {
                    var m = g.parentGroup ? g.parentGroup.id: Sb(g.node) || Tb(g.node) ? g.node.group.id: null,
                    r = null != m ? b._layoutMap.get(m) : b._layout;
                    m = r.getPosition(g.node.id);
                    r.vertexRemoved(g.node);
                    r = b.jsplumb.getManagedElement(g.nodeId);
                    g.parentGroup && b.jsplumb.removeFromGroup(g.parentGroup.id, r, !0);
                    b.fire("node:removed", {
                        vertex: g.node,
                        el: r,
                        pos: m
                    });
                    b.jsplumb.unmanage(r);
                    b.templateRenderer.cleanupVertex(g.nodeId, r);
                    ma(b.vertexList,
                    function(t) {
                        return t.id === g.node.id
                    });
                    delete r.jtk;
                    b.refresh(!0)
                });
                this.__bindToToolkit("group:member:added",
                function(g) {
                    var m = b.jsplumb.getManagedElement(g.vertex.id);
                    m && (b.panZoom.suspend(m), g.pos && (null != g.vertex.data[b._modelLeftAttribute] && (g.vertex.data[b._modelLeftAttribute] = g.pos.x), null != g.vertex.data[b._modelTopAttribute] && (g.vertex.data[b._modelTopAttribute] = g.pos.y)), b.fire("group:member:added", {
                        vertex: g.vertex,
                        group: g.group,
                        uigroup: b.jsplumb.getGroup(g.group.id),
                        sourceGroup: g.sourceGroup,
                        pos: g.pos,
                        el: m,
                        groupEl: b.jsplumb.getManagedElement(g.group.id)
                    }), g.source !== b && b.jsplumb.addToGroup(g.group.id, m), b._layout.vertexRemoved(g.vertex), g.sourceGroup && b._layoutMap.get(g.sourceGroup.id).vertexRemoved(g.vertex), b._layoutMap.get(g.group.id).vertexAdded({
                        el: m,
                        pos: g.pos,
                        vertex: g.vertex
                    }), b._suspendRendering || b.relayoutGroup(g.group))
                });
                this.__bindToToolkit("group:member:removed",
                function(g) {
                    var m = b.jsplumb.getManagedElement(g.vertex.id);
                    if (m) {
                        var r;
                        if (g.source !== b && b.jsplumb.removeFromGroup(g.group.id, m), b._layoutMap.get(g.group.id).vertexRemoved(g.vertex), g.targetGroup)(r = b._layoutMap.get(g.targetGroup.id)).vertexAdded({
                            el: m,
                            vertex: g.vertex
                        });
                        else { (r = b._layout).vertexAdded({
                                el: m,
                                vertex: g.vertex
                            });
                            var t = b.jsplumb.getOffset(m);
                            b._layout.setPosition(g.vertex.id, t.x, t.y);
                            b._storePositionsInModel && b.storePositionInModel(g.vertex.id)
                        }
                        b.panZoom.restore(m);
                        b.fire("group:member:removed", A(g, {
                            el: m,
                            groupEl: b.jsplumb.getManagedElement(g.group.id),
                            pos: r.getPosition(g.vertex.id)
                        }));
                        b._suspendRendering || b.relayoutGroup(g.group)
                    }
                });
                this.__bindToToolkit("group:added",
                function(g) {
                    var m = g.group;
                    b.objectFilter(m) && b._doRenderGroup(m, g.eventInfo)
                });
                this.__bindToToolkit("group:removed",
                function(g) {
                    var m = g.group,
                    r = g.parentGroup ? g.parentGroup.id: null,
                    t = null != r ? b._layoutMap.get(r) : b._layout;
                    r = t.getPosition(g.group.id);
                    t.vertexRemoved(m);
                    t = b.jsplumb.getManagedElement(m.id);
                    var u = b.jsplumb.removeGroup(m.id, g.removeChildren, !0, !0),
                    v = null;
                    if (null != u) for (var w in v = {},
                    u) {
                        var z = b.toolkitInstance.getVertex(w);
                        null != z ? (null == z.group && b.panZoom.restore(z.id), b._setPosition({
                            vertex: z,
                            x: u[w].x,
                            y: u[w].y,
                            doNotUpdateElement: !0
                        }), v[z.id] = {
                            x: u[w].x,
                            y: u[w].y
                        }) : pa("Could not reposition element removed from group - no DOM node found.")
                    }
                    b.fire("group:removed", {
                        el: t,
                        vertex: m,
                        children: g.children,
                        childrenRemoved: g.removeChildren,
                        childPositions: v,
                        pos: r
                    });
                    b.templateRenderer.cleanupVertex(m.id, t);
                    ma(b.vertexList,
                    function(y) {
                        return y.id === g.group.id
                    });
                    delete t.jtk
                });
                this.__bindToToolkit("edge:added",
                function(g) {
                    if (!b._ignoreToolkitEvents && g.source !== b && (g = g.edge, b.objectFilter(g.source) && b.objectFilter(g.target))) {
                        var m = b.view.getEdgeDefinition(b.dataSource.getEdgeType(g.data || {}));
                        m && !0 === m.ignore || b._enqueueEdge(g, !0)
                    }
                });
                this.__bindToToolkit("edge:removed",
                function(g) {
                    if (!b._ignoreToolkitEvents && g.source !== b) {
                        g = g.edge;
                        var m = b.connMap[g.getId()];
                        m && (b.dataSource.debugEnabled && console.log("Renderer", "removing edge", g), b._fireEdgeRemoved(g), delete b.connMap[g.getId()], b.jsplumb.deleteConnection(m, {
                            fireEvent: !1
                        }))
                    }
                });
                this.__bindToToolkit("edge:typeChanged",
                function(g) {
                    if (!b._ignoreToolkitEvents && g.source !== b) {
                        var m = g.obj,
                        r = b.connMap[m.getId()];
                        if (r) {
                            var t = b.view.getEdgeDefinition(g.newType);
                            t && !0 === t.ignore || ((t.endpoint || t.endpoints) && (r.replaceEndpoint(0, t.endpoints ? t.endpoints[0] : t.endpoint), r.replaceEndpoint(1, t.endpoints ? t.endpoints[1] : t.endpoint)), t.connector && r.setConnector(t.connector), r.setType(g.newType, m.data))
                        }
                    }
                });
                this.__bindToToolkit("edge:target",
                function(g) {
                    if (!b._ignoreToolkitEvents) {
                        var m = g.edge,
                        r = b.connMap[m.getId()];
                        g = m.target.getFullId();
                        var t = b.jsplumb.getManagedElement(g) || b.jsplumb.getEndpoint(g) || b.getRenderedElement(g);
                        r ? b.jsplumb.silently(function() {
                            null != t ? (b.dataSource.debugEnabled && console.log("target change", r), b.jsplumb.setTarget(r, t)) : (delete b.connMap[m.getId()], b.jsplumb.deleteConnection(r, {
                                force: !0,
                                fireEvent: !1
                            }))
                        }) : null != t && b.dataSource.debugEnabled && console.log("Target for Edge " + m.getId() + " changed to Node " + t.id + "; we have no valid connection.")
                    }
                });
                this.__bindToToolkit("edge:source",
                function(g) {
                    if (!b._ignoreToolkitEvents) {
                        var m = g.edge,
                        r = b.connMap[m.getId()];
                        g = m.source.getFullId();
                        var t = b.jsplumb.getManagedElement(g) || b.jsplumb.getEndpoint(g) || b.getRenderedElement(g);
                        r ? b.jsplumb.silently(function() {
                            null != t ? b.jsplumb.setSource(r, t) : (delete b.connMap[m.getId()], b.jsplumb.deleteConnection(r, {
                                force: !0,
                                fireEvent: !1
                            }))
                        }) : null != t && b.dataSource.debugEnabled && console.log("Source for Edge " + m.getId() + " changed to Node " + m.source.getFullId() + "; we have no valid connection.")
                    }
                });
                this.__bindToToolkit("edge:pathRestored",
                function(g) {
                    if (g.renderer.id === b.id) {
                        var m = b.getRenderedConnection(g.edge.getId());
                        null != g.geometry ? (m.connector.importGeometry(g.geometry), b.jsplumb.revalidate(m.source)) : m.connector.resetGeometry()
                    }
                });
                this.__bindToToolkit("graphClearStart",
                function() {
                    b.jsplumb.reset();
                    for (var g = 0; g < b.decorators.length; g++) b.decorators[g].reset({
                        remove: function(m) {
                            return m.parentNode && m.parentNode.removeChild(m)
                        }
                    });
                    b.panZoom.reset();
                    P(b.plugins,
                    function(m) {
                        return m.reset()
                    });
                    P(b.vertexList,
                    function(m) {
                        var r = b.jsplumb.getManagedElement(m.id);
                        null != r && b.templateRenderer.cleanupVertex(m.id, r)
                    });
                    b._layout && b._layout._reset();
                    b.vertexList.length = 0;
                    b.connMap = {};
                    b._layoutMap.clear();
                    b.jsplumb.setZoom(b.getZoom())
                });
                this.__bindToToolkit("port:added",
                function(g) {
                    var m = b.jsplumb.getManagedElement(g.vertex.id),
                    r = b.view.getPortDefinition(b.dataSource.getPortType(g.data));
                    if (r.isEndpoint) {
                        var t = b.getRenderedPort(g.port.getFullId());
                        r = A({
                            parameters: {
                                vertexId: g.vertex.id,
                                portId: g.port.id,
                                portType: g.port.getType()
                            },
                            uuid: g.port.getFullId(),
                            data: g.port.data
                        },
                        r);
                        g = Te(new Ll(g.data, "data-jtk-"));
                        A(r, g);
                        r.element = t || m;
                        b.jsplumb._internal_newEndpoint(r)
                    } else b.getRenderedPort(g.port.getFullId()) || b.portRenderer(g.port, g.data, g.vertex, r, null);
                    b.jsplumb.revalidate(m);
                    b.refresh(!0)
                });
                this.__bindToToolkit("port:removed",
                function(g) {
                    var m = b.jsplumb.getManagedElement(g.vertex.id),
                    r = g.port.getFullId(),
                    t = b.getRenderedPort(r),
                    u = b.jsplumb.getEndpoint(r);
                    null != u ? (b.jsplumb.deleteEndpoint(u), b.refresh(!0)) : null != t && (m !== t && (b.jsplumb.setSuspendEvents(!0), b.jsplumb.unmanage(t), b.templateRenderer.cleanupPort(r, t), b.jsplumb.setSuspendEvents(!1)), b.fire("port:removed", {
                        vertex: g.vertex,
                        port: g.port,
                        portEl: t,
                        vertexEl: m
                    }), b.jsplumb.revalidate(m), b.refresh(!0))
                });
                this.__bindToToolkit("edge:updated",
                function(g) {
                    var m = b.connMap[g.edge.getId()];
                    m && (g = b._prepareConnectionParams(g.edge), m.setType(["default", g.type].join(" "), g.data))
                });
                this.__bindToToolkit("port:updated",
                function(g) {
                    var m = b.getRenderedPort(g.originalId);
                    m && (!1 === b.templateRenderer.reactive && b.templateRenderer.update(m, g.port.data, b), b.repaint(b.jsplumb.getManagedElement(g.vertex.id)))
                });
                this.__bindToToolkit("node:updated",
                function(g) {
                    b._vertexUpdated(g.vertex)
                });
                this.__bindToToolkit("group:updated",
                function(g) {
                    b._vertexUpdated(g.vertex)
                });
                this.__bindToToolkit("select",
                function(g) {
                    ka(g.obj) || ra(g.obj) ? (g = b.getRenderedElement(g.obj.id)) && (sa(g, "jtk-surface-selected-element"), b.jsplumb.addToDragSelection(g)) : Wc(g.obj) && (g = b.getConnectionForEdge(g.obj)) && g.addClass("jtk-surface-selected-connection")
                });
                this.__bindToToolkit("selection:cleared",
                function() {
                    b.jsplumb.clearDragSelection();
                    P(b.jsplumb.getSelector(b.jsplumb.getContainer(), ".jtk-surface-selected-connection"),
                    function(g) {
                        return ta(g, "jtk-surface-selected-connection")
                    });
                    P(b.jsplumb.getSelector(b.jsplumb.getContainer(), ".jtk-surface-selected-element"),
                    function(g) {
                        return ta(g, "jtk-surface-selected-element")
                    })
                });
                this.__bindToToolkit("deselect",
                function(g) {
                    ka(g.obj) || ra(g.obj) ? (g = b.getRenderedElement(g.obj.id)) && (ta(g, "jtk-surface-selected-element"), b.jsplumb.removeFromDragSelection(g)) : Wc(g.obj) && (g = b.getConnectionForEdge(g.obj)) && g.removeClass("jtk-surface-selected-connection")
                });
                this.__bindToToolkit("dataLoadStart", this._loadStartFn.bind(this));
                this.__bindToToolkit("dataAppendStart", this._appendStartFn.bind(this));
                this.__bindToToolkit("dataLoadEnd", this._loadEndFn.bind(this));
                this.__bindToToolkit("dataAppendEnd", this._appendEndFn.bind(this))
            }
        },
        {
            key: "_vertexUpdated",
            value: function(b) {
                if (null != b) {
                    var g = this.jsplumb.getManagedElement(b.getFullId());
                    g && (!1 === this.templateRenderer.reactive && this.templateRenderer.update(g, b.data, this), this._doAssignDragGroup(g, b), this.repaint(g))
                }
            }
        },
        {
            key: "_autoSizeAGroup",
            value: function(b, g, m, r) {
                var t = !0 === g.autoShrink || !0 === g.autoSize && !1 !== g.autoShrink,
                u = !0 === g.autoGrow || !0 === g.autoSize && !1 !== g.autoGrow;
                if (! (r || g.autoShrink || g.autoGrow || g.autoSize)) return null;
                m = m || {};
                var v = this.jsplumb.getGroup(b.id),
                w = this.jsplumb.getGroupContentArea(v),
                z = this._layoutMap.get(b.id)._getExtents(),
                y = g.maxSize || [z.xmax, z.ymax];
                g = Math.min(y[0], z.xmax);
                z = Math.min(y[1], z.ymax);
                var E = this.jsplumb.getSize(w),
                F = this.jsplumb.getSize(v.el);
                y = Math.max(E.w, F.w);
                var M = Math.max(E.h, F.h);
                this.gridProfile.grid && !1 !== this.gridProfile.fitGroupsToGrid && (g = this.gridProfile.grid.w * Math.ceil(g / this.gridProfile.grid.w), z = this.gridProfile.grid.h * Math.ceil(z / this.gridProfile.grid.h));
                w.style.width = g + "px";
                w.style.height = z + "px";
                var S = this.jsplumb.getSize(v.el);
                E = S.w - y;
                F = S.h - M;
                r || !1 !== t || (t = !1, 0 > E && (w.style.width = y + "px", E = 0, t = !0), 0 > F && (w.style.height = M + "px", F = 0, t = !0), t && (S = this.jsplumb.getSize(v.el)));
                r || !1 !== u || (r = !1, 0 < E && (w.style.width = y + "px", E = 0, r = !0), 0 < F && (w.style.height = M + "px", F = 0, r = !0), r && (S = this.jsplumb.getSize(v.el)));
                b.group ? (this._layoutMap.get(b.group.id).setSize(b.id, S), (v = this.getGroupDefinition(b.group)) && this._autoSizeAGroup(b.group, v, m, !1)) : (this._layout.setSize(b.id, S), this.magnetizeProfile.afterGroupShrink && (0 > E || 0 > F)) ? this.gather(b) : this.magnetizeProfile.afterGroupGrow && (0 < E || 0 < F) && (v = this._layout.getPosition(b.id), null != v && A(m, this._setMagnetizedPosition(b.id, v.x, v.y, !this.magnetizeProfile.repositionDraggedElement, this._layout)));
                return 0 === E && 0 === F || this.fire("group:resize", {
                    group: b,
                    el: w,
                    w: g,
                    h: z
                }),
                m
            }
        },
        {
            key: "_connect",
            value: function(b, g, m) {
                var r = this;
                this.dataSource.debugEnabled && console.log("Renderer", "adding connection with params", b);
                var t = function(y, E) {
                    y.endpoint = y.endpoint || r.jsplumb.defaults.endpoints[E] || r.jsplumb.defaults.endpoint;
                    y.paintStyle = y.paintStyle || r.jsplumb.defaults.endpointStyles[E] || r.jsplumb.defaults.endpointStyle;
                    y.hoverPaintStyle = y.hoverPaintStyle || r.jsplumb.defaults.endpointHoverStyles[E] || r.jsplumb.defaults.endpointHoverStyle;
                    y.anchor = null != y.anchor ? y.anchor: null != r.jsplumb.defaults.anchors ? r.jsplumb.defaults.anchors[E] : r.jsplumb.defaults.anchor;
                    y.deleteOnEmpty = !1 !== y.deleteOnEmpty || y.deleteOnEmpty
                },
                u = function(y, E) {
                    null != m && (y.endpoint = y.endpoint || m.endpoint || (m.endpoints ? m.endpoints[E] : null), y.anchor = y.anchor || m.anchor || (m.anchors ? m.anchors[E] : null), y.paintStyle = y.paintStyle || m.endpointStyle || (m.endpointStyles ? m.endpointStyles[E] : null), y.hoverPaintStyle = y.hoverPaintStyle || m.endpointHoverStyle || (m.endpointHoverStyles ? m.endpointHoverStyles[E] : null))
                },
                v = A({},
                b);
                if (null != b.type && null != (m = m || this.view.getEdgeDefinition(b.type)) && (this.enhancedView ? A(v, Qc(m, g.data, null, !0)) : A(v, m)), xc(b.source)) {
                    var w = {
                        element: b.source
                    },
                    z = b.source.getAttribute("data-jtk-port-type") || b.source.getAttribute("data-jtk-source-port-type");
                    null != z && (z = this.view.getPortDefinition(z), null != z && (this.enhancedView ? A(w, Qc(z, g.source.data, null, !0)) : A(w, z)));
                    u(w, 0);
                    t(w, 0);
                    v.sourceEndpoint = this.jsplumb._internal_newEndpoint(w)
                }
                xc(b.target) && (w = {
                    element: b.target
                },
                b = b.target.getAttribute("data-jtk-port-type") || b.target.getAttribute("data-jtk-target-port-type"), null != b && (b = this.view.getPortDefinition(b), null != b && (this.enhancedView ? A(w, Qc(b, g.target.data, null, !0)) : A(w, b))), u(w, 1), t(w, 1), v.targetEndpoint = this.jsplumb._internal_newEndpoint(w));
                return this.jsplumb.connect(v)
            }
        },
        {
            key: "_enqueueEdge",
            value: function(b, g) {
                this.unrenderedEdges.push(b);
                g && this._flushUnrenderedEdges()
            }
        },
        {
            key: "_maybeRenderEdge",
            value: function(b) {
                var g = this.getRenderedEndpoint(b.target.getFullId()) || this.getRenderedElement(b.target),
                m = this.getRenderedEndpoint(b.source.getFullId()) || this.getRenderedElement(b.source);
                return null == g || null == m ? null: this._doRenderEdge(b)
            }
        },
        {
            key: "_doRenderEdge",
            value: function(b) {
                var g = this.view.getEdgeDefinition(this.dataSource.getEdgeType(b.data || {})),
                m = this._prepareConnectionParams(b);
                g = this._connect(m, b, g);
                if (null != g) {
                    var r = g.connector;
                    m.geometry && r.importGeometry && (r.importGeometry(m.geometry, g), this.jsplumb.paintConnection(g));
                    g.edge = b;
                    this.connMap[b.getId()] = g;
                    this.fire("edge:added", {
                        source: b.source,
                        target: b.target,
                        connection: g,
                        edge: b,
                        geometry: b.geometry
                    });
                    this.refreshLayoutOnEdgeConnect && this.refresh(!0);
                    m = qa(b.source) ? b.source.getParent() : b.source;
                    m = this.jsplumb.getManagedElement(m.id);
                    r = qa(b.target) ? b.target.getParent() : b.target; ! 1 !== this.jsplumb.getManagedElement(r.id)._jtkVisible && !1 !== m._jtkVisible || this._toggleEdge(b, !1)
                } else console.log("jsPlumb: WARN : An edge could not be rendered " + b + " and is being removed from the dataset."),
                this.dataSource.removeEdge(b);
                return g
            }
        },
        {
            key: "_toggleEdge",
            value: function(b, g, m) { (b = this.getConnectionForEdge(b)) && (!g || !1 !== b.endpoints[0].element._jtkVisible && !1 !== b.endpoints[1].element._jtkVisible) && (b.setVisible(g), m || (Ug(b, b.endpoints[0], g), Ug(b, b.endpoints[1], g)))
            }
        },
        {
            key: "_getStateTarget",
            value: function(b) {
                return null == b ? this.dataSource: "string" == typeof b ? this.toolkitInstance.select(b, !0) : b.jtk ? (b = b.jtk, this.toolkitInstance.select(b.port || b.node, !0)) : b
            }
        },
        {
            key: "vertexRendered",
            value: function(b, g, m, r) {
                if (!g) throw Error("Cannot render vertex");
                g.setAttribute("data-jtk-vertex", b.getFullId());
                var t = ka(b),
                u = ra(b),
                v = t ? "jtk-node": u ? "jtk-group": qa(b) ? "jtk-port": ""; (this.jsplumb.addClass(g, v), g.jtk = g.jtk || {},
                g.jtk[b.objectType.toLowerCase()] = b, g.jtk.vertex = b, this.jsplumb.manage(g, b.id), (ka(b) || ra(b)) && (this._extractEndpointFromElementAndDefinition(g, b), this.vertexList.push(b)), t && (g.jtk = {
                    node: b
                }), u && (g.jtk = {
                    group: b
                }), u || ka(b) && null == b.group ? this._append(g, b.id, r ? r.position: null) : ka(b) && this._appendNodeToGroup(g, b, b.group), this.viewport.refreshElement(b.id), null != b.data.rotation && this.jsplumb.rotate(g, b.data.rotation), ka(b)) ? (this._doAssignDragGroup(g, b), g = {
                    el: g,
                    id: b.id,
                    vertex: b
                },
                null == b.group && (g.pos = this._layout.vertexAdded(g, r)), this.fireNodeAdded(g)) : ra(b) && (this._doAssignDragGroup(g, b), t = {
                    el: g,
                    vertex: b,
                    id: b.id
                },
                this.jsplumb.addGroup(A({
                    el: g,
                    id: b.id
                },
                m)), null != b.group && this.jsplumb.addToGroup(b.group.id, g), this._layoutMap.set(b.id, this._createGroupLayout(m.layout || {
                    type: Hc.type
                },
                b)), t.pos = this._layout.vertexAdded({
                    el: g,
                    id: b.id,
                    vertex: b
                },
                r), this.fire("group:added", t));
                this._flushUnrenderedEdges();
                this.refresh(!0)
            }
        }]),
        c
    } ();
    D(rf, "type", "Surface");
    var Ri = {},
    de = {
        get: function(e) {
            var c = Ri[e];
            if (c) return new c;
            throw {
                message: "jsPlumbToolkit: unknown surface plugin '" + e + "'"
            };
        },
        register: function(e, c) {
            Ri[e] = c
        }
    }; (function(e) {
        function c() {
            return Aa(this, c),
            h.apply(this, arguments)
        }
        Vb(c, Uh);
        var h = Wb(c);
        return Ia(c, [{
            key: "executeAtEvent",
            value: function(b, g) {
                var m = this.container,
                r = this.getContainerPosition(m),
                t = b.pageX - r.x + m.scrollLeft;
                m = b.pageY - r.y + m.scrollTop;
                this.debug && (this.originDebugMarker.style.left = b.pageX + "px", this.originDebugMarker.style.top = b.pageY + "px");
                this.executeAtPoint({
                    x: t,
                    y: m
                },
                g)
            }
        }]),
        c
    })();
    var Si = function() {
        function e(c) {
            fd(this, e);
            hb(this, "knockle", void 0);
            hb(this, "reactive", !1);
            hb(this, "surface", null);
            hb(this, "currentVertex", null);
            c = c || {};
            if (this.knockle = new mi({
                defaultTemplate: '<div data-jtk-node-id="${id}" class="jtk-node"></div>',
                templateResolver: c.templateResolver,
                templates: c.templates
            },
            jl, kl), c.tags) for (var h in c.tags) this.registerTag(h, c.tags[h])
        }
        return gd(e, [{
            key: "render",
            value: function(c, h, b, g, m, r, t, u) {
                this.surface = m;
                this.currentVertex = t;
                c = this.knockle.template(c, h).childNodes[0];
                m.vertexRendered(t, c, r, null)
            }
        },
        {
            key: "_cleanup",
            value: function(c) {
                this.knockle.remove(c, !0)
            }
        },
        {
            key: "cleanupVertex",
            value: function(c, h) {
                this._cleanup(h)
            }
        },
        {
            key: "cleanupPort",
            value: function(c, h) {
                this._cleanup(h)
            }
        },
        {
            key: "addTemplate",
            value: function(c, h) {
                this.knockle.addTemplate(c, h)
            }
        },
        {
            key: "registerTag",
            value: function(c, h, b) {
                var g = this;
                this.knockle.registerTag(c, {
                    template: h.template,
                    rendered: function(m, r, t) {
                        h.rendered(m, r, t, g.surface, g.currentVertex)
                    },
                    updated: function(m, r, t) {
                        h.updated(m, r, t, g.surface, g.currentVertex)
                    }
                },
                b)
            }
        },
        {
            key: "update",
            value: function(c, h, b) {
                if (c._rotors && c._rotors.instance === this.knockle) for (this.currentVertex = b.getModelObjectFromElement(c), this.surface = b, c = this.knockle.update(c, h), h = 0; h < c.removed.length; h++) 3 !== c.removed[h].el.nodeType && 8 !== c.removed[h].el.nodeType && b.jsplumb.unmanage(c.removed[h].el, !0)
            }
        }]),
        e
    } (),
    $g = function(e) {
        function c() {
            return fd(this, c),
            h.apply(this, arguments)
        }
        Wg(c, Tl);
        var h = Zg(c);
        return gd(c, [{
            key: "render",
            value: function(b, g) {
                var m = new Si(g);
                g = A({
                    dataSource: this,
                    container: b
                },
                g || {});
                null != g.selection && ("function" != typeof g.selection ? g.dataSource = g.selection: g.dataSource = new Db(this, {
                    generator: g.selection
                }));
                g.toolkitInstance = this;
                b = g.id || fa();
                m = new rf(g, m);
                return this.addRenderer(m, b),
                m
            }
        }]),
        c
    } (); (function() {
        function e(c) {
            var h = this;
            if (fd(this, e), this.params = c, hb(this, "jsplumb", void 0), hb(this, "toolkit", void 0), hb(this, "render", void 0), hb(this, "conns", void 0), hb(this, "portEndpointMappings", []), hb(this, "surface", void 0), this.jsplumb = c.jsPlumb, !this.jsplumb.getContainer()) throw new TypeError("No container set on jsPlumb instance. Cannot continue.");
            if (this.toolkit = new $g, this.conns = this.jsplumb.select(), this.render = !1 !== c.render, c.nodeSelector) for (var b = this.jsplumb.getContainer().querySelectorAll(c.nodeSelector), g = 0; g < b.length; g++) {
                var m = this.jsplumb.getId(b[g]);
                this.portEndpointMappings.push.apply(this.portEndpointMappings, this._addNode(b[g], m));
                this.jsplumb.manage(b[g])
            }
            b = this.jsplumb.getManagedElements();
            for (var r in b) this.portEndpointMappings.push.apply(this.portEndpointMappings, this._addNode(b[r].el, r));
            if (this.conns.each(function(u) {
                h._addEdge(u)
            }), this.render) {
                c = A({},
                c.renderParams || {});
                c.layout = c.layout || {
                    type: Hc.type
                };
                this.surface = e.render(this, this.jsplumb.getContainer(), c);
                for (c = 0; c < this.portEndpointMappings.length; c++) this.surface._ingestEndpoint(this.portEndpointMappings[c][0], this.portEndpointMappings[c][1]);
                for (var t in b) this.surface.importNode(b[t].el, t)
            }
        }
        return gd(e, [{
            key: "idFunction",
            value: function(c) {
                return this.params.idFunction ? this.params.idFunction(c) : this.jsplumb.getId(c)
            }
        },
        {
            key: "typeFunction",
            value: function(c) {
                return this.params.typeFunction ? this.params.typeFunction(c) : "default"
            }
        },
        {
            key: "edgeIdFunction",
            value: function(c) {
                return this.params.edgeIdFunction ? this.params.edgeIdFunction(c) : c.id
            }
        },
        {
            key: "edgeTypeFunction",
            value: function(c) {
                return this.params.edgeTypeFunction ? this.params.edgeTypeFunction(c) : "default"
            }
        },
        {
            key: "_addEdge",
            value: function(c) {
                var h = this.toolkit.getNode(c.sourceId),
                b = this.toolkit.getNode(c.targetId),
                g = this.edgeIdFunction(c),
                m = this.edgeTypeFunction(c),
                r = c.endpoints[0].parameters.portId,
                t = c.endpoints[1].parameters.portId;
                null != r && (h = h.getPort(r));
                null != t && (b = b.getPort(t));
                c.edge = this.toolkit.addEdge({
                    source: h,
                    target: b,
                    data: {
                        id: g,
                        type: m
                    }
                },
                null, !0)
            }
        },
        {
            key: "_addNode",
            value: function(c, h) {
                var b = this.idFunction(c),
                g = this.typeFunction(c),
                m = this.jsplumb.getId(c),
                r = [];
                h = h || {};
                var t = this.jsplumb.getOffset(c);
                h = this.toolkit.addNode(A({
                    id: b,
                    type: g,
                    left: t.x,
                    top: t.y
                },
                h), null, !0);
                c.jtk = {
                    node: h
                };
                c = this.jsplumb.getEndpoints(c);
                if (0 < c.length) for (b = 0; b < c.length; b++) g = this.toolkit.addPort(h, {
                    id: "" + b
                },
                !0),
                r.push([g, c[b]]),
                c[b].mergeParameters({
                    portId: "" + b,
                    nodeId: m
                });
                return r
            }
        }], [{
            key: "render",
            value: function(c, h, b) {
                var g = A({
                    ingester: c
                },
                b);
                g.dataSource = c.toolkit;
                g.container = h;
                g.toolkitInstance = c.toolkit;
                g.jsPlumbInstance = c.jsplumb;
                h = new Ti(g, new Si(b));
                return c.toolkit.addRenderer(h, b.id),
                h
            }
        }]),
        e
    })();
    var Ti = function(e) {
        function c(b, g) {
            var m;
            return fd(this, c),
            hb(Yg(m = h.call(this, b, g)), "ingester", void 0),
            m.ingester = b.ingester,
            m
        }
        Wg(c, rf);
        var h = Zg(c);
        return gd(c, [{
            key: "importNode",
            value: function(b, g) {
                this.jsplumb.getId(b);
                sa(b, "jtk-node");
                this.jsplumb.manage(b);
                g = {
                    el: b,
                    id: b.jtk.node.id,
                    vertex: b.jtk.node
                };
                null == b.jtk.node.group && this._layout.vertexAdded(g);
                this.fireNodeAdded(g)
            }
        },
        {
            key: "ingest",
            value: function(b, g) {
                this.jsplumb.getContainer().appendChild(b);
                g = this.ingester._addNode(b, g);
                this.importNode(b, this.ingester.idFunction(b));
                for (b = 0; b < g.length; b++) this._ingestEndpoint(g[b][0], g[b][1])
            }
        },
        {
            key: "_loadExistingData",
            value: function(b) {
                var g = this,
                m = b.jsPlumbInstance.select(),
                r;
                for (r in m.each(function(t) {
                    g.connMap[t.edge.getId()] = t
                }), b = b.jsPlumbInstance.getManagedElements()) m = b[r].el,
                this.vertexList.push(m.jtk.node),
                m = {
                    vertex: m.jtk.node,
                    el: m,
                    id: m.jtk.node.id
                },
                null == b.group && (m.pos = this._layout.vertexAdded(m)),
                this.fireNodeAdded(m)
            }
        }]),
        c
    } ();
    hb(Ti, "ingestedSurfaceType", "IngestedSurface");
    var sf = [],
    Ui = !1,
    tf = function() {
        Ui = !0;
        for (var e = 0; e < sf.length; e++) sf[e]()
    },
    $l = function() {
        function e(c) {
            fd(this, e);
            this.templateHolder = c;
            hb(this, "c", 0)
        }
        return gd(e, [{
            key: "_dec",
            value: function() {
                this.c--;
                0 >= this.c && tf()
            }
        },
        {
            key: "add",
            value: function(c) {
                var h = this;
                this.c++;
                Tg({
                    url: c,
                    success: function(b) {
                        var g = h.templateHolder.innerHTML;
                        h.templateHolder.innerHTML = g + b;
                        h._dec()
                    },
                    error: function(b) {
                        h._dec()
                    }
                })
            }
        },
        {
            key: "ensureNotEmpty",
            value: function() {
                0 >= this.c && tf()
            }
        }]),
        e
    } (); (function() { !
        function c() {
            if (/complete|loaded|interactive/.test(document.readyState) && void 0 !== document.body && null != document.body) {
                var h = document.getElementById("jsPlumbToolkitTemplates");
                if (h) tf();
                else { (h = document.createElement("div")).style.display = "none";
                    h.id = "jsPlumbToolkitTemplates";
                    document.body.appendChild(h);
                    h = new $l(h);
                    for (var b = document.getElementsByTagName("script"), g = 0; g < b.length; g++) {
                        var m = b[g].getAttribute("type"),
                        r = b[g].getAttribute("src");
                        "text/x-jtk-templates" == m && h.add(r)
                    }
                    h.ensureNotEmpty()
                }
            } else setTimeout(c, 9)
        } ()
    })();
    var am = function() {
        function e(c) {
            var h = this;
            ah(this, e);
            Da(this, "current", void 0);
            Da(this, "currentConnector", void 0);
            Da(this, "currentEdge", void 0);
            Da(this, "currentSourceVertex", void 0);
            Da(this, "currentTargetVertex", void 0);
            Da(this, "currentOverlays", []);
            Da(this, "sourceDimensions", void 0);
            Da(this, "targetDimensions", void 0);
            Da(this, "sourceAnchorPlaceholder", void 0);
            Da(this, "targetAnchorPlaceholder", void 0);
            Da(this, "active", void 0);
            Da(this, "_surface", void 0);
            Da(this, "jsplumb", void 0);
            Da(this, "eventManager", void 0);
            Da(this, "update", void 0);
            Da(this, "cleanup", void 0);
            Da(this, "dragManager", void 0);
            Da(this, "dragHandler", void 0);
            Da(this, "_dragHandlers", {});
            Da(this, "_anchorDragContext", {
                rotation: 0,
                center: {
                    x: 0,
                    y: 0
                }
            });
            this.active = !1;
            this._surface = c.surface;
            this.jsplumb = this._surface.jsplumb;
            this._surface.toolkitInstance.bind("graphClearStart",
            function() {
                h.deactivate()
            });
            this._surface.toolkitInstance.bind("edge:removed",
            function(b) {
                b.edge === h.currentEdge && h.deactivate()
            });
            this._surface.toolkitInstance.bind("edge:pathRestored",
            function(b) {
                b.edge == h.currentEdge && h.repaintConnection()
            });
            this.jsplumb.bind("internal.connectionDetached",
            function(b) {
                b.connection === h.current && h.deactivate()
            });
            this.eventManager = new $b;
            this.dragManager = new nf;
            this.dragHandler = this.dragManager.draggable(this.jsplumb.getContainer(), {});
            this.dragHandler.addSelector({
                selector: ".jtk-anchor-placeholder",
                constrainFunction: function(b, g, m, r) {
                    var t = g._jsPlumbAnchor.anchor,
                    u = g._jsPlumbAnchor.endpoint,
                    v = g._jsPlumbAnchor.idx;
                    if (0 !== h._anchorDragContext.rotation) {
                        var w = h.dragHandler._posAtDown;
                        b = qb({
                            x: b.x - w.x,
                            y: b.y - w.y
                        },
                        h._anchorDragContext.center, -h._anchorDragContext.rotation)
                    }
                    b = lb(t) ? dk(t, u, b, g, m, r, v, h.current.connector, h.jsplumb) : ek(t, u, b, g, m, r, v, h.current.connector);
                    h.jsplumb.revalidate(g.parentNode);
                    u = [g.offsetWidth, g.offsetHeight];
                    g = -u[0] / 2;
                    r = m.w - u[0] / 2;
                    t = -u[1] / 2;
                    m = m.h - u[1] / 2;
                    return {
                        x: b.x < g ? g: b.x > r ? r: b.x,
                        y: b.y < t ? t: b.y > m ? m: b.y
                    }
                },
                start: function(b) {
                    b = b.drag.getDragElement();
                    var g = b._jsPlumbAnchor.anchor,
                    m = b._jsPlumbAnchor.endpoint,
                    r = b.parentNode,
                    t = h.jsplumb.getId(r);
                    if (h._anchorDragContext.rotation = h.jsplumb._getRotation(t), 0 !== h._anchorDragContext.rotation) r = h.jsplumb.getSize(r),
                    h._anchorDragContext.center = {
                        x: r.w / 2,
                        y: r.h / 2
                    };
                    lb(g) ? b.parentNode.setAttribute("jtk-anchor-face", g.currentFace) : g.locations.map(function(u) {
                        return [u.x, u.y, u.ox, u.oy]
                    }).forEach(function(u) {
                        var v = m.element,
                        w = u[0];
                        u = u[1];
                        var z = Ja(v);
                        w *= z.w;
                        u *= z.h;
                        z = fh(w, u, "jtk-anchor-candidate");
                        v.appendChild(z);
                        v = Ja(z);
                        z.style.left = w - v.w / 2 + "px";
                        z.style.top = u - v.h / 2 + "px"
                    })
                },
                stop: function(b) {
                    var g = b.el.parentNode;
                    b = b.drag.getDragElement();
                    var m = b._jsPlumbAnchor.endpoint;
                    lb(b._jsPlumbAnchor.anchor) && g.removeAttribute("jtk-anchor-face");
                    m.element.querySelectorAll(".jtk-anchor-candidate").forEach(function(r) {
                        return r.parentNode.removeChild(r)
                    });
                    h._drawAnchors();
                    h._update();
                    h.fireConnectionEditEvent()
                },
                drag: function(b) {
                    h._update()
                }
            },
            !0);
            this._surface.bind("node:move:end",
            function(b) {
                h.active && h.currentEdge && (b.vertex === h.currentEdge.source || b.vertex === h.currentEdge.target) && (h._elementDragged(b), h.fireConnectionEditEvent())
            });
            this._surface.bind("node:move",
            function(b) {
                h.active && h.currentEdge && (b.vertex === h.currentEdge.source || b.vertex === h.currentEdge.target) && h._elementDragging(b)
            });
            this._surface.bind("group:move:end",
            function(b) {
                h.active && h.currentEdge && (b.vertex === h.currentEdge.source || b.vertex === h.currentEdge.target) && (h._elementDragged(b), h.fireConnectionEditEvent())
            });
            this._surface.bind("group:move",
            function(b) {
                h.active && h.currentEdge && (b.vertex === h.currentEdge.source || b.vertex === h.currentEdge.target) && h._elementDragging(b)
            });
            this._surface.toolkitInstance.bind("node:updated",
            function(b) {
                h.active && h.currentEdge && (b.vertex === h.currentEdge.source || b.vertex === h.currentEdge.target) && (h._elementDragged(b), h.fireConnectionEditEvent())
            });
            this._surface.toolkitInstance.bind("group:updated",
            function(b) {
                h.active && h.currentEdge && (b.vertex === h.currentEdge.source || b.vertex === h.currentEdge.target) && (h._elementDragged(b), h.fireConnectionEditEvent())
            });
            this.jsplumb.bind("zoom",
            function(b) {
                h.dragManager.setZoom(b)
            })
        }
        return ch(e, [{
            key: "_attachOverlay",
            value: function(c, h, b) {
                c = {
                    type: b.type,
                    options: A(b.options, {
                        id: fa()
                    })
                };
                this.currentOverlays.push(h.addOverlay(c));
                this.repaintConnection()
            }
        },
        {
            key: "_attachOverlays",
            value: function(c, h, b) {
                var g = this;
                this._detachOverlays();
                b.forEach(function(m) {
                    g._attachOverlay(c, h, m)
                })
            }
        },
        {
            key: "_detachOverlays",
            value: function() {
                var c = this;
                this.currentOverlays.forEach(function(h) {
                    c.current.removeOverlay(h.id)
                })
            }
        },
        {
            key: "_attachDeleteButton",
            value: function(c, h) {
                var b = this,
                g = h.deleteButtonClass || "jtk-edge-delete",
                m = h.deleteButtonLocation || .1,
                r = function() {
                    return c.toolkitInstance.removeEdge(b.currentEdge)
                },
                t = function() {
                    h.onMaybeDelete ? h.onMaybeDelete(b.currentEdge, b.current, r) : r()
                };
                Array.isArray(m) || (m = [m]);
                m.forEach(function(u) {
                    b._attachOverlay(c, b.current, {
                        type: Fb.type,
                        options: {
                            location: u,
                            cssClass: g,
                            events: {
                                click: t
                            }
                        }
                    })
                })
            }
        },
        {
            key: "repaintConnection",
            value: function(c) {
                this.current && (this.jsplumb.paintConnection(this.current, c), this.refresh(c))
            }
        },
        {
            key: "fireConnectionEditEvent",
            value: function() {
                this._surface._connectionEdited(this.current)
            }
        },
        {
            key: "refresh",
            value: function(c) {
                this.current && (this._drawAnchors(), this._repaint && this._repaint(c))
            }
        },
        {
            key: "_drawAnchors",
            value: function() {
                var c = this;
                if (this.current) {
                    var h = function(g, m) {
                        var r = c.current.endpoints[g],
                        t = r._anchor;
                        if (t.isDynamic || t.isContinuous) {
                            var u = A({},
                            t.computedPosition),
                            v = c.jsplumb.getOffset(r.element),
                            w = c.jsplumb._getRotation(r.elementId);
                            if (0 !== w) {
                                var z = c.jsplumb.getSize(r.element);
                                w = qb({
                                    x: u.curX,
                                    y: u.curY
                                },
                                {
                                    x: v.x + z.w / 2,
                                    y: v.y + z.h / 2
                                },
                                -w);
                                u.curX = w.x;
                                u.curY = w.y
                            }
                            var y;
                            w = [u.curX - v.x, u.curY - v.y];
                            u = w[0];
                            w = w[1];
                            null != m ? y = m: (y = fh(u, w, "jtk-anchor-placeholder"), r.element.appendChild(y), c._setElementPosition(y, u, w), y._jsPlumbAnchor = {
                                anchor: t,
                                endpoint: r,
                                idx: g
                            });
                            g = c.jsplumb.getSize(y);
                            return y.style.left = u - g.w / 2 + "px",
                            y.style.top = w - g.h / 2 + "px",
                            [[v.x, v.y], y]
                        }
                        return [[0, 0], null]
                    },
                    b = dh(h(0, this.sourceAnchorPlaceholder), 2);
                    this.sourceDimensions = b[0];
                    this.sourceAnchorPlaceholder = b[1];
                    h = dh(h(1, this.targetAnchorPlaceholder), 2);
                    this.targetDimensions = h[0];
                    this.targetAnchorPlaceholder = h[1]
                }
            }
        },
        {
            key: "_cleanupAnchors",
            value: function() {
                this.current && (this.sourceAnchorPlaceholder && (this.sourceAnchorPlaceholder.parentNode.removeChild(this.sourceAnchorPlaceholder), delete this.sourceAnchorPlaceholder._jsPlumbAnchor), this.targetAnchorPlaceholder && (this.targetAnchorPlaceholder.parentNode.removeChild(this.targetAnchorPlaceholder), delete this.targetAnchorPlaceholder._jsPlumbAnchor));
                this.targetDimensions = this.sourceDimensions = this.targetAnchorPlaceholder = this.sourceAnchorPlaceholder = null
            }
        },
        {
            key: "_clearGeometry",
            value: function() {
                this.current && this.current.connector.resetGeometry()
            }
        },
        {
            key: "reset",
            value: function() {
                this.deactivate();
                this._clearGeometry();
                this._clearHandles();
                this.jsplumb.revalidate(this.current.source);
                this.jsplumb.revalidate(this.current.target);
                this.jsplumb.fire("clearConnectionEdits", this.current)
            }
        },
        {
            key: "isActive",
            value: function() {
                return this.active
            }
        },
        {
            key: "_setElementPosition",
            value: function(c, h, b) {
                var g = this.jsplumb.getSize(c);
                b -= g.h / 2;
                c.style.left = h - g.w / 2 + "px";
                c.style.top = b + "px"
            }
        },
        {
            key: "activate",
            value: function(c, h, b) {
                this.deactivate();
                this.current = h;
                this.currentConnector = this.current.connector;
                this.currentEdge = this.current.edge;
                this.currentSourceVertex = this.currentEdge.source;
                this.currentTargetVertex = this.currentEdge.target;
                this.dragManager.setZoom(this.jsplumb.currentZoom);
                this._activate(c, h, b);
                b.overlays && this._attachOverlays(c, h, b.overlays); ! 0 === b.deleteButton && this._attachDeleteButton(c, b);
                c = this.current.endpoints[1]._anchor;
                this.jsplumb.router.lock(this.current.endpoints[0]._anchor);
                this.jsplumb.router.lock(c);
                this._drawAnchors();
                this.current.addClass("jtk-connection-edit");
                this.active = !0;
                this.jsplumb.fire("startConnectionEdit", this.current)
            }
        },
        {
            key: "deactivate",
            value: function(c) {
                null != this.current && (this._detachOverlays(), this.current._paint = null, this.current.removeClass("jtk-connection-edit"), this._cleanupAnchors());
                this._clearHandles();
                null != this.current && this.jsplumb.fire("stopConnectionEdit", this.current);
                this.active = !1;
                this.currentEdge = this.current = null
            }
        },
        {
            key: "_addDragHandler",
            value: function(c) {
                this.dragHandler.addSelector(c);
                this._dragHandlers[c.selector] = c
            }
        }]),
        e
    } (),
    ee = new Map,
    bm = function() {
        function e(c) {
            var h = this;
            ah(this, e);
            this.surface = c;
            Da(this, "_connectorEditors", new Map);
            c.bind("destroy",
            function() {
                return h.destroy()
            })
        }
        return ch(e, [{
            key: "startEditing",
            value: function(c, h) {
                c = this._resolveConnection(c);
                if (null != c) {
                    h = A({},
                    h || {});
                    var b = c.connector.type;
                    if (!ee.has(b)) throw Error("No editor available for connector type [" + b + "]");
                    if (!this._connectorEditors.has(b)) {
                        var g = A({},
                        h);
                        g.surface = this.surface;
                        g = new(ee.get(b))(g);
                        this._connectorEditors.set(b, g)
                    }
                    this._connectorEditors.get(b).activate(this.surface, c, h)
                }
            }
        },
        {
            key: "stopEditing",
            value: function() {
                this._connectorEditors.forEach(function(c) {
                    return c.deactivate()
                })
            }
        },
        {
            key: "clearEdits",
            value: function(c) {
                c = this._resolveConnection(c);
                return null != c && (c.connector.resetGeometry(), !0)
            }
        },
        {
            key: "_resolveConnection",
            value: function(c) {
                return null == c ? null: "string" == typeof c ? this.surface.getRenderedConnection(c) : c instanceof mc ? c: this.surface.getRenderedConnection(c.getId())
            }
        },
        {
            key: "destroy",
            value: function() {
                this._connectorEditors.clear()
            }
        }]),
        e
    } ();
    var cm = function() {
        function e(c) {
            var h = this;
            gh(this, e);
            Y(this, "surface", void 0);
            Y(this, "surfaceCanvas", void 0);
            Y(this, "surfaceCanvasPlaceholder", void 0);
            Y(this, "source", void 0);
            Y(this, "selector", void 0);
            Y(this, "elements", void 0);
            Y(this, "dropFilter", void 0);
            Y(this, "canvasDropFilter", void 0);
            Y(this, "edgeDropFilter", void 0);
            Y(this, "scope", void 0);
            Y(this, "onEdgeDrop", void 0);
            Y(this, "onDrop", void 0);
            Y(this, "onCanvasDrop", void 0);
            Y(this, "dragActiveClass", void 0);
            Y(this, "dragHoverClass", void 0);
            Y(this, "dataGenerator", void 0);
            Y(this, "onDrag", void 0);
            Y(this, "canvasSelector", void 0);
            Y(this, "currentNodeList", void 0);
            Y(this, "currentEdgeList", void 0);
            Y(this, "candidateData", void 0);
            Y(this, "candidate", void 0);
            Y(this, "canvasMoveListener", void 0);
            Y(this, "canvasMouseOutListener", void 0);
            Y(this, "isCurrentlyOnCanvasElement", void 0);
            Y(this, "canDropOnCanvas", void 0);
            Y(this, "viewportPosition", null);
            Y(this, "enabled", void 0);
            Y(this, "_translateX", 0);
            Y(this, "_translateY", 0);
            Y(this, "ignoreGrid", void 0);
            Y(this, "grid", void 0);
            Y(this, "drag", void 0);
            Y(this, "dragManager", void 0);
            this.surface = c.surface;
            this.surfaceCanvas = this.surface.getContainer().parentNode;
            this.surfaceCanvasPlaceholder = this.surfaceCanvas.querySelector(".jtk-surface-canvas");
            this.grid = this.surface.getGrid();
            this.ignoreGrid = !0 === c.ignoreGrid;
            this.enabled = !1 !== c.enabled;
            this.canvasSelector = c.canvasSelector || null;
            this.source = c.source;
            this.selector = c.selector;
            this.scope = c.scope || fa();
            this.dropFilter = c.dropFilter ||
            function(b, g) {
                return ! 0
            };
            this.canvasDropFilter = c.canvasDropFilter ||
            function(b) {
                return ! 0
            };
            this.edgeDropFilter = c.edgeDropFilter ||
            function(b, g) {
                return ! 0
            };
            this.onDrag = c.onDrag;
            this.onDrop = c.onDrop;
            this.onEdgeDrop = c.onEdgeDrop;
            this.onCanvasDrop = c.onCanvasDrop;
            this.dragActiveClass = c.dragActiveClass || "jtk-drag-drop-active";
            this.dragHoverClass = c.dragHoverClass || "jtk-drag-drop-hover";
            this.currentNodeList = [];
            this.dataGenerator = c.dataGenerator ||
            function() {
                return {}
            };
            this.canvasMoveListener = function(b) {
                b = b.srcElement || b.target;
                h.isCurrentlyOnCanvasElement = b === h.surfaceCanvas || b === h.surfaceCanvasPlaceholder || null != h.canvasSelector && Bb(b, h.canvasSelector)
            };
            this.canvasMouseOutListener = function(b) {
                h.isCurrentlyOnCanvasElement = !1
            };
            this.dragManager = new nf;
            this.drag = this.dragManager.draggable(this.source, {
                scope: this.scope,
                clone: !0,
                constrainFunction: function(b, g, m, r) {
                    if (h.ignoreGrid || null == h.grid || !h.surface.isInViewport(b.x, b.y)) return b;
                    b = h.surface.fromPageLocation(b.x - h._translateX, b.y - h._translateY);
                    b = h.surface.toPageLocation((0 > b.x ? Math.ceil(b.x / h.grid.w) : Math.floor(b.x / h.grid.w)) * h.grid.w, (0 > b.y ? Math.ceil(b.y / h.grid.h) : Math.floor(b.y / h.grid.h)) * h.grid.h);
                    return {
                        x: b.x + h._translateX,
                        y: b.y + h._translateY
                    }
                },
                start: function(b) {
                    if (!h.enabled) return ! 1;
                    b = b.drag.getDragElement(); (b.style.pointerEvents = "none", h.candidateData = h.dataGenerator(b), h.currentNodeList.length = 0, h.candidate = null, h._adjustForTransformations(), h.onDrop) && (h.getAllNodesAndGroups().forEach(function(g) {
                        var m = h.surface.getRenderedElement(g);
                        if (m) if (h.dropFilter(h.candidateData, g)) {
                            var r = h.surface.getViewportPosition(g),
                            t = h.surface.toPageLocation(r.x, r.y),
                            u = r.w * h.surface.getZoom();
                            r = r.h * h.surface.getZoom();
                            h.currentNodeList.push({
                                vertex: g,
                                element: m,
                                apparentBounds: A(t, {
                                    w: u,
                                    h: r
                                })
                            });
                            h.surface.addClass(m, h.dragActiveClass)
                        } else h.surface.removeClass(m, h.dragActiveClass)
                    }), h.currentNodeList.sort(function(g, m) {
                        if (ra(g.vertex) && ra(m.vertex)) {
                            var r = h.surface.toolkitInstance.graph;
                            if (r.isAncestor(g.vertex, m.vertex)) return - 1;
                            if (r.isAncestor(m.vertex, g.vertex)) return 1
                        }
                        return 0
                    }));
                    h.currentEdgeList = h.onEdgeDrop ? h.getAllConnectors(h.candidateData) : [];
                    h.onCanvasDrop && h.canvasDropFilter(h.candidateData) && (h.canDropOnCanvas = !0, h.isCurrentlyOnCanvasElement = !1, h.surface.on(h.surfaceCanvas, "mousemove", h.canvasMoveListener), h.surface.on(h.surfaceCanvas, "mouseout", h.canvasMouseOutListener))
                },
                stop: function(b) {
                    h.surface.off(h.surfaceCanvas, "mousemove", h.canvasMoveListener);
                    h.surface.off(h.surfaceCanvas, "mouseout", h.canvasMouseOutListener);
                    h._cleanupClasses();
                    var g = h.surface.fromPageLocation(h.viewportPosition.x, h.viewportPosition.y);
                    if (h.candidate) if (h.candidate.edge && h.onEdgeDrop) h.onEdgeDrop(h.candidateData, h.candidate.edge, b.el, b.e, b.pos, g);
                    else {
                        if (h.onDrop) {
                            var m = h.surface.toolkitInstance.getNode(h.candidate.id) || h.surface.toolkitInstance.getGroup(h.candidate.id);
                            if ("Group" === m.objectType) {
                                var r = h.surface.jsplumb.getGroup(m.id);
                                r = h.surface.jsplumb.getOffset(h.surface.jsplumb.getGroupContentArea(r))
                            } else r = h.surface.jsplumb.getOffset(h.surface.getRenderedElement(h.candidate.id));
                            h.onDrop(h.candidateData, m, b.el, b.e, b.pos, g, r, {
                                x: g.x - r.x,
                                y: g.y - r.y
                            })
                        }
                    } else h.canDropOnCanvas && h.isCurrentlyOnCanvasElement && null != h.viewportPosition && h.onCanvasDrop && h.onCanvasDrop(h.candidateData, g, b.el, b.e, b.pos);
                    h.isCurrentlyOnCanvasElement = !1
                },
                drag: function(b) {
                    h._cleanupClasses(!0);
                    var g = {
                        x: b.pos.x - h._translateX,
                        y: b.pos.y - h._translateY
                    };
                    h.viewportPosition = g;
                    h.candidate = null;
                    var m = h.surface.fromPageLocation(g.x, g.y);
                    if (h.onDrop) {
                        var r = A(g, b.drag._size),
                        t = h.currentNodeList.filter(function(y) {
                            return cc(y.apparentBounds, r)
                        })[0];
                        null != t && (h.candidate = {
                            r: t.apparentBounds,
                            id: t.vertex.id,
                            element: t.element
                        })
                    }
                    if (!h.candidate && h.onEdgeDrop) {
                        t = h.surface.getZoom();
                        t = {
                            x: m.x,
                            y: m.y,
                            w: b.drag._size.w / t,
                            h: b.drag._size.h / t
                        };
                        for (var u = 0; u < h.currentEdgeList.length; u++) {
                            var v = h.currentEdgeList[u],
                            w = v.r,
                            z = v.connector;
                            if (cc(t, w) && 0 < z.boundingBoxIntersection({
                                x: t.x - w.x,
                                y: t.y - w.y,
                                w: t.w,
                                h: t.h
                            }).length) {
                                h.candidate = v;
                                break
                            }
                        }
                    }
                    h.candidate ? h.surface.addClass(h.candidate.element, h.dragHoverClass) : h.canDropOnCanvas && (h.isCurrentlyOnCanvasElement = h.isEffectivelyOnCanvas(b.e), h.isCurrentlyOnCanvasElement && h.surface.isInViewport(g.x, g.y) ? (h.viewportPosition = g, h.surface.addClass(h.surfaceCanvas, h.dragHoverClass)) : h.surface.addClass(h.surface.getContainer(), h.dragActiveClass));
                    h.onDrag && h.onDrag(h.candidateData, b.e, g, m)
                },
                selector: this.selector,
                dragInit: function(b) {}
            })
        }
        return ih(e, [{
            key: "setEnabled",
            value: function(c) {
                this.enabled = c
            }
        },
        {
            key: "setSurface",
            value: function(c) {
                this.surface = c;
                this.surfaceCanvas = c.getContainer()
            }
        },
        {
            key: "isEffectivelyOnCanvas",
            value: function(c) {
                var h = this.isCurrentlyOnCanvasElement;
                return h || "touchmove" !== c.type || (h = !0),
                h
            }
        },
        {
            key: "getAllNodesAndGroups",
            value: function() {
                var c = [];
                return Array.prototype.push.apply(c, this.surface.toolkitInstance.getNodes()),
                Array.prototype.push.apply(c, this.surface.toolkitInstance.getGroups()),
                c
            }
        },
        {
            key: "_adjustForTransformations",
            value: function() {
                var c = 0,
                h = 0; !
                function m(g) {
                    if (null != g && g !== document.body) {
                        var r = window.getComputedStyle(g).transform.match(/(-?[0-9\.]+)/g);
                        r && (c += parseInt(r[4], 10), h += parseInt(r[5], 10));
                        m(g.parentNode)
                    }
                } (this.surface.jsplumb.getContainer().parentElement);
                this._translateX = c;
                this._translateY = h
            }
        },
        {
            key: "getAllConnectors",
            value: function(c) {
                var h = this,
                b = [];
                return this.surface.jsplumb.select().each(function(g) {
                    if (g.edge && h.edgeDropFilter(c, g.edge)) {
                        var m = g.connector,
                        r = m.canvas,
                        t = {
                            x: parseInt(r.style.left, 10),
                            y: parseInt(r.style.top, 10),
                            w: parseInt(r.getAttribute("width"), 10),
                            h: parseInt(r.getAttribute("height"), 10)
                        };
                        b.push({
                            connection: g,
                            connector: m,
                            element: r,
                            r: t,
                            id: g.edge.id,
                            edge: g.edge
                        });
                        h.surface.addClass(r, h.dragActiveClass)
                    }
                }),
                b
            }
        },
        {
            key: "_cleanupClasses",
            value: function(c) {
                var h = this;
                this.currentNodeList.forEach(function(b) {
                    c || h.surface.removeClass(b.element, h.dragActiveClass);
                    h.surface.removeClass(b.element, h.dragHoverClass)
                });
                this.currentEdgeList.forEach(function(b) {
                    c || h.surface.removeClass(b.element, h.dragActiveClass);
                    h.surface.removeClass(b.element, h.dragHoverClass)
                });
                this.surface.removeClass(this.surfaceCanvas, this.dragActiveClass);
                this.surface.removeClass(this.surfaceCanvas, this.dragHoverClass)
            }
        }]),
        e
    } (),
    dm = function() {
        function e(c) {
            var h = this;
            gh(this, e);
            Y(this, "surface", void 0);
            Y(this, "dropManager", void 0);
            Y(this, "toolkit", void 0);
            Y(this, "typeGenerator", void 0);
            Y(this, "groupIdentifier", void 0);
            Y(this, "modelPositionAttributes", void 0);
            Y(this, "magnetize", void 0);
            Y(this, "ignoreGrid", void 0);
            Y(this, "grid", void 0);
            Y(this, "allowDropOnEdge", void 0);
            Y(this, "allowDropOnGroup", void 0);
            Y(this, "allowDropOnCanvas", void 0);
            Y(this, "allowDropOnNode", void 0);
            this.surface = c.surface;
            this.toolkit = this.surface.toolkitInstance;
            this.modelPositionAttributes = this.surface.getModelPositionAttributes();
            this.typeGenerator = c.typeGenerator ||
            function(b) {
                return b.type
            };
            this.groupIdentifier = c.groupIdentifier ||
            function(b, g) {
                return "true" === g.getAttribute("data-jtk-is-group")
            };
            this.allowDropOnEdge = !1 !== c.allowDropOnEdge;
            this.allowDropOnGroup = !1 !== c.allowDropOnGroup;
            this.allowDropOnNode = !0 === c.allowDropOnNode;
            this.allowDropOnCanvas = !1 !== c.allowDropOnCanvas;
            this.magnetize = !1 !== c.magnetize;
            this.grid = this.surface.getGrid();
            this.ignoreGrid = !0 === c.ignoreGrid;
            this.dropManager = new cm({
                surface: this.surface,
                ignoreGrid: this.ignoreGrid,
                onCanvasDrop: this.allowDropOnCanvas ?
                function(b, g, m, r, t) {
                    h.addNewVertexToCanvas(b, g, m, r, t)
                }: null,
                onDrop: function(b, g, m, r, t, u, v, w) {
                    h.allowDropOnGroup && ra(g) ? (m = h.groupIdentifier(b, m), r = h.typeGenerator(b), b = h._mapToPositionAttributes({
                        group: g.id,
                        left: w.x,
                        top: w.y
                    },
                    b), t = function(z) {
                        h.surface.setPosition(z, w.x, w.y);
                        h.surface.relayoutGroup(g)
                    },
                    m ? h.toolkit.addFactoryGroup(r, b, t) : h.toolkit.addFactoryNode(r, b, t)) : h.allowDropOnNode && ka(g) && h.addNewVertexToCanvas(b, u, m, r, t)
                },
                onEdgeDrop: this.allowDropOnEdge ?
                function(b, g, m, r, t, u) {
                    r = h.typeGenerator(b);
                    t = h._mapToPositionAttributes({
                        x: u.x,
                        y: u.y
                    },
                    b);
                    var v = function(w) {
                        var z = g.source,
                        y = g.target;
                        h.toolkit.removeEdge(g);
                        h.toolkit.addEdge({
                            source: z,
                            target: w
                        });
                        h.toolkit.addEdge({
                            source: w,
                            target: y
                        }); ! 1 !== h.magnetize ? h.surface.setMagnetizedPosition(w, u.x, u.y, !0) : h.surface.setPosition(w, u.x, u.y)
                    };
                    h.groupIdentifier(b, m) ? h.toolkit.addFactoryGroup(r, t, v) : h.toolkit.addFactoryNode(r, t, v)
                }: null,
                source: c.source,
                selector: c.selector,
                dataGenerator: c.dataGenerator,
                canvasSelector: c.canvasSelector
            })
        }
        return ih(e, [{
            key: "_mapToPositionAttributes",
            value: function(c, h) {
                var b = {},
                g;
                for (g in c)"left" === g ? b[this.modelPositionAttributes[0]] = c[g] : "top" === g ? b[this.modelPositionAttributes[1]] = c[g] : b[g] = c[g];
                return A(b, h),
                b
            }
        },
        {
            key: "addNewVertexToCanvas",
            value: function(c, h, b, g, m) {
                var r = this;
                g = this.typeGenerator(c);
                b = this.groupIdentifier(c, b);
                c = this._mapToPositionAttributes({
                    left: h.x,
                    top: h.y
                },
                c);
                b ? this.toolkit.addFactoryGroup(g, c,
                function(t) {
                    r.surface.setPosition(t, h.x, h.y)
                }) : this.toolkit.addFactoryNode(g, c,
                function(t) {
                    r.surface.setPosition(t, h.x, h.y)
                })
            }
        },
        {
            key: "setEnabled",
            value: function(c) {
                this.dropManager.setEnabled(c)
            }
        },
        {
            key: "setSurface",
            value: function(c) {
                this.surface = c;
                this.toolkit = this.surface.toolkitInstance;
                this.modelPositionAttributes = this.surface.getModelPositionAttributes();
                this.dropManager.setSurface(c)
            }
        }]),
        e
    } ();
    var kh = 96 / 2.54,
    fe = [0, 0, 0, 0],
    Ve = {
        INCHES: "INCHES",
        CENTIMETERS: "CENTIMETERS"
    },
    em = {
        LETTER: [21.59, 27.94],
        A5: [14.8, 21],
        A4: [21, 29.7],
        A3: [29.7, 42],
        A2: [42, 59.4],
        A1: [59.4, 84.1],
        A0: [84.1, 118.9]
    },
    fm = function() {
        function e(c, h) {
            if (! (this instanceof e)) throw new TypeError("Cannot call a class as a function");
            this.surface = c;
            "id" in this ? Object.defineProperty(this, "id", {
                value: void 0,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : this.id = void 0;
            this.id = h || fa()
        }
        return fk(e, [{
            key: "scaleToBounds",
            value: function(c) {
                var h = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : fe,
                b = mh(this.surface);
                h = Math.min((c[0] - h[3] - h[1]) / b.w, (c[1] - h[0] - h[2]) / b.h);
                var g = this.surface.isClamping();
                return this.surface.setClamping(!1),
                this.surface.setZoom(h),
                this.surface.setPan( - b.x * h, -b.y * h),
                this.surface.setClamping(g),
                h
            }
        },
        {
            key: "scaleToPageDimensions",
            value: function(c) {
                var h = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : fe,
                b = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : "CENTIMETERS";
                return this.scaleToBounds(hd(c, b), hd(h, b))
            }
        },
        {
            key: "scaleToPageSize",
            value: function(c) {
                var h = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : fe,
                b = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : "CENTIMETERS";
                if ("FULL" === c) return this.scaleToFullPage(h, b);
                var g = em[c];
                if (g) return g = hd(g, Ve.CENTIMETERS),
                hd(h, b),
                lh(g, b);
                throw Error("Unknown page size " + c);
            }
        },
        {
            key: "scaleToFullPage",
            value: function() {
                var c = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : fe,
                h = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "CENTIMETERS",
                b = mh(this.surface),
                g = [b.w + 5, b.h + 5];
                c = hd(c, h);
                h = lh([g[0] + c[1] + c[3], g[1] + c[0] + c[2]], h);
                g = this.surface.isClamping();
                return this.surface.setClamping(!1),
                this.surface.setZoom(1),
                this.surface.setPan( - b.x, -b.y),
                this.surface.setClamping(g),
                h
            }
        },
        {
            key: "isReadyToPrint",
            value: function() {
                for (var c = this.surface.jsplumb.getContainer().querySelectorAll("img"), h = 0; h < c.length; h++) if (!c[h].complete) return ! 1;
                return ! 0
            }
        }]),
        e
    } ();
    var ge = function() {
        function e() {
            var c = this;
            if (! (this instanceof e)) throw new TypeError("Cannot call a class as a function");
            na(this, "surface", void 0);
            na(this, "toolkit", void 0);
            na(this, "jsp", void 0);
            na(this, "widthAtt", void 0);
            na(this, "heightAtt", void 0);
            na(this, "leftAtt", void 0);
            na(this, "topAtt", void 0);
            na(this, "xAxis", void 0);
            na(this, "yAxis", void 0);
            na(this, "onEdit", void 0);
            na(this, "onDemand", void 0);
            na(this, "skeletons", void 0);
            na(this, "downAt", void 0);
            na(this, "handler", void 0);
            na(this, "toolkitDragObject", void 0);
            na(this, "x1", void 0);
            na(this, "x2", void 0);
            na(this, "y1", void 0);
            na(this, "y2", void 0);
            na(this, "minimumHeight", void 0);
            na(this, "minimumWidth", void 0);
            na(this, "ignoreGrid", void 0);
            na(this, "grid", void 0);
            na(this, "_moving", !1);
            na(this, "_dragHandlers", {
                tl: function(h, b) {
                    h = c.x1 + h;
                    b = c.y1 + b;
                    var g = c.x2 - h,
                    m = c.y2 - b;
                    return h > c.x2 - c._minWidth() && (h = c.x2 - c._minWidth(), g = c._minWidth()),
                    b > c.y2 - c._minHeight() && (b = c.y2 - c._minHeight(), m = c._minHeight()),
                    c._dim(h, b, g, m)
                },
                tr: function(h, b) {
                    h = c.x2 - c.x1 + h;
                    b = c.y1 + b;
                    var g = c.y2 - b,
                    m = c.x1;
                    return h < c._minWidth() && (h = c._minWidth()),
                    b > c.y2 - c._minHeight() && (b = c.y2 - c._minHeight(), g = c._minHeight()),
                    c._dim(m, b, h, g)
                },
                bl: function(h, b) {
                    h = c.x1 + h;
                    b = c.y2 - c.y1 + b;
                    var g = c.x2 - h,
                    m = c.y1;
                    return h > c.x2 - c._minWidth() && (h = c.x2 - c._minWidth(), g = c._minWidth()),
                    b < c._minHeight() && (b = c._minHeight()),
                    c._dim(h, m, g, b)
                },
                br: function(h, b) {
                    h = c.x2 - c.x1 + h;
                    b = c.y2 - c.y1 + b;
                    var g = c.x1,
                    m = c.y1;
                    return h < c._minWidth() && (h = c._minWidth()),
                    b < c._minHeight() && (b = c._minHeight()),
                    c._dim(g, m, h, b)
                }
            })
        }
        return gk(e, [{
            key: "destroy",
            value: function() {}
        },
        {
            key: "initialise",
            value: function(c, h) {
                var b = this;
                this.surface = c;
                this.toolkit = c.toolkitInstance;
                this.jsp = c.jsplumb;
                this.skeletons = {};
                this.widthAtt = h.widthAttribute || "w";
                this.heightAtt = h.heightAttribute || "h";
                this.leftAtt = h.leftAttribute || "left";
                this.topAtt = h.topAttribute || "top";
                this.onEdit = h.onEdit ||
                function() {};
                this.onDemand = !0 === h.onDemand;
                this.minimumWidth = null != h.minimumWidth && 0 < h.minimumWidth ? h.minimumWidth: 30;
                this.minimumHeight = null != h.minimumHeight && 0 < h.minimumHeight ? h.minimumHeight: 30;
                this.grid = this.surface.getGrid();
                this.ignoreGrid = !0 === h.ignoreGrid;
                this.toolkit.bind("selection:cleared",
                function() {
                    b.reset()
                });
                this.toolkit.bind("select",
                function(r) { ! 0 !== b.onDemand && b._select(r.obj)
                });
                this.toolkit.bind("deselect",
                function(r) { ! 0 !== b.onDemand && b._deselect(r.obj)
                });
                var g = function(r) {
                    b._moving || b.toolkit.openTransaction();
                    b._moving = !0;
                    Ha(r);
                    var t = b.surface.mapEventLocation(r);
                    r = t.x - b.downAt.x;
                    t = t.y - b.downAt.y;
                    b.grid && !b.ignoreGrid && (r = (0 > r ? Math.ceil(r / b.grid.w) : Math.floor(r / b.grid.w)) * b.grid.w, t = (0 > t ? Math.ceil(t / b.grid.h) : Math.floor(t / b.grid.h)) * b.grid.h);
                    r = b.handler(r, t, "");
                    b.toolkit.update(b.toolkitDragObject, r);
                    b.surface.setPosition(b.toolkitDragObject, r[b.leftAtt], r[b.topAtt])
                },
                m = function u(t) {
                    b._moving = !1;
                    b.surface.storePositionInModel(b.toolkitDragObject.id);
                    b.jsp.removeClass(document.body, "jtk-drag-select-defeat");
                    b.jsp.off(document, "mousemove", g);
                    b.jsp.off(document, "mouseup", u);
                    Ha(t);
                    b.onEdit(b.toolkitDragObject);
                    b.toolkit.commitTransaction()
                };
                return this.jsp.on(this.jsp.getContainer(), "mousedown", Eb("jtk-draw-handle"),
                function(t) {
                    Ha(t);
                    var u = t.target.getAttribute("data-dir"),
                    v = t.target.getAttribute("data-node-id");
                    b.toolkitDragObject = b.toolkit.getNode(v) || b.toolkit.getGroup(v);
                    b.xAxis = b.skeletons[v][1];
                    b.yAxis = b.skeletons[v][2];
                    b.downAt = b.surface.mapEventLocation(t);
                    t = b.surface.getCoordinates(b.toolkitDragObject);
                    b.x1 = t.x;
                    b.y1 = t.y;
                    b.x2 = b.x1 + t.w;
                    b.y2 = b.y1 + t.h;
                    b.handler = b._dragHandlers[u];
                    b.jsp.addClass(document.body, "jtk-drag-select-defeat");
                    b.jsp.on(document, "mousemove", g);
                    b.jsp.on(document, "mouseup", m)
                }),
                !1
            }
        },
        {
            key: "reset",
            value: function() {
                for (var c in this.skeletons) {
                    var h = this.skeletons[c];
                    h[0] && h[0].parentNode && h[0].parentNode.removeChild(h[0]);
                    delete this.skeletons[c]
                }
            }
        },
        {
            key: "_minWidth",
            value: function() {
                return null == this.grid || this.ignoreGrid ? this.minimumWidth: this.grid.w
            }
        },
        {
            key: "_minHeight",
            value: function() {
                return null == this.grid || this.ignoreGrid ? this.minimumHeight: this.grid.h
            }
        },
        {
            key: "_create",
            value: function(c, h, b, g) {
                c = document.createElement(c);
                h = h.join(" ");
                if (c.className = h, b && b.appendChild(c), g) for (var m in g) c.setAttribute(m, g[m]);
                return c
            }
        },
        {
            key: "_remove",
            value: function(c) {
                var h = this.skeletons[c];
                h && h[0] && h[0].parentNode && h[0].parentNode.removeChild(h[0]);
                delete this.skeletons[c]
            }
        },
        {
            key: "_deselect",
            value: function(c) {
                var h = this.surface.getRenderedVertex(c.id);
                return this._remove(c.id),
                h
            }
        },
        {
            key: "_select",
            value: function(c) {
                var h = this._deselect(c);
                if (null != h) {
                    var b = this._create("div", ["jtk-draw-skeleton"], h),
                    g = h.getAttribute("jtk-x-resize");
                    h = h.getAttribute("jtk-y-resize");
                    this._create("div", ["jtk-draw-drag"], b);
                    this._create("div", ["jtk-draw-handle", "jtk-draw-handle-tl"], b, {
                        "data-dir": "tl",
                        "data-node-id": c.id
                    });
                    this._create("div", ["jtk-draw-handle", "jtk-draw-handle-tr"], b, {
                        "data-dir": "tr",
                        "data-node-id": c.id
                    });
                    this._create("div", ["jtk-draw-handle", "jtk-draw-handle-bl"], b, {
                        "data-dir": "bl",
                        "data-node-id": c.id
                    });
                    this._create("div", ["jtk-draw-handle", "jtk-draw-handle-br"], b, {
                        "data-dir": "br",
                        "data-node-id": c.id
                    });
                    this.skeletons[c.id] = [b, "false" !== g, "false" !== h]
                }
            }
        },
        {
            key: "_dim",
            value: function(c, h, b, g) {
                var m = {};
                return m[this.widthAtt] = this.xAxis ? b: this.x2 - this.x1,
                m[this.heightAtt] = this.yAxis ? g: this.y2 - this.y1,
                m[this.leftAtt] = this.xAxis ? c: this.x1,
                m[this.topAtt] = this.yAxis ? h: this.y1,
                0 > m[this.widthAtt] && (m[this.widthAtt] = this._minWidth()),
                0 > m[this.heightAtt] && (m[this.heightAtt] = this._minHeight()),
                m
            }
        },
        {
            key: "edit",
            value: function(c) {
                this._select(c)
            }
        }]),
        e
    } ();
    na(ge, "type", "drawingTools");
    de.register(ge.type, ge);
    var he = function(e) {
        function c() {
            var b;
            if (! (this instanceof c)) throw new TypeError("Cannot call a class as a function");
            for (var g = arguments.length,
            m = Array(g), r = 0; r < g; r++) m[r] = arguments[r];
            return ha(ia(b = h.call.apply(h, [this].concat(m))), "surface", void 0),
            ha(ia(b), "panzoom", void 0),
            ha(ia(b), "containerElement", void 0),
            ha(ia(b), "canvasElement", void 0),
            ha(ia(b), "pannerElement", void 0),
            ha(ia(b), "surfaceBounds", void 0),
            ha(ia(b), "suspended", void 0),
            ha(ia(b), "_collapsible", void 0),
            ha(ia(b), "typeFunction", void 0),
            ha(ia(b), "_collapser", void 0),
            ha(ia(b), "_collapsed", void 0),
            ha(ia(b), "wheelSensitivity", void 0),
            ha(ia(b), "wheelReverse", void 0),
            ha(ia(b), "panning", !1),
            ha(ia(b), "downAt", null),
            ha(ia(b), "pannerAtMouseDown", null),
            ha(ia(b), "zoomingWithWheel", !1),
            ha(ia(b), "elementFilter", void 0),
            ha(ia(b), "visible", !0),
            ha(ia(b), "pannerPos", void 0),
            ha(ia(b), "vertexMap", {}),
            ha(ia(b), "enableWheelZoom", void 0),
            ha(ia(b), "eventManager", void 0),
            ha(ia(b), "_zoomToFit", void 0),
            ha(ia(b), "surfaceBindings", []),
            ha(ia(b), "_doToggleCollapse", void 0),
            ha(ia(b), "viewport", void 0),
            ha(ia(b), "_doWheelZoom", void 0),
            ha(ia(b), "_downListener", void 0),
            ha(ia(b), "_moveListener", void 0),
            ha(ia(b), "_upListener", void 0),
            b
        }
        ik(c, $e);
        var h = kk(c);
        return hk(c, [{
            key: "destroy",
            value: function() {
                var b = this;
                this.panzoom.destroy();
                this.eventManager.off(this.pannerElement, "mousedown", this._downListener);
                this.canvasElement.parentNode.removeChild(this.canvasElement);
                this.pannerElement.parentNode.removeChild(this.pannerElement);
                this.surface.removeClass(this.containerElement, "jtk-miniview");
                this.surface.removeClass(this.containerElement, "jtk-miniview-collapsed");
                this._collapsible && (this.eventManager.off(this._collapser, "click", this._doToggleCollapse), this._collapser.parentNode.removeChild(this._collapser));
                this.surfaceBindings.forEach(function(g) {
                    return b.surface.unbind(g[0], g[1])
                });
                this.surface.toolkitInstance.unbind("dataLoadEnd", this._zoomToFit);
                this._doWheelZoom && Qg(this.containerElement, this._doWheelZoom)
            }
        },
        {
            key: "bindToSurface",
            value: function(b, g) {
                g = g.bind(this);
                this.surfaceBindings.push([b, g]);
                this.surface.bind(b, g)
            }
        },
        {
            key: "initialise",
            value: function(b, g) {
                var m = this;
                this.surface = b;
                this.wheelReverse = this.wheelReverse || !0 === this.surface.wheelReverse;
                this._downListener = this.downListener.bind(this);
                this._moveListener = this.moveListener.bind(this);
                this._upListener = this.upListener.bind(this);
                this.containerElement = g.container;
                this.canvasElement = this.surface._createElement({
                    position: "relative",
                    width: "50px",
                    height: "50px",
                    left: 0,
                    top: 0,
                    clazz: "jtk-miniview-canvas"
                },
                this.containerElement);
                this.pannerElement = this.surface._createElement({
                    position: "absolute",
                    width: "50px",
                    height: "50px",
                    left: 0,
                    top: 0,
                    clazz: "jtk-miniview-panner"
                },
                this.containerElement);
                this.surfaceBounds = g.bounds;
                this.suspended = !0 === g.suspended;
                this._collapsible = !1 !== g.collapsible;
                this.typeFunction = g.typeFunction;
                this._collapser = null;
                this._collapsed = !1;
                this.enableWheelZoom = !1 !== g.enableWheelZoom;
                this.wheelSensitivity = g.wheelSensitivity || 10;
                this.elementFilter = g.elementFilter ||
                function(r) {
                    return ! 0
                };
                this.visible = !1 !== g.visible;
                this.eventManager = new $b;
                sa(this.containerElement, "jtk-miniview");
                this._doToggleCollapse = this._toggleCollapsed.bind(this);
                this._collapsible && (this._collapser = this.surface._createElement({
                    type: "div"
                }), this._collapser.className = "jtk-miniview-collapse", this.containerElement.appendChild(this._collapser), this.surface.on(this._collapser, "click", this._doToggleCollapse));
                this.viewport = this.surface.viewport;
                this.panzoom = new Qi(this.surface, {
                    viewport: this.viewport,
                    viewportElement: this.containerElement,
                    canvasElement: this.canvasElement,
                    enableWheelZoom: !1,
                    enablePan: !1,
                    enableAnimation: !1,
                    idFunction: function(r) {
                        return r.getAttribute("id")
                    },
                    events: {
                        pan: function() {
                            m._updateSurface()
                        },
                        mousedown: function() {
                            sa(m.pannerElement, "jtk-miniview-panning")
                        },
                        mouseup: function() {
                            ta(m.pannerElement, "jtk-miniview-panning")
                        }
                    },
                    zoomRange: [ - 1 / 0, 1 / 0]
                });
                this.eventManager.on(window, "resize", Xj(function() {
                    m._updatePanner()
                },
                100)); ! 1 !== this.enableWheelZoom && (this._doWheelZoom = this.wheelZoom.bind(this), Og(this.containerElement, this._doWheelZoom));
                this.pannerElement.style.transformOrigin = "0 0";
                this.surface.addClass(this.containerElement, "jtk-miniview");
                this.eventManager.on(this.pannerElement, "mousedown", this._downListener);
                this._zoomToFit = function() {
                    return m.zoomToFit()
                };
                this.surface.toolkitInstance.bind("dataLoadEnd", this._zoomToFit);
                this.setVisible(this.visible);
                this.bindToSurface("pan", this._updatePanner);
                this.bindToSurface("zoom", this._updatePanner);
                this.bindToSurface("node:move:end", this._vertexMoved);
                this.bindToSurface("node:removed", this._nodeRemoved);
                this.bindToSurface("node:added", this._nodeAdded);
                this.bindToSurface("node:render", this._nodeAdded);
                this.bindToSurface("group:relayout", this._groupRelayout);
                this.bindToSurface("relayout", this._afterRelayout);
                this.bindToSurface("group:added", this._onGroupAdded);
                this.bindToSurface("group:move:end", this._vertexMoved);
                this.bindToSurface("group:removed", this._groupRemoved);
                this.bindToSurface("group:member:added", this._onGroupMemberAdded);
                this.bindToSurface("group:member:removed", this._onGroupMemberRemoved);
                this.bindToSurface("group:collapse", this._onGroupCollapse);
                this.bindToSurface("group:expand", this._onGroupExpand);
                this.bindToSurface("group:resize", this._onGroupResize);
                this.bindToSurface("rotate", this._objectRotated);
                b = function(r) {
                    m.surfaceBounds = r.bounds;
                    r.positions.forEach(function(t, u) { (u = m.vertexMap[u]) && ob(u, t.x, t.y)
                    });
                    m.zoomToFit(!0)
                };
                return this.bindToSurface("relayout", b),
                this.bindToSurface("afterLayoutRefresh", b),
                this.bindToSurface("objectRepainted", this._objectRepainted),
                this.bindToSurface("state:restore", this._updatePanner),
                this.bindToSurface("node:visibility", this._nodeVisibility),
                !0
            }
        },
        {
            key: "reset",
            value: function() {
                this._removeAllNodes()
            }
        },
        {
            key: "_onGroupAdded",
            value: function(b) {
                this._nodeAdded(b, "jtk-miniview-group-element")
            }
        },
        {
            key: "_onGroupCollapse",
            value: function(b) {
                this._showGroupMembers(b.group, !1);
                this._objectRepainted({
                    id: b.group.id
                })
            }
        },
        {
            key: "_onGroupExpand",
            value: function(b) {
                this._showGroupMembers(b.group, !0);
                this._objectRepainted({
                    id: b.group.id
                })
            }
        },
        {
            key: "_onGroupMemberRemoved",
            value: function(b) {
                var g = this.vertexMap[b.vertex.id];
                g && (this.canvasElement.appendChild(g), b.pos && ob(g, b.pos.x, b.pos.y))
            }
        },
        {
            key: "_onGroupResize",
            value: function(b) {
                this._objectRepainted({
                    id: b.group.id
                })
            }
        },
        {
            key: "_onGroupMemberAdded",
            value: function(b) {
                var g = this.vertexMap[b.group.id],
                m = this.vertexMap[b.vertex.id];
                g && m && (g.appendChild(m), b.pos && ob(m, b.pos.x, b.pos.y))
            }
        },
        {
            key: "_objectRotated",
            value: function(b) {
                var g = this.vertexMap[b.obj.id];
                null != g && (g.style.transform = "rotate(" + b.rotation + "deg)", g.style.transformOrigin = "50% 50%")
            }
        },
        {
            key: "downListener",
            value: function(b) {
                this.panning = !0;
                this.downAt = bb(b);
                this.pannerAtMouseDown = Re(this.pannerElement);
                this.eventManager.on(document, "mouseup", this._upListener);
                this.eventManager.on(document, "mousemove", this._moveListener);
                Ha(b)
            }
        },
        {
            key: "moveListener",
            value: function(b) {
                if (this.zoomingWithWheel = !1, this.panning) b = bb(b),
                b = {
                    x: this.pannerAtMouseDown.x + (b.x - this.downAt.x),
                    y: this.pannerAtMouseDown.y + (b.y - this.downAt.y)
                },
                this._updateSurface(b),
                ob(this.pannerElement, b.x, b.y)
            }
        },
        {
            key: "upListener",
            value: function(b) {
                this.panning = !1;
                this.downAt = null;
                this.eventManager.off(document, "mouseup", this._upListener);
                this.eventManager.off(document, "mousemove", this._moveListener)
            }
        },
        {
            key: "wheelZoom",
            value: function(b) {
                Ha(b);
                this.surface.nudgeWheelZoom(b.normalizedWheelDelta * this.wheelSensitivity * (this.wheelReverse ? -1 : 1), b)
            }
        },
        {
            key: "_toggleCollapsed",
            value: function(b) {
                this._collapsed = !this._collapsed;
                this.surface[this._collapsed ? "addClass": "removeClass"](this.containerElement, "jtk-miniview-collapsed");
                this.zoomToFit(!0)
            }
        },
        {
            key: "zoomToFit",
            value: function(b) {
                this.panzoom.zoomToFit({
                    onComplete: this._updatePanner,
                    doNotFirePanEvent: b
                })
            }
        },
        {
            key: "_vertexMoved",
            value: function(b) {
                var g = b.vertex;
                g && !1 === this.elementFilter(g) || (ob(this.vertexMap[g.id] || b.el, b.pos.x, b.pos.y), this.zoomToFit(!0))
            }
        },
        {
            key: "_groupRelayout",
            value: function(b) {
                var g, m = this,
                r = b.group.getMembers(),
                t = this.vertexMap[b.group.id];
                r.forEach(function(u, v) {
                    g = b.layout.getPosition(u.id);
                    u = m.vertexMap[u.id];
                    null != g && null != u && ob(u, g.x, g.y)
                });
                r = this.surface.jsplumb.getSize(b.el);
                t.style.width = r.w + "px";
                t.style.height = r.h + "px";
                this._updatePanner()
            }
        },
        {
            key: "_afterRelayout",
            value: function(b) {
                var g = this;
                this.surfaceBounds = b.bounds;
                b.positions.forEach(function(m, r) { (r = g.vertexMap[r]) && ob(r, m.x, m.y)
                });
                this.zoomToFit(!0)
            }
        },
        {
            key: "_migrateGroupMembers",
            value: function(b, g) {
                b = b.getMembers();
                for (var m = 0; m < b.length; m++) {
                    var r = this.vertexMap[b[m].id];
                    r && g.appendChild(r)
                }
            }
        },
        {
            key: "_nodeAdded",
            value: function(b, g) {
                if (!1 !== this.elementFilter(b.vertex)) {
                    var m = b.vertex,
                    r = m.id;
                    if (null == this.vertexMap[r]) {
                        var t = b.pos || {
                            x: 0,
                            y: 0
                        },
                        u = this.surface.jsplumb.getSize(b.el);
                        g = this.surface._createElement({
                            position: "absolute",
                            width: u.w + "px",
                            height: u.h + "px",
                            left: t.x,
                            top: t.y,
                            clazz: "jtk-miniview-element" + (g ? " " + g: "")
                        }); (this.typeFunction && g.setAttribute("jtk-miniview-type", this.typeFunction(b.vertex)), g.relatedElement = b.el, this.surfaceBounds = this.surface.getBoundsInfo(), g.setAttribute("jtk-node-id", r), this.canvasElement.appendChild(g), this.panzoom.add(g), this.vertexMap[r] = g, null != m.data.rotation && (g.style.transform = "rotate(" + m.data.rotation + "deg)", g.style.transformOrigin = "50% 50%"), b.vertex.type === cb.objectType) ? this._migrateGroupMembers(b.vertex, g) : b.vertex.group && (m = this.vertexMap[b.vertex.group.id]) && (m.appendChild(g), this.panzoom.suspend(b.el));
                        this._updatePanner()
                    }
                }
            }
        },
        {
            key: "registerNode",
            value: function(b) {
                this._nodeAdded(b, b.group ? "jtk-miniview-group-element": "");
                this._vertexMoved(b)
            }
        },
        {
            key: "setVisible",
            value: function(b) {
                this.visible = b;
                this.containerElement.style.display = b ? "block": "none"
            }
        },
        {
            key: "getPan",
            value: function() {
                return this.panzoom.getPan()
            }
        },
        {
            key: "_showGroupMembers",
            value: function(b, g) {
                b = b.getMembers();
                for (var m = 0; m < b.length; m++) this.vertexMap[b[m].id].style.display = g ? "block": "none"
            }
        },
        {
            key: "_objectRepainted",
            value: function(b) {
                var g = this.vertexMap[b.id];
                if (g) {
                    var m = this.surface.jsplumb.getSize(g.relatedElement); (g.style.width = m.w + "px", g.style.height = m.h + "px", this._updatePanner(), this.typeFunction) && (b = b.obj || this.surface.toolkitInstance.getVertex(b.id)) && g.setAttribute("jtk-miniview-type", this.typeFunction(b))
                }
            }
        },
        {
            key: "invalidate",
            value: function(b) {
                if (b) this._objectRepainted({
                    id: b
                });
                else for (var g in this.vertexMap) this._objectRepainted({
                    id: g
                })
            }
        },
        {
            key: "setSuspended",
            value: function(b, g) {
                this.suspended = b;
                g && this._updatePanner()
            }
        },
        {
            key: "_vertexRemoved",
            value: function(b) {
                b = b.vertex.id;
                var g = this.vertexMap[b];
                g && (this.panzoom.remove(g), delete this.vertexMap[b], g.parentNode.removeChild(g), this.zoomToFit(!0))
            }
        },
        {
            key: "_groupRemoved",
            value: function(b) {
                var g, m;
                if (this.vertexMap[b.vertex.id] && !0 !== b.childrenRemoved) for (var r = 0; r < b.children.length; r++) {
                    var t = b.children[r]; (g = this.vertexMap[t.id]) && ((m = b.childPositions[t.id]) && ob(g, m.x, m.y), this.canvasElement.appendChild(g))
                }
                this._vertexRemoved(b)
            }
        },
        {
            key: "_nodeRemoved",
            value: function(b) {
                this._vertexRemoved(b)
            }
        },
        {
            key: "_removeAllNodes",
            value: function() {
                var b;
                for (b in this.vertexMap) {
                    var g = this.vertexMap[b];
                    this.panzoom.remove(g);
                    delete this.vertexMap[b];
                    g.parentNode.removeChild(g)
                }
                this._updatePanner()
            }
        },
        {
            key: "_nodeVisibility",
            value: function(b) {
                var g = this.vertexMap[(b.node || b.group).id];
                g && (g.style.display = b.state ? "block": "none")
            }
        },
        {
            key: "_updatePanner",
            value: function() {
                if (this.surface && this.panzoom && !this.suspended) {
                    this.surfaceBounds = this.surface.getBoundsInfo();
                    var b = this.surface.getApparentCanvasLocation(),
                    g = this.panzoom.getApparentCanvasLocation(),
                    m = this.panzoom.getZoom() / this.surfaceBounds.zoom;
                    this.pannerElement.style.width = this.surfaceBounds.vw + "px";
                    this.pannerElement.style.height = this.surfaceBounds.vh + "px";
                    this.pannerElement.style.transform = "scale(" + m + ")";
                    this.pannerPos = {
                        x: g.x - b.x * m,
                        y: g.y - b.y * m
                    };
                    ob(this.pannerElement, this.pannerPos.x, this.pannerPos.y)
                }
            }
        },
        {
            key: "_updateSurface",
            value: function(b) {
                if (null != this.panzoom) {
                    this.surfaceBounds = this.surface.getBoundsInfo();
                    b = b || Re(this.pannerElement);
                    var g = this.panzoom.getApparentCanvasLocation(),
                    m = this.panzoom.getZoom() / this.surfaceBounds.zoom;
                    b = this.surface.setApparentCanvasLocation((g.x - b.x) / m, (g.y - b.y) / m);
                    return {
                        x: g.x - b.x * m,
                        y: g.y - b.y * m
                    }
                }
            }
        },
        {
            key: "getRenderedVertex",
            value: function(b) {
                return this.vertexMap[b]
            }
        },
        {
            key: "getPosition",
            value: function(b) {
                return this.surface.getPosition(b)
            }
        }]),
        c
    } ();
    ha(he, "type", "miniview");
    de.register(he.type, he);
    var ie = new Map;
    ie.set("perpendicular", uh);
    ie.set("orthogonal", uh);
    ie.set("opposite",
    function(e, c) {
        var h = "x" === e.sourceAxis ? 0 : 1;
        return ! c && {
            x: function() {
                return 1 === e.so[h] && (e.startStubX > e.endStubX && e.tx > e.startStubX || e.sx > e.endStubX && e.tx > e.sx) || -1 === e.so[h] && (e.startStubX < e.endStubX && e.tx < e.startStubX || e.sx < e.endStubX && e.tx < e.sx)
            },
            y: function() {
                return 1 === e.so[h] && (e.startStubY > e.endStubY && e.ty > e.startStubY || e.sy > e.endStubY && e.ty > e.sy) || -1 === e.so[h] && (e.startStubY < e.endStubY && e.ty < e.startStubY || e.sy < e.endStubY && e.ty < e.sy)
            }
        } [e.sourceAxis]() ? {
            x: [(e.sx + e.tx) / 2, e.startStubY, (e.sx + e.tx) / 2, e.endStubY],
            y: [e.startStubX, (e.sy + e.ty) / 2, e.endStubX, (e.sy + e.ty) / 2]
        } [e.sourceAxis] : [e.startStubX, e.startStubY, e.endStubX, e.endStubY]
    });
    var Vi = {
        x: [0, 1],
        y: [1, 0]
    },
    je = new Map;
    je.set("perpendicular",
    function(e, c, h, b, g, m, r, t, u, v, w) {
        m = {
            x: [[c.startStubX, c.endStubX], null, [c.endStubX, c.startStubX]],
            y: [[c.startStubY, c.endStubY], null, [c.endStubY, c.startStubY]]
        };
        e = {
            x: [[u, c.startStubY], [u, c.endStubY]],
            y: [[c.startStubX, v], [c.endStubX, v]]
        };
        h = {
            x: [[c.endStubX, c.startStubY]],
            y: [[c.startStubX, c.endStubY]]
        };
        g = {
            x: [[c.startStubX, c.endStubY], [c.endStubX, c.endStubY]],
            y: [[c.endStubX, c.startStubY], [c.endStubX, c.endStubY]]
        };
        u = {
            x: [[c.startStubX, v], [c.endStubX, v], [c.endStubX, c.endStubY]],
            y: [[u, c.startStubY], [u, c.endStubY], [c.endStubX, c.endStubY]]
        };
        t = {
            x: [c.startStubY, c.endStubY],
            y: [c.startStubX, c.endStubX]
        };
        v = Vi[b][1];
        r = c.so[Vi[b][0]] + 1;
        t = -1 === c.to[v] && t[b][1] < t[b][0] || 1 === c.to[v] && t[b][1] > t[b][0];
        w = m[b][r][0];
        m = m[b][r][1];
        v = {
            x: [[[1, 2, 3, 4], null, [2, 1, 4, 3]], null, [[4, 3, 2, 1], null, [3, 4, 1, 2]]],
            y: [[[3, 2, 1, 4], null, [2, 3, 4, 1]], null, [[4, 1, 2, 3], null, [1, 4, 3, 2]]]
        } [b][r][c.to[v] + 1];
        return c.segment === v[3] || c.segment === v[2] && t ? e[b] : c.segment === v[2] && m < w ? h[b] : c.segment === v[2] && m >= w || c.segment === v[1] && !t ? u[b] : c.segment === v[0] || c.segment === v[1] && t ? g[b] : void 0
    });
    je.set("orthogonal",
    function(e, c, h, b, g, m, r, t, u, v, w) {
        e = {
            x: -1 === c.so[0] ? Math.min(g, r) : Math.max(g, r),
            y: -1 === c.so[1] ? Math.min(g, r) : Math.max(g, r)
        } [b];
        return {
            x: [[e, m], [e, t], [r, t]],
            y: [[m, e], [t, e], [t, r]]
        } [b]
    });
    je.set("opposite",
    function(e, c, h, b, g, m, r, t, u, v, w) {
        t = {
            x: "y",
            y: "x"
        } [b];
        var z = {
            x: "height",
            y: "width"
        } [b],
        y = c["is" + b.toUpperCase() + "GreaterThanStubTimes2"];
        return h.sourceEndpoint.elementId === h.targetEndpoint.elementId ? (e = m + (1 - h.sourceEndpoint._anchor[t]) * h.sourceInfo[z] + e.maxStub, {
            x: [[g, e], [r, e]],
            y: [[e, g], [e, r]]
        } [b]) : !y || 1 === c.so[w] && g > r || -1 === c.so[w] && g < r ? {
            x: [[g, v], [r, v]],
            y: [[u, g], [u, r]]
        } [b] : 1 === c.so[w] && g < r || -1 === c.so[w] && g > r ? {
            x: [[u, c.sy], [u, c.ty]],
            y: [[c.sx, v], [c.tx, v]]
        } [b] : void 0
    });
    var ke = function(e) {
        function c(b, g) {
            var m;
            if (! (this instanceof c)) throw new TypeError("Cannot call a class as a function");
            return (m = h.call(this, b, g)).connection = b,
            ib(jb(m), "type", void 0),
            ib(jb(m), "midpoint", void 0),
            ib(jb(m), "alwaysRespectStubs", void 0),
            ib(jb(m), "lastx", void 0),
            ib(jb(m), "lasty", void 0),
            ib(jb(m), "lastOrientation", void 0),
            ib(jb(m), "cornerRadius", void 0),
            ib(jb(m), "loopbackRadius", void 0),
            ib(jb(m), "isLoopbackCurrently", void 0),
            ib(jb(m), "geometry", void 0),
            ib(jb(m), "slightlyWonky", !1),
            ib(jb(m), "orthogonalSegments", []),
            (g = g || {}).stub = null == g.stub ? 30 : g.stub,
            m.type = "Orthogonal",
            m.midpoint = null == g.midpoint ? .5 : g.midpoint,
            m.alwaysRespectStubs = !0 === g.alwaysRespectStubs,
            m.lastx = null,
            m.lasty = null,
            m.lastOrientation = null,
            m.cornerRadius = null != g.cornerRadius ? g.cornerRadius: 0,
            m.slightlyWonky = !0 === g.slightlyWonky,
            m.loopbackRadius = g.loopbackRadius || 25,
            m.isLoopbackCurrently = !1,
            m
        }
        mk(c, af);
        var h = ok(c);
        return lk(c, [{
            key: "getDefaultStubs",
            value: function() {
                return [30, 30]
            }
        },
        {
            key: "setAndTransformGeometry",
            value: function(b) {
                b.segments = id(b.segments);
                this.setGeometry(b, !1)
            }
        },
        {
            key: "setAndTransformSegments",
            value: function(b) {
                null != this.geometry && (this.geometry.segments = id(b))
            }
        },
        {
            key: "exportGeometry",
            value: function() {
                return null == this.geometry ? null: (this.geometry.segments[this.geometry.segments.length - 1], {
                    segments: this.geometry.segments.slice(1).map(function(b) {
                        return {
                            x: b.ax1,
                            y: b.ay1
                        }
                    }),
                    source: this.geometry.source,
                    target: this.geometry.target
                })
            }
        },
        {
            key: "_setAnchorLocation",
            value: function(b, g, m) {
                m = g.endpoints[m]._anchor;
                lb(m) ? (g = wa, 0 === b.x ? g = La: 1 === b.x ? g = Ma: 1 === b.y && (g = Ua), m.currentFace = g) : m.isDynamic && g.instance.router.selectAnchorLocation(m, {
                    x: b.x,
                    y: b.y
                });
                this.connection.instance.router.lock(m)
            }
        },
        {
            key: "importGeometry",
            value: function(b) {
                if (null != b && null != b.segments && null != b.source && null != b.target) {
                    var g = b.segments;
                    if (null != g && 3 <= g.length) {
                        for (var m = [], r = b.source.curX, t = b.source.curY, u = 0; u < g.length; u++) {
                            if (0 != g[u].x - r && 0 != g[u].y - t) return pa("Invalid path segment: ".concat(r, ", ").concat(t, ", ").concat(g[u].x, ", ").concat(g[u].y, ", not in X or Y axis")),
                            !1;
                            m.push({
                                x1: 0,
                                y1: 0,
                                x2: 0,
                                y2: 0,
                                o: null,
                                ax1: r,
                                ay1: t,
                                ax2: g[u].x,
                                ay2: g[u].y
                            });
                            r = g[u].x;
                            t = g[u].y
                        }
                        return m.push({
                            x1: 0,
                            y1: 0,
                            x2: 0,
                            y2: 0,
                            o: null,
                            ax1: r,
                            ay1: t,
                            ax2: b.target.curX,
                            ay2: b.target.curY
                        }),
                        this.setAndTransformGeometry({
                            segments: m,
                            source: b.source,
                            target: b.target
                        }),
                        this._setAnchorLocation(b.source, this.connection, 0),
                        this._setAnchorLocation(b.target, this.connection, 1),
                        !0
                    }
                }
                return ! 1
            }
        },
        {
            key: "writeSegments",
            value: function(b, g) {
                this.paintInfo = g;
                var m, r, t;
                g = null;
                for (var u = 0; u < b.length - 1; u++) {
                    if (g = g || A({},
                    b[u]), m = A({},
                    b[u + 1]), r = th(g), t = th(m), 0 < this.cornerRadius && g.o !== m.o) {
                        var v = Math.min(Pd(g), Pd(m));
                        v = Math.min(this.cornerRadius, v / 2);
                        g.x2 -= r[0] * v;
                        g.y2 -= r[1] * v;
                        m.x1 += t[0] * v;
                        m.y1 += t[1] * v;
                        r = r[1] === t[0] && 1 === t[0] || r[1] === t[0] && 0 === t[0] && r[0] !== t[1] || r[1] === t[0] && -1 === t[0];
                        var w = (m.y1 > g.y2 ? 1 : -1) === (m.x1 > g.x2 ? 1 : -1);
                        t = w && r || !w && !r ? m.x1: g.x2;
                        w = w && r || !w && !r ? g.y2: m.y1;
                        this._addSegment(kc, A({},
                        g));
                        this.slightlyWonky ? this._addSegment(df, A({
                            r: v,
                            cx: t,
                            cy: w,
                            ac: r
                        },
                        g)) : this._addSegment(df, {
                            r: v,
                            x1: g.x2,
                            y1: g.y2,
                            x2: m.x1,
                            y2: m.y1,
                            cx: t,
                            cy: w,
                            ac: r
                        })
                    } else this._addSegment(kc, A({},
                    g));
                    g = m
                }
                null != m && this._addSegment(kc, A({},
                g))
            }
        },
        {
            key: "_compute",
            value: function(b, g) {
                this.lastOrientation = this.lasty = this.lastx = null;
                var m = g.sourcePos,
                r = g.targetPos,
                t = this.geometry;
                if (this.edited && null != t && null != t.segments && 0 < t.segments.length) {
                    this.orthogonalSegments = t.segments;
                    m = !vh(m, t.source);
                    if (!vh(r, t.target)) {
                        r = this.orthogonalSegments[this.orthogonalSegments.length - 1];
                        var u = yc(this.orthogonalSegments, -1, "v"),
                        v = yc(this.orthogonalSegments, -1, "h"); (r.ax1 = g.targetPos.curX + b.stubs[1] * b.to[0], r.ay1 = g.targetPos.curY + b.stubs[1] * b.to[1], r.ax2 = g.targetPos.curX, r.ay2 = g.targetPos.curY, r.o = 0 === g.targetPos.oy ? "h": "v", null != u && null != v) ? u[1] > v[1] ? (u[0].ax1 = r.ax1, u[0].ax2 = r.ax1, u[0].ay2 = r.ay1, v[0].ax2 = r.ax1) : (v[0].ay1 = r.ay1, v[0].ay2 = r.ay1, v[0].ax2 = r.ax1, u[0].ay2 = r.ay1) : null != v ? 0 !== t.target.curY - g.targetPos[1] && (v[0].o = "v", v[0].ax2 = v[0].ax1, v[0].ay2 = g.targetPos[1], this.orthogonalSegments.splice(v[1] + 1, 0, {
                            x1: 0,
                            y1: 0,
                            x2: 0,
                            y2: 0,
                            o: "h",
                            ax1: v[0].ax2,
                            ay1: v[0].ay2,
                            ax2: r.ax1,
                            ay2: r.ay1
                        })) : null != u && 0 !== t.target.curX - g.targetPos[0] && (u[0].o = "h", u[0].ay2 = v[0].ay1, u[0].ax2 = g.targetPos[0], this.orthogonalSegments.splice(u[1] + 1, 0, {
                            x1: 0,
                            y1: 0,
                            x2: 0,
                            y2: 0,
                            o: "v",
                            ax1: u[0].ax2,
                            ay1: u[0].ay2,
                            ax2: r.ax1,
                            ay2: r.ay1
                        }));
                        this.orthogonalSegments = id(this.orthogonalSegments)
                    }
                    m && (m = this.orthogonalSegments[0], r = yc(this.orthogonalSegments, 1, "v"), u = yc(this.orthogonalSegments, 1, "h"), (m.ax1 = g.sourcePos.curX, m.ay1 = g.sourcePos.curY, m.ax2 = g.sourcePos.curX + b.stubs[0] * b.so[0], m.ay2 = g.sourcePos.curY + b.stubs[0] * b.so[1], m.o = 0 === g.sourcePos.oy ? "h": "v", null != r && null != u) ? r[1] > u[1] ? (u[0].ay1 = m.ay2, u[0].ay2 = m.ay2, u[0].ax1 = m.ax2, r[0].ay1 = m.ay2) : (r[0].ax1 = m.ax2, r[0].ax2 = m.ax2, r[0].ay1 = m.ay2, u[0].ax1 = m.ax2) : null != u ? 0 !== t.target.curY - g.targetPos[1] && this.orthogonalSegments.splice(u[1] - 1, 0, {
                        x1: 0,
                        y1: 0,
                        x2: 0,
                        y2: 0,
                        o: "v",
                        ax1: u[0].ax1,
                        ay1: g.targetPos[1],
                        ax2: u[0].ax1,
                        ay2: u[0].ay1
                    }) : null != r && 0 !== t.target.curX - g.targetPos[0] && this.orthogonalSegments.splice(r[1] - 1, 0, {
                        x1: 0,
                        y1: 0,
                        x2: 0,
                        y2: 0,
                        o: "h",
                        ax1: g.targetPos[0],
                        ay1: r[0].ay1,
                        ax2: r[0].ax1,
                        ay2: r[0].ay1
                    }), this.orthogonalSegments = id(this.orthogonalSegments));
                    this.setGeometry({
                        segments: this.orthogonalSegments,
                        source: g.sourcePos,
                        target: g.targetPos,
                        quadrant: b.segment
                    },
                    !1)
                } else {
                    this.orthogonalSegments.length = 0;
                    t = r.curX >= m.curX ? m.curX: r.curX;
                    m = r.curY >= m.curY ? m.curY: r.curY;
                    r = ie.get(b.anchorOrientation)(b, this.alwaysRespectStubs);
                    u = "x" === b.sourceAxis ? 0 : 1;
                    var w = "x" === b.sourceAxis ? 1 : 0;
                    v = r[u];
                    var z = r[w],
                    y = r[u + 2];
                    w = r[w + 2];
                    Qd(this, r[0], r[1], b, t, m);
                    var E = b.startStubX + (b.endStubX - b.startStubX) * this.midpoint,
                    F = b.startStubY + (b.endStubY - b.startStubY) * this.midpoint;
                    if (u = je.get(b.anchorOrientation)(this, b, g, b.sourceAxis, v, z, y, w, E, F, u)) for (v = 0; v < u.length; v++) Qd(this, u[v][0], u[v][1], b, t, m);
                    Qd(this, r[2], r[3], b, t, m);
                    Qd(this, b.tx, b.ty, b, t, m);
                    this.setGeometry({
                        segments: this.orthogonalSegments,
                        source: g.sourcePos,
                        target: g.targetPos,
                        quadrant: b.segment
                    },
                    !0)
                }
                this.writeSegments(this.orthogonalSegments, b)
            }
        },
        {
            key: "_locateSegment",
            value: function(b, g) {
                var m = this.orthogonalSegments.findIndex(function(u) {
                    return u.ax1 === b.ax1 && u.ay1 === b.ay1 && u.ax2 === b.ax2 && u.ay2 === b.ay2
                });
                if ( - 1 < m) {
                    var r = this.orthogonalSegments[m].o,
                    t = this.orthogonalSegments[m];
                    return {
                        segment: t,
                        index: m,
                        orientation: r,
                        prev: 1 < m ? this.orthogonalSegments[m - 1] : null,
                        next: m < this.orthogonalSegments.length - 2 ? this.orthogonalSegments[m + 1] : null,
                        left: g ? yc(this.orthogonalSegments, -1, r, t) : null,
                        right: g ? yc(this.orthogonalSegments, 1, r, t) : null
                    }
                }
                return null
            }
        },
        {
            key: "setSegmentPosition",
            value: function(b, g) {
                b = this._locateSegment(b);
                if (null != b) {
                    "v" === b.orientation ? b.segment.ax1 = b.segment.ax2 = g[0] : b.segment.ay1 = b.segment.ay2 = g[1];
                    var m = "v" === b.orientation,
                    r = b.index;
                    g = b.index;
                    for (var t = 1 < r ? this.orthogonalSegments[r - 1] : null, u = b.segment; null != t;) t.o === u.o ? m ? (t.ax1 = u.ax1, t.ax2 = u.ax2) : (t.ay1 = u.ay1, t.ay2 = u.ay2) : (t.ax2 = u.ax1, t.ay2 = u.ay1),
                    u = t,
                    t = 1 < --r ? this.orthogonalSegments[r - 1] : null;
                    u.ax1 !== this.orthogonalSegments[0].ax2 ? (this.orthogonalSegments.splice(1, 0, {
                        x1: null,
                        y1: null,
                        x2: null,
                        y2: null,
                        o: "h",
                        ax1: this.orthogonalSegments[0].ax2,
                        ay1: this.orthogonalSegments[0].ay2,
                        ax2: u.ax1,
                        ay2: u.ay1
                    }), g++) : u.ay1 !== this.orthogonalSegments[0].ay2 && (this.orthogonalSegments.splice(1, 0, {
                        x1: null,
                        y1: null,
                        x2: null,
                        y2: null,
                        o: "v",
                        ax1: this.orthogonalSegments[0].ax2,
                        ay1: this.orthogonalSegments[0].ay2,
                        ax2: u.ax1,
                        ay2: u.ay1
                    }), g++);
                    u = b.segment;
                    for (t = (r = b.index) < this.orthogonalSegments.length - 2 ? this.orthogonalSegments[r + 1] : null; null != t;) t.o === u.o ? m ? (t.ax1 = u.ax1, t.ax2 = u.ax2) : (t.ay1 = u.ay1, t.ay2 = u.ay2) : (t.ax1 = u.ax2, t.ay1 = u.ay2),
                    u = t,
                    t = ++r < this.orthogonalSegments.length - 2 ? this.orthogonalSegments[r + 1] : null;
                    m = this.orthogonalSegments[this.orthogonalSegments.length - 1];
                    u.ax2 !== m.ax1 ? this.orthogonalSegments.splice(this.orthogonalSegments.length - 1, 0, {
                        x1: null,
                        y1: null,
                        x2: null,
                        y2: null,
                        o: "h",
                        ax1: u.ax2,
                        ay1: u.ay2,
                        ax2: m.ax1,
                        ay2: m.ay1
                    }) : u.ay2 !== m.ay1 && this.orthogonalSegments.splice(this.orthogonalSegments.length - 1, 0, {
                        x1: null,
                        y1: null,
                        x2: null,
                        y2: null,
                        o: "v",
                        ax1: u.ax2,
                        ay1: u.ay2,
                        ax2: m.ax1,
                        ay2: m.ay1
                    });
                    return this.orthogonalSegments = id(this.orthogonalSegments),
                    this.edited = !0,
                    {
                        ctx: b,
                        segments: this.orthogonalSegments,
                        index: g
                    }
                }
                return null
            }
        },
        {
            key: "trim",
            value: function() {
                for (var b = [O(this.orthogonalSegments[0])], g = O(this.orthogonalSegments[this.orthogonalSegments.length - 1]), m = this.orthogonalSegments.slice(1, this.orthogonalSegments.length - 1).filter(function(v) {
                    return 0 < Pd(v)
                }).map(O), r = null, t = null, u = 0; u < m.length; u++) null == r || null == t ? (r = m[u], t = m[u].o) : m[u].o === t ? (r.y2 = m[u].y2, r.x2 = m[u].x2, r.ay2 = m[u].ay2, r.ax2 = m[u].ax2) : (b.push(r), r = m[u], t = m[u].o);
                if (b.push(r), b.push(g), 3 === b.length) t = b[1],
                g = t.o,
                m = O(t),
                r = O(t),
                t = O(t),
                r.o = "h" === g ? "v": "h",
                r.x1 = m.x1,
                r.y1 = m.y1,
                r.x2 = m.x1,
                r.y2 = m.y1,
                r.ax1 = m.ax1,
                r.ay1 = m.ay1,
                r.ax2 = m.ax1,
                r.ay2 = m.ay1,
                t.o = "h" === g ? "v": "h",
                t.x1 = m.x2,
                t.y1 = m.y2,
                t.x2 = m.x2,
                t.y2 = m.y2,
                t.ax1 = m.ax2,
                t.ay1 = m.ay2,
                t.ax2 = m.ax2,
                t.ay2 = m.ay2,
                b = [b[0], r, m, t, b[2]];
                this.setAndTransformSegments(b)
            }
        },
        {
            key: "setAnchorOrientation",
            value: function(b, g) {
                2 <= this.orthogonalSegments.length && ((0 === b ? this.orthogonalSegments[0] : this.orthogonalSegments[this.orthogonalSegments.length - 1]).o = 0 === g[0] ? "v": "h", this.edited = !0)
            }
        }]),
        c
    } ();
    ib(ke, "type", "Orthogonal");
    bf.register(ke.type, ke);
    var sd = function(e) {
        function c(b) {
            var g;
            if (! (this instanceof c)) throw new TypeError("Cannot call a class as a function");
            return jd(kd(g = h.call(this, b)), "current", void 0),
            jd(kd(g), "segments", void 0),
            jd(kd(g), "segmentHandles", void 0),
            jd(kd(g), "geometry", void 0),
            g.segments = [],
            g.segmentHandles = [],
            g._addDragHandler({
                selector: ".jtk-orthogonal-segment-drag",
                drag: function(m) {
                    var r = m.drag.getDragElement()._jsPlumbDragHandle,
                    t = g.jsplumb.getSize(r.el);
                    m = g.currentConnector.setSegmentPosition(r.geometry, [Math.floor(m.pos.x + t.w / 2), Math.floor(m.pos.y + t.h / 2)]);
                    null != m && (g.segments.length = 0, g.geometry.segments = m.segments, Array.prototype.push.apply(g.segments, g.geometry.segments), r.geometry = g.geometry.segments[m.index], g.repaintConnection({
                        segmentInfo: r,
                        segmentIndex: m.index
                    }))
                },
                constrainFunction: function(m, r, t, u) {
                    r = r._jsPlumbDragHandle;
                    return r.geometry.ax1 === r.geometry.ax2 ? {
                        x: m.x,
                        y: (r.geometry.ay1 + r.geometry.ay2) / 2 - u.h / 2
                    }: {
                        x: (r.geometry.ax1 + r.geometry.ax2) / 2 - u.w / 2,
                        y: m.y
                    }
                },
                stop: function(m) {
                    g._trimConnection();
                    g.fireConnectionEditEvent()
                }
            }),
            g
        }
        qk(c, am);
        var h = sk(c);
        return pk(c, [{
            key: "_setHandlePosition",
            value: function(b, g) {
                b.el.style.visibility = "visible";
                this._setElementPosition(b.el, g[0], g[1])
            }
        },
        {
            key: "_repaint",
            value: function(b) {
                this._update(b);
                for (b = 0; b < this.segmentHandles.length; b++)(this.segmentHandles[b].geometry = this.geometry.segments[b + 1], 0 < Pd(this.segmentHandles[b].geometry)) ? this._setHandlePosition(this.segmentHandles[b], [(this.segmentHandles[b].geometry.ax1 + this.segmentHandles[b].geometry.ax2) / 2, (this.segmentHandles[b].geometry.ay1 + this.segmentHandles[b].geometry.ay2) / 2]) : this.segmentHandles[b].el.style.visibility = "hidden"
            }
        },
        {
            key: "_clearHandles",
            value: function(b) {
                for (var g = 0; g < this.segmentHandles.length; g++) this.segmentHandles[g].el !== b && this.jsplumb._removeElement(this.segmentHandles[g].el)
            }
        },
        {
            key: "_activate",
            value: function(b, g, m) {
                this._update()
            }
        },
        {
            key: "_elementDragged",
            value: function(b) {
                this._trimConnection()
            }
        },
        {
            key: "_elementDragging",
            value: function(b) {
                this._repaint()
            }
        },
        {
            key: "_update",
            value: function(b) {
                var g = (b = b || {}).segmentInfo;
                b = b.segmentIndex;
                if (this.geometry = this.current.connector.geometry, this.geometry && this.geometry.segments) {
                    this._clearHandles(g ? g.el: null);
                    this.segmentHandles.length = 0;
                    this.segments.length = 0;
                    Array.prototype.push.apply(this.segments, this.geometry.segments);
                    for (var m = 1; m < this.segments.length - 1; m++) if (null == g || m !== b) {
                        var r = [(this.segments[m].ax1 + this.segments[m].ax2) / 2, (this.segments[m].ay1 + this.segments[m].ay2) / 2],
                        t = r[0],
                        u = r[1],
                        v = "v" === this.segments[m].o;
                        var w = t;
                        var z = u,
                        y = this.jsplumb,
                        E = ["jtk-orthogonal-handle jtk-orthogonal-segment-drag", v ? "jtk-orthogonal-segment-drag-ew": "jtk-orthogonal-segment-drag-ns"].join(" ");
                        var F = w;
                        var M = z,
                        S = document.createElement("div");
                        F = (S.className = E, S.style.position = "absolute", S.style.left = F + "px", S.style.top = M + "px", S);
                        y._appendElement(F, y.getContainer());
                        y = y.getSize(F);
                        w = (F.style.left = w - y.w / 2 + "px", F.style.top = z - y.h / 2 + "px", F);
                        t = {
                            left: t,
                            top: u,
                            el: w,
                            geometry: this.segments[m],
                            vertical: v
                        };
                        w._jsPlumbDragHandle = t;
                        this.segmentHandles.push(t);
                        this._setHandlePosition(t, r)
                    } else m === b && this.segmentHandles.push(g)
                }
            }
        },
        {
            key: "_trimConnection",
            value: function() {
                this.current && (this.currentConnector.trim(), this.repaintConnection())
            }
        }]),
        c
    } ();
    jd(sd, "type", "Orthogonal");
    ee.set(sd.type, sd);
    var uf = "ontouchstart" in document.documentElement,
    gm = uf ? "touchstart": "mousedown",
    Wi = uf ? "touchend": "mouseup",
    Xi = uf ? "touchmove": "mousemove",
    hm = !!window.MSInputMethodContext && !!document.documentMode,
    im = function() {
        function e(c) {
            yh(this, e);
            Ea(this, "el", void 0);
            Ea(this, "masks", {});
            Ea(this, "origin", {
                x: 0,
                y: 0
            });
            Ea(this, "onStart", void 0);
            Ea(this, "onEnd", void 0);
            Ea(this, "onSelect", void 0);
            Ea(this, "down", !1);
            Ea(this, "moving", !1);
            Ea(this, "invert", void 0);
            Ea(this, "surface", void 0);
            Ea(this, "_filter", void 0);
            Ea(this, "eventManager", void 0);
            Ea(this, "downListener", void 0);
            Ea(this, "upListener", void 0);
            Ea(this, "moveListener", void 0);
            Ea(this, "enabled", !1);
            this.surface = c.surface;
            this.onStart = c.onStart || Ze;
            this.onEnd = c.onEnd || Ze;
            this.onSelect = c.onSelect || Ze;
            this.invert = !0 === c.invert;
            this.downListener = this._downListener.bind(this);
            this.upListener = this._upListener.bind(this);
            this.moveListener = this._moveListener.bind(this);
            this.eventManager = new $b;
            this._filter = c.filter ?
            function(h) {
                return Bb(h.srcElement || h.target, c.filter)
            }: function() {
                return ! 1
            };
            this.invert ? this._createMasks() : this.el = ld(["jtk-lasso"]);
            this.eventManager.on(this.surface.jsplumb.getContainer().parentNode, gm, this.downListener)
        }
        return Ah(e, [{
            key: "_position",
            value: function(c, h) {
                if (this.invert) {
                    var b = hm ? (window.innerWidth + document.body.clientWidth) / 2 : window.innerWidth,
                    g = window.innerHeight,
                    m = g - c.y + window.pageYOffset;
                    g = g - m + h.h;
                    c = b - c.x + window.pageXOffset;
                    h = b - c + h.w;
                    this.masks.top.style.bottom = m + "px";
                    this.masks.bottom.style.top = g + "px";
                    this.masks.left.style.right = c + "px";
                    this.masks.right.style.left = h + "px";
                    this.masks.top.style.left = b - c + "px";
                    this.masks.top.style.right = b - h + "px";
                    this.masks.bottom.style.left = b - c + "px";
                    this.masks.bottom.style.right = b - h + "px"
                } else b = this.el,
                ob(b, c.x, c.y),
                m = h.h,
                b.style.width = h.w + "px",
                b.style.height = m + "px"
            }
        },
        {
            key: "_setVisible",
            value: function(c) {
                var h = c ? "block": "none";
                this.invert ? (this.masks.top.style.display = h, this.masks.left.style.display = h, this.masks.right.style.display = h, this.masks.bottom.style.display = h) : this.el.style.display = h;
                c ? this.surface.addClass(document.body, "jtk-drag-select-defeat") : this.surface.removeClass(document.body, "jtk-drag-select-defeat")
            }
        },
        {
            key: "_downListener",
            value: function(c) {
                this.enabled && !this._filter(c) && (Ha(c), this.down = !0, this.eventManager.on(document, Wi, this.upListener), this.eventManager.on(document, Xi, this.moveListener), this.origin = bb(c), this._position(this.origin, {
                    w: 1,
                    h: 1
                }), this.onStart(this.origin, c.shiftKey))
            }
        },
        {
            key: "_moveListener",
            value: function(c) {
                if (this.down) {
                    this.moving || (this._setVisible(!0), this.moving = !0);
                    Ha(c);
                    var h = bb(c),
                    b = {
                        w: Math.abs(h.x - this.origin.x),
                        h: Math.abs(h.y - this.origin.y)
                    },
                    g = {
                        x: Math.min(this.origin.x, h.x),
                        y: Math.min(this.origin.y, h.y)
                    };
                    this._position(g, b);
                    this.onSelect(g, b, [this.origin.x < h.x, this.origin.y < h.y], c.shiftKey)
                }
            }
        },
        {
            key: "_upListener",
            value: function(c) {
                this.down && (this.down = !1, this.moving = !1, Ha(c), this.eventManager.off(document, Wi, this.upListener), this.eventManager.off(document, Xi, this.moveListener), this._setVisible(!1), this.onEnd())
            }
        },
        {
            key: "_createMasks",
            value: function() {
                this.masks.top = ld(["jtk-lasso-mask", "jtk-lasso-mask-top"]);
                this.masks.bottom = ld(["jtk-lasso-mask", "jtk-lasso-mask-bottom"]);
                this.masks.left = ld(["jtk-lasso-mask", "jtk-lasso-mask-left"]);
                this.masks.right = ld(["jtk-lasso-mask", "jtk-lasso-mask-right"])
            }
        },
        {
            key: "isActive",
            value: function() {
                return this.down
            }
        },
        {
            key: "setEnabled",
            value: function(c) {
                this.enabled = c
            }
        }]),
        e
    } (),
    le = function() {
        function e() {
            yh(this, e);
            Ea(this, "surface", void 0);
            Ea(this, "lasso", void 0);
            Ea(this, "selectionFilter", void 0);
            Ea(this, "lassoSelections", [])
        }
        return Ah(e, [{
            key: "destroy",
            value: function() {}
        },
        {
            key: "initialise",
            value: function(c, h) {
                var b = this;
                return c.bind("modeChanged",
                function(g) {
                    b.lasso.enabled = "select" === g
                }),
                this.selectionFilter = h.selectionFilter,
                this.lasso = new im({
                    surface: c,
                    invert: h.invert,
                    canvas: c.containerElement,
                    onStart: function() {
                        c.setHoverSuspended(!0);
                        b.lassoSelections.length = 0
                    },
                    onSelect: function(g, m, r, t) {
                        c.jsplumb.clearDragSelection && c.jsplumb.clearDragSelection();
                        c.toolkitInstance.clearSelection();
                        t && 0 < b.lassoSelections.length && c.toolkitInstance.removeFromSelection(b.lassoSelections);
                        t = [];
                        var u = c.findIntersectingVertices(g, m, !r[0]);
                        m = u.length;
                        r = {};
                        for (g = 0; g < m; g++) null != b.selectionFilter && !1 === b.selectionFilter(u[g].v) || (t.push(u[g].v), r[u[g].id] = !0, c.jsplumb.addToDragSelection(u[g].el));
                        if (b.lassoSelections = t, m = t.length, h.includeEdges) for (u = {},
                        g = 0; g < m; g++) {
                            var v = [],
                            w;
                            Array.prototype.push.apply(v, t[g].getAllEdges());
                            for (var z = 0; z < v.length; z++) if (!u[w = v[z].getId()]) {
                                var y = v[z].source.objectType === oa.objectType ? v[z].source.getParent().id: v[z].source.id,
                                E = v[z].target.objectType === oa.objectType ? v[z].target.getParent().id: v[z].target.id;
                                r[y] && r[E] && t.push(v[z]);
                                u[w] = !0
                            }
                        }
                        c.toolkitInstance.addToSelection(t)
                    },
                    onEnd: function() {
                        c.setHoverSuspended(!1);
                        c.autoExitSelectMode && c.mode !== Mb.DISABLED && c.setMode(Mb.PAN);
                        c.fire("lasso:end")
                    },
                    filter: h.filter
                }),
                !1
            }
        },
        {
            key: "reset",
            value: function() {}
        },
        {
            key: "activated",
            value: function() {
                this.lasso.enabled = !0
            }
        },
        {
            key: "deactivated",
            value: function() {
                this.lasso.enabled = !1
            }
        }]),
        e
    } ();
    Ea(le, "type", "lasso");
    de.register(le.type, le);
    ee.set(sd.type, sd); (function(e) {
        Ui ? e() : sf.push(e)
    })(function() {
        function e(F, M, S) {
            g.show({
                id: "dlgText",
                data: {
                    text: F.label || ""
                },
                onOK: function(X) {
                    M({
                        label: X.text || ""
                    })
                },
                onCancel: S
            })
        }
        var c, h, b, g = new Il({
            dialogs: {
                dlgText: {
                    template: '<input type="text" size="50" jtk-focus jtk-att="text" value="${text}" jtk-commit="true"/>',
                    title: "Enter Text",
                    cancelable: !0
                },
                dlgConfirm: {
                    template: "${msg}",
                    title: "Please Confirm",
                    cancelable: !0
                },
                dlgMessage: {
                    template: "${msg}",
                    title: "Message",
                    cancelable: !1
                }
            }
        }),
        m = document.querySelector("#jtk-demo-flowchart"),
        r = m.querySelector(".jtk-demo-canvas"),
        t = m.querySelector(".miniview"),
        u = m.querySelector(".node-palette"),
        v = m.querySelector(".controls"),
        w = ck({
            nodeFactory: function(F, M, S, X) {
                g.show({
                    id: "dlgText",
                    title: "Enter " + F + " name:",
                    onOK: function(da) {
                        M.text = da.text;
                        M.text && 2 <= M.text.length ? (M.id = fa(), S(M)) : (alert(F + " names must be at least 2 characters!"), X())
                    },
                    onCancel: function() {
                        return X()
                    }
                });
                return ! 0
            },
            edgeFactory: function(F, M, S, X) {
                e(M, S, X);
                return ! 0
            },
            beforeStartConnect: function(F, M) {
                return "start" === F.data.type && 0 < F.getEdges().length ? !1 : {
                    label: "..."
                }
            }
        });
        window.toolkit = w;
        var z = function(F, M) {
            g.show({
                id: "dlgText",
                data: {
                    text: F.data.label || ""
                },
                onOK: function(S) {
                    w.updateEdge(F, {
                        label: S.text || ""
                    })
                },
                onCancel: function() {
                    M && w.removeEdge(F)
                }
            })
        },
        y = w.render(r, {
            view: {
                nodes: (c = {},
                H(c, "start", {
                    templateId: "tmplStart"
                }), H(c, "selectable", {
                    events: {
                        tap: function(F) {
                            w.toggleSelection(F.obj)
                        }
                    }
                }), H(c, "question", {
                    parent: "selectable",
                    templateId: "tmplQuestion"
                }), H(c, "action", {
                    parent: "selectable",
                    templateId: "tmplAction"
                }), H(c, "output", {
                    parent: "selectable",
                    templateId: "tmplOutput"
                }), c),
                edges: (h = {},
                H(h, "default", {
                    anchor: ec.AutoDefault,
                    endpoint: nd.type,
                    connector: {
                        type: ke.type,
                        options: {
                            cornerRadius: 3
                        }
                    },
                    paintStyle: {
                        strokeWidth: 2,
                        stroke: "rgb(132, 172, 179)",
                        outlineWidth: 3,
                        outlineStroke: "transparent"
                    },
                    hoverPaintStyle: {
                        strokeWidth: 2,
                        stroke: "rgb(67,67,67)"
                    },
                    events: {
                        click: function(F) {
                            E.startEditing(F.edge, {
                                deleteButton: !0,
                                onMaybeDelete: function(M, S, X) {
                                    g.show({
                                        id: "dlgConfirm",
                                        data: {
                                            msg: "Delete Edge"
                                        },
                                        onOK: X
                                    })
                                }
                            })
                        }
                    },
                    overlays: [{
                        type: Kb.type,
                        options: {
                            location: 1,
                            width: 10,
                            length: 10
                        }
                    }]
                }), H(h, "response", {
                    parent: "default",
                    overlays: [{
                        type: Fb.type,
                        options: {
                            label: "${label}",
                            events: {
                                click: function(F) {
                                    z(F.edge)
                                }
                            }
                        }
                    }]
                }), h),
                ports: (b = {},
                H(b, "start", {
                    edgeType: "default"
                }), H(b, "source", {
                    maxConnections: -1,
                    edgeType: "response"
                }), H(b, "target", {
                    maxConnections: -1,
                    isTarget: !0
                }), b)
            },
            layout: {
                type: Hc.type
            },
            grid: {
                size: {
                    w: 20,
                    h: 20
                }
            },
            events: H({},
            "canvasClick",
            function(F) {
                w.clearSelection();
                E.stopEditing()
            }),
            consumeRightClick: !1,
            dragOptions: {
                filter: ".jtk-draw-handle, .node-action, .node-action i"
            },
            plugins: [{
                type: he.type,
                options: {
                    container: t
                }
            },
            ge.type, {
                type: le.type,
                options: {
                    lassoInvert: !0,
                    lassoEdges: !0
                }
            }],
            magnetize: {
                afterDrag: !0
            }
        }),
        E = new bm(y);
        w.bind("undoredo:update",
        function(F) {
            v.setAttribute("can-undo", 0 < F.undoCount ? "true": "false");
            v.setAttribute("can-redo", 0 < F.redoCount ? "true": "false")
        });
        y.on(v, "tap", "[undo]",
        function() {
            w.undo()
        });
        y.on(v, "tap", "[redo]",
        function() {
            w.redo()
        });
        w.load({
            url: "./copyright.json",
            onload: function() {
                y.zoomToFit()
            }
        });
        y.bind("modeChanged",
        function(F) {
            P(v.querySelectorAll("[mode]"),
            function(M) {
                y.removeClass(M, "selected-mode")
            });
            y.addClass(v.querySelector("[mode='" + F + "']"), "selected-mode")
        });
        y.on(v, "tap", "[mode]",
        function(F, M) {
            y.setMode(M.getAttribute("mode"))
        });
        y.on(v, "tap", "[reset]",
        function(F, M) {
            w.clearSelection();
            y.zoomToFit()
        });
        y.on(v, "tap", "[clear]",
        function(F, M) { (0 === w.getNodeCount() || confirm("Clear flowchart?")) && w.clear()
        });
        y.bindModelEvent("tap", ".node-delete",
        function(F, M, S) {
            g.show({
                id: "dlgConfirm",
                data: {
                    msg: "Delete '" + S.obj.data.text + "'"
                },
                onOK: function() {
                    w.removeNode(S.obj)
                }
            })
        });
        y.bindModelEvent("tap", ".node-edit",
        function(F, M, S) {
            g.show({
                id: "dlgText",
                data: S.obj.data,
                title: "Edit " + S.obj.data.type + " name",
                onOK: function(X) {
                    X.text && 2 < X.text.length && w.updateNode(S.obj, X)
                }
            })
        });
        new dm({
            source: u,
            selector: "div",
            dataGenerator: function(F) {
                return {
                    w: parseInt(F.getAttribute("data-width"), 10),
                    h: parseInt(F.getAttribute("data-height"), 10),
                    type: F.getAttribute("data-node-type")
                }
            },
            surface: y
        });
        new fm(y, "jsplumb-demo-print")
    })
});